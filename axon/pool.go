// Code generated by "goal build"; DO NOT EDIT.
//line pool.goal:1
// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package axon

import (
	"sync/atomic"
)

//gosl:start
//gosl:import "github.com/emer/axon/v2/fsfffb"

// PoolIntVars are int32 pool variables, for computing fsfffb inhibition etc.
// Note that we use int32 instead of uint32 so that overflow errors can be detected.
// See [PoolVars] for float32 variables.
type PoolIntVars int32 //enums:enum

const (
	// starting layer-wise index within the list of neurons in this pool.
	// Add layer starting neuron index (NeurSt) to get index into global
	// network neurons list.
	PoolNeurSt PoolIntVars = iota

	// ending (exclusive) layer-wise index within the list of neurons in this pool.
	// Add layer starting neuron index (NeurSt) to get index into global
	// network neurons list.
	PoolNeurEd

	// PoolIsLayer is true (> 0) if this pool represents the entire layer,
	// which is always the first pool in the list of pools for a layer.
	PoolIsLayer

	// Clamped if true (!=0), this layer is hard-clamped and should
	// use GeExts exclusively for PV.
	Clamped

	// PoolGated is true (> 0) if this pool gated (for [MatrixLayer], [BGThalLayer])
	PoolGated

	// FFsRawInt is the int32 atomic add compatible integration of [fsfffb.FFsRaw].
	FFsRawInt

	// FBsRawInt is the int32 atomic add compatible integration of [fsfffb.FBsRaw].
	FBsRawInt

	// GeExtRawInt is the int32 atomic add compatible integration of [fsfffb.GeExtRaw].
	GeExtRawInt

	// PoolIntAvgMaxStart is the starting point for int32 AvgMax variables.
	// Use AvgMaxIntVarIdx to get the relevant variable index.
	// There are only values for Cycle phase, for the different variables.
	PoolIntAvgMaxStart
)

// AvgMax are Avg and Max
type AvgMax int32 //enums:enum

const (
	Avg AvgMax = iota
	Max
)

// AvgMaxPhases are the different Phases over which AvgMax values are tracked.
type AvgMaxPhases int32 //enums:enum -trim-prefix AM

const (
	// Cycle is the current cycle, which is the source for the rest.
	AMCycle AvgMaxPhases = iota

	// Minus is at the end of the minus phase.
	AMMinus

	// Plus is at the end of the plus phase.
	AMPlus

	// Prev is at the end of the previous plus phase.
	AMPrev
)

// AvgMaxVars are the different Neuron variables for which [AvgMaxPhases]
// is computed.
type AvgMaxVars int32 //enums:enum -trim-prefix AM

const (
	// CaSpkP is the primary variable for tracking overall pool activity
	// over a recent timescale, integrated at roughly 40 msec time constant.
	AMCaSpkP AvgMaxVars = iota

	// CaSpkD is a slower moving activation signal, capable of reflecting
	// activity over the entire trial.
	AMCaSpkD

	// SpkMax is the maximum CaSpkP over the trial of processing.
	AMSpkMax

	// Act is the computed rate-code equivalent of current spike rate.
	AMAct

	// GeInt is the integrated running-average value of excitatory conductance.
	AMGeInt

	// GiInt is the integrated running-average value of inhibitory conductance.
	AMGiInt

	// AvgDif is the integrated AvgDif between ActPct - TrgAvg.
	// Only the Plus phase is used.
	AMAvgDif
)

const (
	// poolFloatAvgMaxStart is the starting index for AvgMax float32 variables.
	poolFloatAvgMaxStart = fsfffb.InhibVarsN

	PoolVarsN = poolFloatAvgMaxStart + AvgMaxVarsN*AvgMaxN*AvgMaxPhasesN + AvgMaxPhasesN*AvgMaxN
)

// mapping to neuron vars
const avgMaxToNeuron = [AMAvgDif]NeuronVars{CaSpkP, CaSpkD, SpkMax, Act, GeInt, GiInt}

// AvgMaxVarIdx returns the variable index for accessing
// [Pools] AvgMax float32 variables.
func AvgMaxVarIdx(vr AvgMaxVars, phase AvgMaxPhases, am AvgMax) uint32 {
	return uint32(PoolFloatAvgMaxStart + vr*AvgMaxN*AvgMaxPhasesN + phase*AvgMaxN + am)
}

// AvgMaxIntVarIdx returns the variable index for accessing
// [Pools] AvgMax int32 variables.  Avg = Sum actually.
// There are only values for the Cycle phase level.
func AvgMaxIntVarIdx(vr AvgMaxVars, am AvgMax) uint32 {
	return uint32(PoolIntAvgMaxStart + vr*AvgMaxN + am)
}

// PoolNNeurons returns the number of neurons in the given pool.
// pi = global pool index.
func PoolNNeurons(pi uint32) int32 {
	return PoolsInt.Value(int(PoolNeurEd), int(pi), int(0)) - PoolsInt.Value(int(PoolNeurSt), int(pi), int(0))
}

// PoolAvgMaxInit initializes the AvgMax Int accumulators for Cycle vals
// for update start. always left init'd so generally unnecessary.
// pi = global pool index.
func PoolAvgMaxInit(pi, di uint32) {
	for vr := range AvgMaxVarsN {
		PoolsInt.Set(0, int(AvgMaxIntVarIdx(vr, Avg)), int(pi), int(di))
		PoolsInt.Set(0, int(AvgMaxIntVarIdx(vr, Max)), int(pi), int(di))
	}
}

// PoolAvgMaxZero initializes all the AvgMax values to zero.
// pi = global pool index.
func PoolAvgMaxZero(pi, di uint32) {
	PoolAvgMaxInit(pi, di)
	for vr := range AvgMaxVarsN {
		for ph := range AvgMaxPhasesN {
			Pools.Set(0, int(AvgMaxVarIdx(vr, ph, Avg)), int(pi), int(di))
			Pools.Set(0, int(AvgMaxVarIdx(vr, ph, Max)), int(pi), int(di))
		}
	}
}

// PoolAvgMaxUpdate updates the AvgMax values based on current neuron values.
// pi = global pool index.
func PoolAvgMaxUpdate(pi, di, ni uint32) {
	n := float32(PoolNNeurons(pi))
	floatToInt := float32(uint32(1) << 20)
	floatToSum := floatToInt / n
	for vr := range AMAvgDif { // don't do AvgDif
		nv := math32.Abs(Neurons.Value(int(avgMaxToNeuron[vr]), int(ni), int(di))) // can't be negative
		vis := AvgMaxIntVarIdx(vr, Avg)
		vim := AvgMaxIntVarIdx(vr, Max)
		atomic.AddInt32(PoolsInt.ValuePtr(int(vis), int(pi), int(di)), int32(nv*floatToSum))
		AtomicMaxInt32(PoolsInt.ValuePtr(int(vim), int(pi), int(di)), int32(nv*floatToInt))
	}
}

// PoolAvgMaxCalc does Calc on Cycle level, and re-inits
func PoolAvgMaxCalc(pi, di uint32) {
	floatFromInt := float32(1.0) / float32(uint32(1)<<20)
	for vr := range AMAvgDif { // don't do AvgDif
		vim := AvgMaxIntVarIdx(vr, Max)
		sum := PoolsInt.Value(int(AvgMaxIntVarIdx(vr, Avg)), int(pi), int(di))
		if sum < 0 {
			//gosl:end
			log.Println("PoolAvgMaxCalc overflow in Sum", "pi:", pi, "di:", di, "sum:", sum)
			//gosl:start
			sum = int32(uint32(1) << 20)
		}
		Pools.Set(sum*floatFromInt, int(AvgMaxVarIdx(vr, AMCycle, Avg)), int(pi), int(di))
		mx := PoolsInt.Value(int(AvgMaxIntVarIdx(vr, Max)), int(pi), int(di))
		if mx < 0 {
			//gosl:end
			log.Println("PoolAvgMaxCalc overflow in Max", "pi:", pi, "di:", di, "max:", mx)
			//gosl:start
			mx = int32(uint32(1) << 20)
		}
		Pools.Set(mx*floatFromInt, int(AvgMaxVarIdx(vr, AMCycle, Max)), int(pi), int(di))
	}
}

// PoolCycleToMinus grabs current Cycle values into the Minus phase values,
// and Plus values into Prev.
func PoolCycleToMinus(pi, di uint32) {
	for vr := range AMAvgDif { // don't do AvgDif
		Pools.Set(Pools.Value(int(AvgMaxVarIdx(vr, AMCycle, Avg)), int(pi), int(di)), int(AvgMaxVarIdx(vr, AMMinus, Avg)), int(pi), int(di))
		Pools.Set(Pools.Value(int(AvgMaxVarIdx(vr, AMCycle, Max)), int(pi), int(di)), int(AvgMaxVarIdx(vr, AMMinus, Max)), int(pi), int(di))

		Pools.Set(Pools.Value(int(AvgMaxVarIdx(vr, AMPlus, Avg)), int(pi), int(di)), int(AvgMaxVarIdx(vr, AMPrev, Avg)), int(pi), int(di))
		Pools.Set(Pools.Value(int(AvgMaxVarIdx(vr, AMPlus, Max)), int(pi), int(di)), int(AvgMaxVarIdx(vr, AMPrev, Max)), int(pi), int(di))
	}
}

// PoolCycleToPlus grabs current Cycle values into the Plus phase values.
func PoolCycleToPlus(pi, di uint32) {
	for vr := range AMAvgDif { // don't do AvgDif
		Pools.Set(Pools.Value(int(AvgMaxVarIdx(vr, AMCycle, Avg)), int(pi), int(di)), int(AvgMaxVarIdx(vr, AMPlus, Avg)), int(pi), int(di))
		Pools.Set(Pools.Value(int(AvgMaxVarIdx(vr, AMCycle, Max)), int(pi), int(di)), int(AvgMaxVarIdx(vr, AMPlus, Max)), int(pi), int(di))
	}
}

// PoolInit is callled during InitActs
func PoolInit(pi, di uint32) {
	pl.Inhib.Init()
	pl.Gated.SetBool(false)
	PoolAvgMaxZero(pi, di)
}

func (pl *Pool) PoolGi(ctx *Context, di uint32) {
	if pl.IsLayPool > 0 {
		return
	}
	li := pl.LayIndex
	pl.AvgMax.Calc(int32(li))
	pl.Inhib.IntToRaw()
	ly := GetLayers(pl.LayIndex)
	giMult := LayerStates.Value(int(LayerGiMult), int(li), int(di))
	lyIsOn := (ly.Inhib.Layer.On == 1)
	pi := ly.PoolIndex(uint32(0), di)
	lpl := GetPools(pi)
	ly.SubPoolGiFromSpikes(ctx, di, pl, lpl, lyIsOn, giMult)
}

//gosl:end

// AtomicMaxInt32 performs an atomic Max operation: a = max(a, b)
func AtomicMaxInt32(a *int32, b int32) {
	old := atomic.LoadInt32(a)
	for old < b && !atomic.CompareAndSwapInt32(a, old, b) {
		old = atomic.LoadInt32(a)
	}
}

// TestValues returns a map of CaSpkD.Avg, which provides an
// integrated summary of pool activity for testing
func (pl *Pool) TestValues(layKey string, vals map[string]float32) {
	vals[layKey+" CaSpkD Avg"] = pl.AvgMax.CaSpkD.Cycle.Avg
}
