// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package axon

import (
	"log"
	"sync/atomic"

	"cogentcore.org/core/goal/gosl/slbool"
	"cogentcore.org/core/math32"
	"github.com/emer/axon/v2/fsfffb"
)

//gosl:start
//gosl:import "github.com/emer/axon/v2/fsfffb"

////////  ActAvgParams

// ActAvgParams represents the nominal average activity levels in the layer
// and parameters for adapting the computed Gi inhibition levels to maintain
// average activity within a target range.
type ActAvgParams struct {

	// nominal estimated average activity level in the layer, which is used in computing the scaling factor on sending pathways from this layer.  In general it should roughly match the layer ActAvg.ActMAvg value, which can be logged using the axon.LogAddDiagnosticItems function.  If layers receiving from this layer are not getting enough Ge excitation, then this Nominal level can be lowered to increase pathway strength (fewer active neurons means each one contributes more, so scaling factor goes as the inverse of activity level), or vice-versa if Ge is too high.  It is also the basis for the target activity level used for the AdaptGi option -- see the Offset which is added to this value.
	Nominal float32 `min:"0" step:"0.01"`

	// enable adapting of layer inhibition Gi multiplier factor (stored in layer GiMult value) to maintain a target layer level of ActAvg.Nominal.  This generally works well and improves the long-term stability of the models.  It is not enabled by default because it depends on having established a reasonable Nominal + Offset target activity level.
	AdaptGi slbool.Bool

	// offset to add to Nominal for the target average activity that drives adaptation of Gi for this layer.  Typically the Nominal level is good, but sometimes Nominal must be adjusted up or down to achieve desired Ge scaling, so this Offset can compensate accordingly.
	Offset float32 `default:"0" min:"0" step:"0.01"`

	// tolerance for higher than Target target average activation as a proportion of that target value (0 = exactly the target, 0.2 = 20% higher than target) -- only once activations move outside this tolerance are inhibitory values adapted.
	HiTol float32 `default:"0"`

	// tolerance for lower than Target target average activation as a proportion of that target value (0 = exactly the target, 0.5 = 50% lower than target) -- only once activations move outside this tolerance are inhibitory values adapted.
	LoTol float32 `default:"0.8"`

	// rate of Gi adaptation as function of AdaptRate * (Target - ActMAvg) / Target -- occurs at spaced intervals determined by Network.SlowInterval value -- slower values such as 0.01 may be needed for large networks and sparse layers.
	AdaptRate float32 `default:"0.1"`

	pad, pad1 float32
}

func (aa *ActAvgParams) Update() {
}

func (aa *ActAvgParams) Defaults() {
	aa.Nominal = 0.1
	aa.Offset = 0
	aa.HiTol = 0
	aa.LoTol = 0.8
	aa.AdaptRate = 0.1
	aa.Update()
}

func (aa *ActAvgParams) ShouldDisplay(field string) bool {
	switch field {
	case "Nominal", "AdaptGi":
		return true
	default:
		return aa.AdaptGi.IsTrue()
	}
}

// AvgFromAct updates the running-average activation given average activity level in layer
func (aa *ActAvgParams) AvgFromAct(avg *float32, act float32, dt float32) {
	if act < 0.0001 {
		return
	}
	*avg += dt * (act - *avg)
}

// Adapt adapts the given gi multiplier factor as function of target and actual
// average activation, given current params.
func (aa *ActAvgParams) Adapt(gimult *float32, act float32) bool {
	trg := aa.Nominal + aa.Offset
	del := (act - trg) / trg
	if del < -aa.LoTol || del > aa.HiTol {
		*gimult += aa.AdaptRate * del
		return true
	}
	return false
}

// InhibParams contains all the inhibition computation params and functions for basic Axon.
// This is included in LayerParams to support computation.
// Also includes the expected average activation in the layer, which is used for
// G conductance rescaling and potentially for adapting inhibition over time.
type InhibParams struct {

	// ActAvg has layer-level and pool-level average activation initial values
	// and updating / adaptation thereof.
	// Initial values help determine initial scaling factors.
	ActAvg ActAvgParams `display:"inline"`

	// Layer determines inhibition across the entire layer.
	// Input layers generally use Gi = 0.8 or 0.9, 1.3 or higher for sparse layers.
	// If the layer has sub-pools (4D shape) then this is effectively between-pool inhibition.
	Layer fsfffb.GiParams `display:"inline"`

	// Pool determines inhibition within sub-pools of units, for layers with 4D shape.
	// This is almost always necessary if the layer has sub-pools.
	Pool fsfffb.GiParams `display:"inline"`
}

func (ip *InhibParams) Update() {
	ip.ActAvg.Update()
	ip.Layer.Update()
	ip.Pool.Update()
}

func (ip *InhibParams) Defaults() {
	ip.ActAvg.Defaults()
	ip.Layer.Defaults()
	ip.Pool.Defaults()
	ip.Layer.Gi = 1.1
	ip.Pool.Gi = 1.1
}

// PoolInhib computes FSFFFB inhibition for a pool,
// based on aggregated FFs and FBs spiking values
func PoolInhib(fb *fsfffb.GiParams, pi, di uint32, gimult float32) {
	if fb.On.IsFalse() {
		PoolInhibZero(pi, di)
		return
	}
	Pools[pi, fsfffb.FFAvg, di] += fb.FFAvgDt * (Pools[pi, fsfffb.FFs, di] - Pools[pi, fsfffb.FFAvg, di])

	fsi := Pools[pi, fsfffb.FSi, di]
	fsi = fb.FSiFromFFs(fsi, Pools[pi, fsfffb.FFs, di], Pools[pi, fsfffb.FBs, di])
	Pools[pi, fsfffb.FSi, di] = fsi
	clamped := PoolsInt[pi, Clamped, di] > 0
	Pools[pi, fsfffb.FSGi, di] = fb.Gi * fb.FS(fsi, Pools[pi, fsfffb.GeExts, di], clamped)

	ssf := Pools[pi, fsfffb.SSf, di]
	ssi := Pools[pi, fsfffb.SSi, di]
	fb.SSFromFBs(&ssf, &ssi, Pools[pi, fsfffb.FBs, di])
	Pools[pi, fsfffb.SSGi, di] = fb.Gi * fb.SS * ssi
	Pools[pi, fsfffb.SSf, di] = ssf
	Pools[pi, fsfffb.SSi, di] = ssi

	Pools[pi, fsfffb.TotalGi, di] = PoolInhibGiFromFSSS(pi, di) + fb.FFPrv*Pools[pi, fsfffb.FFAvgPrv, di]
	PoolInhibSaveOrig(pi, di)
}

func PoolInhibInit(pi, di uint32) {
	PoolInhibInitRaw(pi, di)
	PoolInhibZero(pi, di)
}

// PoolInhibInitRaw clears raw spike counters -- done every cycle prior to accumulating
func PoolInhibInitRaw(pi, di uint32) {
	Pools[pi, fsfffb.FFsRaw, di] = 0.0
	Pools[pi, fsfffb.FBsRaw, di] = 0.0
	Pools[pi, fsfffb.GeExtRaw, di] = 0.0

	PoolsInt[pi, FFsRawInt, di] = 0
	PoolsInt[pi, FBsRawInt, di] = 0
	PoolsInt[pi, GeExtRawInt, di] = 0
}

// PoolInhibZero resets all accumulating inhibition factors to 0
func PoolInhibZero(pi, di uint32) {
	Pools[pi, fsfffb.FFs, di] = 0.0
	Pools[pi, fsfffb.FBs, di] = 0.0
	Pools[pi, fsfffb.GeExts, di] = 0.0
	Pools[pi, fsfffb.FSi, di] = 0.0
	Pools[pi, fsfffb.SSi, di] = 0.0
	Pools[pi, fsfffb.SSf, di] = 0.0
	Pools[pi, fsfffb.FSGi, di] = 0.0
	Pools[pi, fsfffb.SSGi, di] = 0.0
	Pools[pi, fsfffb.TotalGi, di] = 0.0
	Pools[pi, fsfffb.FFAvg, di] = 0.0
	Pools[pi, fsfffb.FFAvgPrv, di] = 0.0
	Pools[pi, fsfffb.GiOrig, di] = 0.0
	Pools[pi, fsfffb.LayGi, di] = 0.0
	PoolsInt[pi, Clamped, di] = 0
}

// Decay reduces inhibition values by given decay proportion
func PoolInhibDecay(pi, di uint32, decay float32) {
	Pools[pi, fsfffb.FFAvgPrv, di] = Pools[pi, fsfffb.FFAvg, di] // capture prior to decay

	Pools[pi, fsfffb.FFs, di] -= decay * Pools[pi, fsfffb.FFs, di]
	Pools[pi, fsfffb.FBs, di] -= decay * Pools[pi, fsfffb.FBs, di]
	Pools[pi, fsfffb.GeExts, di] -= decay * Pools[pi, fsfffb.GeExts, di]
	Pools[pi, fsfffb.FSi, di] -= decay * Pools[pi, fsfffb.FSi, di]
	Pools[pi, fsfffb.SSi, di] -= decay * Pools[pi, fsfffb.SSi, di]
	Pools[pi, fsfffb.SSf, di] -= decay * Pools[pi, fsfffb.SSf, di]
	Pools[pi, fsfffb.FSGi, di] -= decay * Pools[pi, fsfffb.FSGi, di]
	Pools[pi, fsfffb.SSGi, di] -= decay * Pools[pi, fsfffb.SSGi, di]
	Pools[pi, fsfffb.TotalGi, di] -= decay * Pools[pi, fsfffb.TotalGi, di]
	Pools[pi, fsfffb.FFAvg, di] -= decay * Pools[pi, fsfffb.FFAvg, di]
}

// SpikesFromRaw updates spike values from raw, dividing by given number in pool
func PoolInhibSpikesFromRaw(pi, di uint32) {
	fnn := float32(PoolNNeurons(pi))
	Pools[pi, fsfffb.FBs, di] = Pools[pi, fsfffb.FBsRaw, di] / fnn
	Pools[pi, fsfffb.FFs, di] = Pools[pi, fsfffb.FFsRaw, di]
	Pools[pi, fsfffb.GeExts, di] = Pools[pi, fsfffb.GeExtRaw, di]
	PoolInhibInitRaw(pi, di)
}

// SaveOrig saves the current Gi values as original values
func PoolInhibSaveOrig(pi, di uint32) {
	Pools[pi, fsfffb.GiOrig, di] = Pools[pi, fsfffb.TotalGi, di]
}

// GiFromFSSS returns the sum of FSGi and SSGi as overall inhibition
func PoolInhibGiFromFSSS(pi, di uint32) float32 {
	return Pools[pi, fsfffb.FSGi, di] + Pools[pi, fsfffb.SSGi, di]
}

// LayerMax updates given pool-level inhib values from given layer-level Gi
// with resulting value being the Max of either
func PoolInhibLayerMax(pi, di uint32, liGi float32) {
	Pools[pi, fsfffb.LayGi, di] = liGi
	Pools[pi, fsfffb.TotalGi, di] = math32.Max(Pools[pi, fsfffb.TotalGi, di], liGi)
}

// PoolMax updates given layer-level inhib values from given pool-level
// with resulting value being the Max of either
func PoolInhibPoolMax(pi, di uint32, piGi float32) {
	Pools[pi, fsfffb.TotalGi, di] = math32.Max(Pools[pi, fsfffb.TotalGi, di], piGi)
}

//////// atomic int safe accumulation

// RawIncrInt increments raw values from given neuron-based input values
// for the int-based values (typically use Atomic InterlockedAdd instead)
func PoolInhibRawIncrInt(pi, di uint32, spike, geRaw, geExt float32) {
	floatToInt := float32(uint32(1) << 24)
	fnn := float32(PoolNNeurons(pi))
	atomic.AddInt32(&PoolsInt[pi, FBsRawInt, di], int32(spike))
	atomic.AddInt32(&PoolsInt[pi, FFsRawInt, di], int32((geRaw/fnn)*floatToInt))
	atomic.AddInt32(&PoolsInt[pi, GeExtRawInt, di], int32((geExt/fnn)*floatToInt))
}

// IntToRaw computes int values into float32 raw values
func PoolInhibIntToRaw(pi, di uint32) {
	floatFromInt := 1.0 / float32(uint32(1)<<24)
	fbs := PoolsInt[pi, FBsRawInt, di]
	ffs := PoolsInt[pi, FFsRawInt, di]
	geExt := PoolsInt[pi, GeExtRawInt, di]
	//gosl:end
	floatToInt := int32(1) << 24
	if ffs < 0 {
		log.Println("PoolInhibIntToRaw overflow in FFsRawInt", "pi:", pi, "di:", di, "val:", ffs)
		ffs = floatToInt
	}
	if geExt < 0 {
		log.Println("PoolInhibIntToRaw overflow in GeExtRawInt", "pi:", pi, "di:", di, "val:", geExt)
		geExt = floatToInt
	}
	//gosl:start
	Pools[pi, fsfffb.FBsRaw, di] = float32(fbs)
	Pools[pi, fsfffb.FFsRaw, di] = float32(ffs) * floatFromInt
	Pools[pi, fsfffb.GeExtRaw, di] = float32(geExt) * floatFromInt
}

//gosl:end
