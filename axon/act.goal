// Copyright (c) 2019, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package axon

import (
	"math"

	"cogentcore.org/lab/base/randx"
	"cogentcore.org/lab/gosl/slbool"
	"cogentcore.org/core/math32"
	"cogentcore.org/core/math32/minmax"
	"github.com/emer/axon/v2/chans"
)

////////  act.go contains the activation params and functions for axon

//gosl:start
//gosl:import "cogentcore.org/core/math32"
//gosl:import "cogentcore.org/core/math32/minmax"
//gosl:import "github.com/emer/axon/v2/chans"

// NeuronHasFlag
func NeuronHasFlag(flag NeuronFlags, ni, di uint32) bool {
	return (NeuronFlags(math.Float32bits(Neurons[ni, di, NeurFlags])) & flag) > 0 // weird: != 0 does NOT work on GPU
}

func NeuronSetFlag(flag NeuronFlags, ni, di uint32) {
	Neurons[ni, di, NeurFlags] = math.Float32frombits(math.Float32bits(Neurons[ni, di, NeurFlags]) | uint32(flag))
}

func NeuronClearFlag(flag NeuronFlags, ni, di uint32) {
	Neurons[ni, di, NeurFlags] = math.Float32frombits(math.Float32bits(Neurons[ni, di, NeurFlags]) &^ uint32(flag))
}

// NeuronIsOff returns true if the neuron has been turned off (lesioned)
// Only checks the first data item -- all should be consistent.
func NeuronIsOff(ni uint32) bool {
	return NeuronHasFlag(NeuronOff, ni, 0)
}

////////  SpikeParams

// SpikeParams contains spiking activation function params.
// Implements a basic thresholded Vm model, and optionally
// the AdEx adaptive exponential function.
type SpikeParams struct {

	// Thr is the spiking threshold value Theta (Î˜) for firing output activation,
	// in mV (millivolts). See also ExpThr for the AdEx implementation,
	// in which case this threshold is the V_t parameters for the exponential function.
	Thr float32 `default:"-50"`

	// VmR is the post-spiking membrane potential to reset to, in mV.
	// This produces refractory effect if lower than VmInit.
	// -70 is appropriate biologically based value for AdEx (Brette & Gurstner, 2005)
	// parameters. See also RTau.
	VmR float32 `default:"-70"`

	// Tr is the post-spiking explicit refractory period, in cycles.
	// Prevents Vm updating for this number of cycles post firing.
	// Vm is reduced in exponential steps over this period according to RTau,
	// being fixed at Tr to VmR exactly.
	Tr int32 `min:"1" default:"3"`

	// RTau is the time constant for decaying Vm down to VmR. At end of Tr it is set
	// to VmR exactly. This provides a more realistic shape of the post-spiking
	// Vm which is only relevant for more realistic channels that key off of Vm.
	// Does not otherwise affect standard computation.
	RTau float32 `default:"1.6667"`

	// Exp turns on the AdEx exponential excitatory current that drives Vm rapidly
	// upward for spiking as it gets past its nominal firing threshold (Thr).
	// Efficiently captures the Hodgkin Huxley dynamics of Na and K channels
	// (Brette & Gurstner 2005).
	Exp slbool.Bool `default:"true"`

	// ExpSlope is the slope in mV for extra exponential excitatory current in AdEx.
	ExpSlope float32 `default:"2"`

	// ExpThr is the membrane potential threshold (mV) for actually triggering
	// a spike when using the exponential mechanism. Due to 1 ms time integration,
	// this doesn't have much impact as long as it is above nominal spike threshold,
	// and inside the VmRange for clipping Vm.
	ExpThr float32 `default:"-10"`

	// MaxHz is for translating spiking interval (rate) into rate-code activation
	// equivalent, as the maximum firing rate associated with a maximum
	// activation value of 1.
	MaxHz float32 `default:"180" min:"1"`

	// ISITau is the time constant for integrating the spiking interval in
	// estimating spiking rate.
	ISITau float32 `default:"5" min:"1"`

	// ISIDt = 1 / tau
	ISIDt float32 `display:"-"`

	// RDt = 1 / tau
	RDt float32 `display:"-"`

	pad int32
}

func (sk *SpikeParams) Defaults() {
	sk.Thr = -50
	sk.VmR = -70
	sk.Tr = 3
	sk.RTau = 1.6667
	sk.Exp.SetBool(true)
	sk.ExpSlope = 2
	sk.ExpThr = -10
	sk.MaxHz = 180
	sk.ISITau = 5
	sk.Update()
}

func (sk *SpikeParams) Update() {
	if sk.Tr <= 0 {
		sk.Tr = 1 // hard min
	}
	sk.ISIDt = 1 / sk.ISITau
	sk.RDt = 1 / sk.RTau
}

func (sk *SpikeParams) ShouldDisplay(field string) bool {
	switch field {
	case "ExpSlope", "ExpThr":
		return sk.Exp.IsTrue()
	default:
		return true
	}
}

// ActToISI compute spiking interval from a given rate-coded activation,
// based on time increment (.001 = 1msec default), Act.Dt.Integ
func (sk *SpikeParams) ActToISI(act, timeInc, integ float32) float32 {
	if act == 0 {
		return 0
	}
	return (1 / (timeInc * integ * act * sk.MaxHz))
}

// ActFromISI computes rate-code activation from estimated spiking interval
func (sk *SpikeParams) ActFromISI(isi, timeInc, integ float32) float32 {
	if isi <= 0 {
		return 0
	}
	maxInt := 1.0 / (timeInc * integ * sk.MaxHz) // interval at max hz..
	return maxInt / isi                          // normalized
}

// AvgFromISI returns updated spiking ISI from current isi interval value
func (sk *SpikeParams) AvgFromISI(avg float32, isi float32) float32 {
	av := avg
	if av <= 0 {
		av = isi
	} else if isi < 0.8*av {
		av = isi // if significantly less than we take that
	} else { // integrate on slower
		av += sk.ISIDt * (isi - av) // running avg updt
	}
	return av
}

////////  DendParams

// DendParams are the parameters for updating dendrite-specific dynamics
type DendParams struct {

	// GExp is the dendrite-specific strength multiplier of the exponential
	// spiking drive on Vm. E.g., .5 makes it half as strong as at the soma.
	GExp float32 `default:"0.2,0.5"`

	// GR is the dendrite-specific additional conductance of Kdr delayed
	// rectifier currents, used to reset membrane potential for dendrite.
	// Applied for Tr cycles (ms).
	GR float32 `default:"3,6"`

	// SSGi is the SST+ somatostatin positive slow spiking inhibition level
	// specifically affecting dendritic Vm (VmDend). This is important for countering
	// a positive feedback loop from NMDA getting stronger over the course
	// of learning. Also typically requires SubMean = 1 for TrgAvgAct and
	// learning to fully counter this feedback loop.
	SSGi float32 `default:"0,2"`

	// HasMod is set automatically based on whether this layer has any recv pathways
	// that have a GType conductance type of Modulatory.
	// If so, then multiply GeSyn etc by GModSyn.
	HasMod slbool.Bool `edit:"-"`

	// ModGain is a multiplicative gain factor on the total modulatory input.
	// This can also be controlled by the PathScale.Abs factor on
	// ModulatoryG inputs, but it is convenient to be able to control
	// on the layer as well.
	ModGain float32

	// ModACh if true, modulatory signal also includes ACh multiplicative factor.
	ModACh slbool.Bool

	// ModBase is the baseline modulatory level for modulatory effects. 
	// Net modulation is ModBase + ModGain * GModSyn
	ModBase float32

	pad int32
}

func (dp *DendParams) Defaults() {
	dp.SSGi = 2
	dp.GExp = 0.2
	dp.GR = 3
	dp.ModGain = 1
	dp.ModBase = 0
}

func (dp *DendParams) Update() {
}

func (dp *DendParams) ShouldDisplay(field string) bool {
	switch field {
	case "ModGain", "ModACh", "ModBase":
		return dp.HasMod.IsTrue()
	default:
		return true
	}
}

////////  ActInitParams

// ActInitParams are initial values for key network state variables.
// Initialized in InitActs called by InitWeights, and provides target values
// for DecayState.
type ActInitParams struct {

	// Vm initial membrane potential in mV (millivolts).
	// See Erev.L for the resting potential, typically -70.
	Vm float32 `default:"-70"`

	// Act is the initial activation value. Typically 0.
	Act float32 `default:"0"`

	// GeBase is the baseline level of excitatory conductance (net input).
	// Ge is initialized to this value, and it is added in as a constant
	// background level of excitatory input, to capture all the other
	// inputs not represented in the model, and intrinsic excitability, etc.
	GeBase float32 `default:"0"`

	// GiBase baseline level of inhibitory conductance (net input)
	// Gi is initialized to this value, and it is added in as a constant
	// background level of inhibitory input. Captures all the other inputs
	// not represented in the model.
	GiBase float32 `default:"0"`

	// GeVar is the variance (sigma) of gaussian distribution around baseline
	// Ge values, per neuron, to establish variability in intrinsic excitability.
	// Value never goes < 0.
	GeVar float32 `default:"0"`

	// GiVar is the variance (sigma) of gaussian distribution around baseline
	// Gi values, per neuron, to establish variability in intrinsic excitability.
	// Value never goes < 0
	GiVar float32 `default:"0"`

	pad, pad1 int32
}

func (ai *ActInitParams) Update() {
}

func (ai *ActInitParams) Defaults() {
	ai.Vm = -70
	ai.Act = 0
	ai.GeBase = 0
	ai.GiBase = 0
	ai.GeVar = 0
	ai.GiVar = 0
}

//gosl:end

// note: these are only called in CPU during init.

// GeBase returns the baseline Ge value: Ge + rand(GeVar) > 0
func (ai *ActInitParams) GetGeBase(rnd randx.Rand) float32 {
	ge := ai.GeBase
	if ai.GeVar > 0 {
		ge += float32(float64(ai.GeVar) * rnd.NormFloat64())
		if ge < 0 {
			ge = 0
		}
	}
	return ge
}

// GiBase returns the baseline Gi value: Gi + rand(GiVar) > 0
func (ai *ActInitParams) GetGiBase(rnd randx.Rand) float32 {
	gi := ai.GiBase
	if ai.GiVar > 0 {
		gi += float32(float64(ai.GiVar) * rnd.NormFloat64())
		if gi < 0 {
			gi = 0
		}
	}
	return gi
}

//gosl:start

////////  DecayParams

// DecayParams control the decay of activation state in the DecayState function
// called in NewState when a new state is to be processed.
type DecayParams struct {

	// Act is proportion to decay most activation state variables toward initial
	// values at start of every ThetaCycle (except those controlled separately below).
	// If 1 it is effectively equivalent to full clear, resetting other derived values.
	// ISI is reset every AlphaCycle to get a fresh sample of activations
	// (doesn't affect direct computation -- only readout).
	Act float32 `default:"0,0.2,0.5,1" max:"1" min:"0"`

	// Glong is proportion to decay long-lasting conductances, NMDA and GABA,
	// and also the dendritic membrane potential -- when using random stimulus
	// order, it is important to decay this significantly to allow a fresh start,
	// but set Act to 0 to enable ongoing activity to keep neurons in their
	// sensitive regime.
	Glong float32 `default:"0,0.6" max:"1" min:"0"`

	// AHP is decay of afterhyperpolarization currents, including mAHP, sAHP,
	// and KNa, Kir. Has a separate decay because often useful to have this
	// not decay at all even if decay is on.
	AHP float32 `default:"0" max:"1" min:"0"`

	// LearnCa is decay of Ca variables driven by spiking activity used in learning:
	// CaSpike* and Ca* variables. These are typically not decayed but may
	// need to be in some situations.
	LearnCa float32 `default:"0" max:"1" min:"0"`

	// OnRew means decay layer at end of ThetaCycle when there is a global reward.
	// true by default for PTPred, PTMaint and PFC Super layers.
	OnRew slbool.Bool

	pad, pad1, pad2 float32
}

func (dp *DecayParams) Update() {
}

func (dp *DecayParams) Defaults() {
	dp.Act = 0.2
	dp.Glong = 0.6
	dp.AHP = 0
	dp.LearnCa = 0
}

////////  DtParams

// DtParams are time and rate constants for temporal derivatives in Axon (Vm, G)
type DtParams struct {

	// Integ is the overall rate constant for numerical integration, for all equations
	// at the neuron level. All time constants are specified in ms millisecond units,
	// with one cycle = 1 ms. If you instead want to make one cycle = 2 ms, you can do
	// this globally by setting this integ value to 2 (etc).
	// However, stability issues will likely arise if you go too high.
	// For improved numerical stability, you may even need to reduce this value
	// to 0.5 or possibly even lower (typically however this is not necessary).
	Integ float32 `default:"1" min:"0"`

	// VmC is the membrane potential capacitance in pF (picofarads), which 
	// determines the rate of Vm updating over time.
	VmC float32 `default:"281" min:"1"`

	// VmDendC is the effective dendritic membrane capacitance in pF (picofarads),
	// which is typically slower than VmC (also reflecting other dendritic dynamics).
	VmDendC float32 `default:"500" min:"1"`

	// VmSteps are the number of integration steps to take in computing new Vm value.
	// This is the one computation that can be most numerically unstable
	// so taking multiple steps with proportionally smaller dt is beneficial.
	VmSteps int32 `default:"2" min:"1"`

	// GeTau is the time constant for decay of excitatory AMPA receptor
	// conductance in ms (milliseconds).
	GeTau float32 `default:"5" min:"1"`

	// GiTau is the time constant for decay of inhibitory GABA-A receptor
	// conductance in ms (milliseconds).
	GiTau float32 `default:"7" min:"1"`

	// IntTau is a time constant for integrating values over timescale of an
	// individual input state (e.g., roughly the 200 msec theta cycle),
	// used in computing ActInt, GeInt from Ge, and GiInt from GiSyn.
	// This is used for scoring performance, not for learning, in cycles,
	// which should be milliseconds typically
	// (Tau is roughly 2/3 of the way to asymptote).
	IntTau float32 `default:"40" min:"1"`

	// LongAvgTau is a time constant for integrating slower long-time-scale averages,
	// such as ActAvg, Pool.ActsMAvg, ActsPAvg. Computed in NewState
	// when a new input state is present (i.e., not msec but in units
	// of a theta cycle) (Tau is roughly 2/3 of the way to asymptote).
	// Set lower for smaller models.
	LongAvgTau float32 `default:"20" min:"1"`

	// maxCycStart is the cycle to start updating the CaPMaxCa, CaPMax values
	// within a theta cycle. Early cycles often reflect prior state.
	MaxCycStart int32 `default:"10" min:"0"`

	// VmDT = Integ / VmC
	VmDt float32 `display:"-" json:"-" xml:"-"`

	// VmDendDt = Integ / VmDendC
	VmDendDt float32 `display:"-" json:"-" xml:"-"`

	// DtStep = 1 / VmSteps
	DtStep float32 `display:"-" json:"-" xml:"-"`

	// GeDt = Integ / GeTau
	GeDt float32 `display:"-" json:"-" xml:"-"`

	// GiDt = Integ / GiTau
	GiDt float32 `display:"-" json:"-" xml:"-"`

	// IntDt = Integ / IntTau
	IntDt float32 `display:"-" json:"-" xml:"-"`

	// LongAvgDt = 1 / LongAvgTau
	LongAvgDt float32 `display:"-" json:"-" xml:"-"`

	// MaxI = VmC * 100 nS nominal max conductance = maximum I current step.
	MaxI float32 `display:"-" json:"-" xml:"-"`
	
	pad, pad1, pad2 float32
}

func (dp *DtParams) Update() {
	if dp.VmSteps < 1 {
		dp.VmSteps = 1
	}
	dp.VmDt = dp.Integ / dp.VmC
	dp.VmDendDt = dp.Integ / dp.VmDendC
	dp.DtStep = 1 / float32(dp.VmSteps)
	dp.GeDt = dp.Integ / dp.GeTau
	dp.GiDt = dp.Integ / dp.GiTau
	dp.IntDt = dp.Integ / dp.IntTau
	dp.LongAvgDt = 1 / dp.LongAvgTau
	dp.MaxI = dp.VmC * 100
}

func (dp *DtParams) Defaults() {
	dp.Integ = 1
	dp.VmC = 281
	dp.VmDendC = 500
	dp.VmSteps = 2
	dp.GeTau = 5
	dp.GiTau = 7
	dp.IntTau = 40
	dp.LongAvgTau = 20
	dp.MaxCycStart = 10
	dp.Update()
}

// GeSynFromRaw integrates a synaptic conductance from raw spiking using GeTau
func (dp *DtParams) GeSynFromRaw(geSyn, geRaw float32) float32 {
	return geSyn + geRaw - dp.GeDt*geSyn
}

// GeSynFromRawSteady returns the steady-state GeSyn that would result from
// receiving a steady increment of GeRaw every time step = raw * GeTau.
// dSyn = Raw - dt*Syn; solve for dSyn = 0 to get steady state:
// dt*Syn = Raw; Syn = Raw / dt = Raw * Tau
func (dp *DtParams) GeSynFromRawSteady(geRaw float32) float32 {
	return geRaw * dp.GeTau
}

// GiSynFromRaw integrates a synaptic conductance from raw spiking using GiTau
func (dp *DtParams) GiSynFromRaw(giSyn, giRaw float32) float32 {
	return giSyn + giRaw - dp.GiDt*giSyn
}

// GiSynFromRawSteady returns the steady-state GiSyn that would result from
// receiving a steady increment of GiRaw every time step = raw * GiTau.
// dSyn = Raw - dt*Syn; solve for dSyn = 0 to get steady state:
// dt*Syn = Raw; Syn = Raw / dt = Raw * Tau
func (dp *DtParams) GiSynFromRawSteady(giRaw float32) float32 {
	return giRaw * dp.GiTau
}

// AvgVarUpdate updates the average and variance from current value, using LongAvgDt
func (dp *DtParams) AvgVarUpdate(avg, vr *float32, val float32) {
	if *avg == 0 { // first time -- set
		*avg = val
		*vr = 0
	} else {
		del := val - *avg
		incr := dp.LongAvgDt * del
		*avg += incr
		// following is magic exponentially weighted incremental variance formula
		// derived by Finch, 2009: Incremental calculation of weighted mean and variance
		if *vr == 0 {
			*vr = 2 * (1 - dp.LongAvgDt) * del * incr
		} else {
			*vr = (1 - dp.LongAvgDt) * (*vr + del*incr)
		}
	}
}

////////  Noise

// SpikeNoiseParams parameterizes background spiking activity impinging on the neuron,
// simulated using a poisson spiking process.
type SpikeNoiseParams struct {

	// On switch to add noise simulating background spiking levels.
	On slbool.Bool

	// GeHz is the mean frequency of excitatory spikes. Typically 50Hz but multiple
	// inputs increase rate. This is a poisson lambda parameter, also the variance.
	GeHz float32 `default:"100"`

	// Ge is the excitatory conductance per spike. 0.001 has minimal impact,
	// 0.01 can be strong, and .15 is needed to influence timing of clamped inputs.
	Ge float32 `min:"0"`

	// GiHz is the mean frequency of inhibitory spikes. Typically 100Hz fast spiking
	// but multiple inputs increase rate. This is a poisson lambda parameter,
	// also the variance.
	GiHz float32 `default:"200"`

	// Gi is the excitatory conductance per spike. 0.001 has minimal impact,
	// 0.01 can be strong, and .15 is needed to influence timing of clamped inputs.
	Gi float32 `min:"0"`

	// MaintGe adds Ge noise to GeMaintRaw instead of standard Ge.
	// used for PTMaintLayer for example.
	MaintGe slbool.Bool

	// GeExpInt = Exp(-Interval) which is the threshold for GeNoiseP as it is updated.
	GeExpInt float32 `display:"-" json:"-" xml:"-"`

	// GiExpInt = Exp(-Interval) which is the threshold for GiNoiseP as it is updated.
	GiExpInt float32 `display:"-" json:"-" xml:"-"`
}

func (an *SpikeNoiseParams) Update() {
	an.GeExpInt = math32.Exp(-1000.0 / an.GeHz)
	an.GiExpInt = math32.Exp(-1000.0 / an.GiHz)
}

func (an *SpikeNoiseParams) Defaults() {
	an.GeHz = 100
	an.Ge = 0.001
	an.GiHz = 200
	an.Gi = 0.001
	an.Update()
}

func (an *SpikeNoiseParams) ShouldDisplay(field string) bool {
	switch field {
	case "On":
		return true
	default:
		return an.On.IsTrue()
	}
}

// PGe updates the GeNoiseP probability, multiplying a uniform random number [0-1]
// and returns Ge from spiking if a spike is triggered
func (an *SpikeNoiseParams) PGe(ctx *Context, p *float32, ni, di uint32) float32 {
	nix := GetNetworkIxs(0)
	ndi := di*nix.NNeurons + ni
	*p *= GetRandomNumber(ndi, ctx.RandCounter.Counter, RandFunActPGe)
	if *p <= an.GeExpInt {
		*p = 1
		return an.Ge
	}
	return 0
}

// PGi updates the GiNoiseP probability, multiplying a uniform random number [0-1]
// and returns Gi from spiking if a spike is triggered.
func (an *SpikeNoiseParams) PGi(ctx *Context, p *float32, ni, di uint32) float32 {
	nix := GetNetworkIxs(0)
	ndi := di*nix.NNeurons + ni
	*p *= GetRandomNumber(ndi, ctx.RandCounter.Counter, RandFunActPGi)
	if *p <= an.GiExpInt {
		*p = 1
		return an.Gi
	}
	return 0
}

////////  ClampParams

// ClampParams specify how external inputs drive excitatory conductances
// (like a current clamp) -- either adds or overwrites existing conductances.
// Noise is added in either case.
type ClampParams struct {

	// Ge is the contribution to Ge(t) for clamped external input.
	// Generally use .8 for Target layers, 1.50 for Input layers.
	// This is later multiplied by overall gbar_e which converts to nS units.
	Ge float32 `default:"0.8,1.5"`

	// Add external conductance on top of any existing.
	// Generally this is not a good idea for target layers
	// (creates a main effect that learning can never match),
	// but may be ok for input layers.
	Add slbool.Bool `default:"false"`

	// ErrThr is the threshold on neuron Act activity to count as active for
	// computing the error relative to target in PctErr method.
	ErrThr float32 `default:"0.5"`

	pad float32
}

func (cp *ClampParams) Update() {
}

func (cp *ClampParams) Defaults() {
	cp.Ge = 0.8
	cp.ErrThr = 0.5
}

////////  SMaintParams

// SMaintParams for self-maintenance simulating a population of
// NMDA-interconnected spiking neurons
type SMaintParams struct {

	// On switch for self maintenance.
	On slbool.Bool

	// NNeurons is the number of neurons within the self-maintenance pool,
	// each of which is assumed to have the same probability of spiking.
	NNeurons float32 `default:"10"`

	// Ge is the excitatory conductance multiplier for self maintenance synapses.
	Ge float32 `default:"0.2"`

	// Inhib controls how much of the extra maintenance conductance goes
	// to the GeExt, which drives extra proportional inhibition.
	Inhib float32 `default:"1"`

	// ISI (inter spike interval) range. Min is used as min ISIAvg
	// for poisson spike rate expected from the population,
	// and above Max, no additional maintenance conductance is added.
	ISI minmax.F32 `display:"inline"`
}

func (sm *SMaintParams) Defaults() {
	sm.NNeurons = 10
	sm.ISI.Set(1, 20)
	sm.Ge = 0.2
	sm.Inhib = 1
}

func (sm *SMaintParams) Update() {
}

func (sm *SMaintParams) ShouldDisplay(field string) bool {
	switch field {
	case "On":
		return true
	default:
		return sm.On.IsTrue()
	}
}

// ExpInt returns the exponential interval value for determining
// when the next excitatory spike will arrive, based on given ISI
// value for this neuron.
func (sm *SMaintParams) ExpInt(isi float32) float32 {
	if isi <= 0 {
		return 0
	}
	return math32.FastExp(-max(isi, sm.ISI.Min) / sm.NNeurons)
}

////////  PopCodeParams

// PopCodeParams provides an encoding of scalar value using population code,
// where a single continuous (scalar) value is encoded as a gaussian bump
// across a population of neurons (1 dimensional).
// It can also modulate rate code and number of neurons active according to the value.
// This is for layers that represent values as in the Rubicon system.
// Both normalized activation values (1 max) and Ge conductance values can be generated.
type PopCodeParams struct {

	// On toggles use of popcode encoding of variable(s) that this layer represents.
	On slbool.Bool

	// Ge multiplier for driving excitatory conductance based on PopCode.
	// Multiplies normalized activation values and adds to total Ge(t)
	// which is later multiplied by Gbar.E for pA unit scaling.
	Ge float32 `default:"0.1"`

	// Min is the minimum value representable. For GaussBump, typically include
	// extra to allow mean with activity on either side to represent
	// the lowest value you want to encode.
	Min float32 `default:"-0.1"`

	// Max is the maximum value representable. For GaussBump, typically include
	// extra to allow mean with activity on either side to represent
	// the lowest value you want to encode.
	Max float32 `default:"1.1"`

	// MinAct is an activation multiplier for values at Min end of range,
	// where values at Max end have an activation of 1.
	// If this is < 1, then there is a rate code proportional
	// to the value in addition to the popcode pattern. See also MinSigma, MaxSigma.
	MinAct float32 `default:"1,0.5"`

	// MinSigma is the sigma parameter of a gaussian specifying the tuning width
	// of the coarse-coded units, in normalized 0-1 range, for values at the Min
	// end of the range. If MinSigma < MaxSigma then more units are activated
	// for Max values vs. Min values, proportionally.
	MinSigma float32 `default:"0.1,0.08"`

	// MaxSigma is the sigma parameter of a gaussian specifying the tuning width
	// of the coarse-coded units, in normalized 0-1 range, for values at the Max
	// end of the range. If MinSigma < MaxSigma then more units are activated
	// for Max values vs. Min values, proportionally.
	MaxSigma float32 `default:"0.1,0.12"`

	// Clip ensures that encoded and decoded value remains within specified range.
	Clip slbool.Bool
}

func (pc *PopCodeParams) Defaults() {
	pc.Ge = 0.1
	pc.Min = -0.1
	pc.Max = 1.1
	pc.MinAct = 1
	pc.MinSigma = 0.1
	pc.MaxSigma = 0.1
	pc.Clip.SetBool(true)
}

func (pc *PopCodeParams) Update() {
}

func (pc *PopCodeParams) ShouldDisplay(field string) bool {
	switch field {
	case "On":
		return true
	default:
		return pc.On.IsTrue()
	}
}

// SetRange sets the min, max and sigma values
func (pc *PopCodeParams) SetRange(min, max, minSigma, maxSigma float32) {
	pc.Min = min
	pc.Max = max
	pc.MinSigma = minSigma
	pc.MaxSigma = maxSigma
}

// ClipVal returns clipped (clamped) value in min / max range
func (pc *PopCodeParams) ClampValue(val float32) float32 {
	clipVal := val
	if clipVal < pc.Min {
		clipVal = pc.Min
	}
	if clipVal > pc.Max {
		clipVal = pc.Max
	}
	return clipVal
}

// ProjectParam projects given min / max param value onto val within range
func (pc *PopCodeParams) ProjectParam(minParam, maxParam, clipVal float32) float32 {
	normVal := (clipVal - pc.Min) / (pc.Max - pc.Min)
	return minParam + normVal*(maxParam-minParam)
}

// EncodeValue returns value for given value, for neuron index i
// out of n total neurons. n must be 2 or more.
func (pc *PopCodeParams) EncodeValue(i, n uint32, val float32) float32 {
	eval := val
	clipVal := pc.ClampValue(eval)
	if pc.Clip.IsTrue() {
		eval = clipVal
	}
	rng := pc.Max - pc.Min
	act := float32(1)
	if pc.MinAct < 1 {
		act = pc.ProjectParam(pc.MinAct, 1.0, clipVal)
	}
	sig := pc.MinSigma
	if pc.MaxSigma > pc.MinSigma {
		sig = pc.ProjectParam(pc.MinSigma, pc.MaxSigma, clipVal)
	}
	gnrm := 1.0 / (rng * sig)
	incr := rng / float32(n-1)
	trg := pc.Min + incr*float32(i)
	dist := gnrm * (trg - eval)
	return act * math32.FastExp(-(dist * dist))
}

// EncodeGe returns Ge value for given value, for neuron index i
// out of n total neurons. n must be 2 or more.
func (pc *PopCodeParams) EncodeGe(i, n uint32, val float32) float32 {
	return pc.Ge * pc.EncodeValue(i, n, val)
}

////////  ActParams

// ActParams contains all the neural activity computation params and functions
// for Axon, at the neuron level. This is included in [LayerParams].
type ActParams struct {

	// Spikes are spiking function parameter, including the AdEx spiking function.
	Spikes SpikeParams `display:"inline"`

	// Dend are dendrite-specific parameters, which more accurately approximate
	// the electrical dynamics present in dendrites vs the soma.
	Dend DendParams `display:"inline"`

	// Init has initial values for key network state variables.
	// Initialized in InitActs called by InitWeights, and provides target
	// values for DecayState.
	Init ActInitParams `display:"inline"`

	// Decay is the amount to decay between theta cycles, simulating the passage
	// of time and effects of saccades etc. It is especially important for
	// environments with random temporal structure (e.g., most standard neural net
	// training corpora).
	Decay DecayParams `display:"inline"`

	// Dt has time and rate constants for temporal derivatives / updating of
	// activation state.
	Dt DtParams `display:"inline"`

	// Gbar has maximal conductances levels for channels, in nS (nanosiemens).
	// Most other conductances are computed as time-varying proportions of these
	// values (strict 1 max is not enforced and can be exceeded).
	Gbar chans.Chans `display:"inline"`

	// Erev are reversal / driving potentials for each channel, in mV (millivolts).
	// Current is a function of the difference between these driving potentials
	// and the membrane potential Vm, and goes to 0 (and reverses sign) as it
	// crosses equality.
	Erev chans.Chans `display:"inline"`

	// Clamp determines how external inputs drive excitatory conductance.
	Clamp ClampParams `display:"inline"`

	// Noise specifies how, where, when, and how much noise to add.
	Noise SpikeNoiseParams `display:"inline"`

	// VmRange constrains the range of the Vm membrane potential, 
	// which helps to prevent numerical instability.
	VmRange minmax.F32 `display:"inline"`

	// Mahp is the M-type medium time-scale afterhyperpolarization (mAHP) current.
	// This is the primary form of adaptation on the time scale of
	// multiple sequences of spikes.
	Mahp chans.MahpParams `display:"inline"`

	// Sahp is the slow time-scale afterhyperpolarization (sAHP) current.
	// It integrates CaD at theta cycle intervals and produces a hard cutoff
	// on sustained activity for any neuron.
	Sahp chans.SahpParams `display:"inline"`

	// KNa has the sodium-gated potassium channel adaptation parameters.
	// It activates a leak-like current as a function of neural activity
	// (firing = Na influx) at two different time-scales (Slick = medium, Slack = slow).
	KNa chans.KNaMedSlow `display:"inline"`

	// Kir is the potassium (K) inwardly rectifying (ir) current, which
	// is similar to GABA-B (which is a GABA modulated Kir channel).
	// This channel is off by default but plays a critical role in making medium
	// spiny neurons (MSNs) relatively quiet in the striatum.
	Kir chans.KirParams `display:"inline"`

	// NMDA has channel parameters used in computing the Gnmda conductance
	// that is maximal for more depolarized neurons (due to unblocking of 
	// Mg++ ions), and thus helps keep active neurons active, thereby promoting
	// overall neural stability over time. See also Learn.LearnNMDA for
	// distinct parameters used for Ca++ influx driving learning, and
	// MaintNMDA for specialized NMDA driven by maintenance pathways.
	NMDA chans.NMDAParams `display:"inline"`

	// MaintNMDA has channel parameters used in computing the Gnmda conductance
	// based on pathways of the MaintG conductance type, e.g., in the PT PFC neurons.
	// This is typically stronger and longer lasting than standard NMDA.
	MaintNMDA chans.NMDAParams `display:"inline"`

	// GabaB has GABA-B channel parameters for long-lasting inhibition
	// that is inwardly rectified (GIRK coupled) and maximal for more hyperpolarized
	// neurons, thus keeping inactive neurons inactive. This is synergistic with
	// NMDA for supporting stable activity patterns over the theta cycle.
	GabaB chans.GABABParams `display:"inline"`

	// VGCC are voltage gated calcium channels, which provide a key additional
	// source of Ca for learning and positive-feedback loop upstate for active
	// neurons when they are spiking.
	VGCC chans.VGCCParams `display:"inline"`

	// AK is the A-type potassium (K) channel that is particularly important
	// for limiting the runaway excitation from VGCC channels.
	AK chans.AKsParams `display:"inline"`

	// SKCa is the small-conductance calcium-activated potassium channel produces
	// the pausing function as a consequence of rapid bursting. These are not active
	// by default but are critical for subthalamic nucleus (STN) neurons.
	SKCa chans.SKCaParams `display:"inline"`

	// SMaint provides a simplified self-maintenance current for a population of
	// NMDA-interconnected spiking neurons.
	SMaint SMaintParams `display:"inline"`

	// PopCode provides encoding population codes, used to represent a single
	// continuous (scalar) value, across a population of units / neurons
	// (1 dimensional).
	PopCode PopCodeParams `display:"inline"`
}

func (ac *ActParams) Defaults() {
	ac.Spikes.Defaults()
	ac.Dend.Defaults()
	ac.Init.Defaults()
	ac.Decay.Defaults()
	ac.Dt.Defaults()
	ac.Gbar.SetAll(100, 20, 100, 100) // E, L, I, K
	ac.Erev.SetAll(0,  -70, -90, -90) // E, L, I, K: K = hyperpolarized -90mv
	ac.Clamp.Defaults()
	ac.Noise.Defaults()
	ac.VmRange.Set(-100, 0)
	ac.Mahp.Defaults()
	ac.Mahp.Gk = 0.05
	ac.Sahp.Defaults()
	ac.Sahp.Gk = 0.05
	ac.Sahp.CaTau = 5
	ac.KNa.Defaults()
	ac.KNa.On.SetBool(true)
	ac.Kir.Defaults()
	ac.Kir.Gk = 0
	ac.NMDA.Defaults()
	ac.NMDA.Ge = 0.006
	ac.MaintNMDA.Defaults()
	ac.MaintNMDA.Ge = 0.007
	ac.MaintNMDA.Tau = 200
	ac.GabaB.Defaults()
	ac.VGCC.Defaults()
	ac.VGCC.Ge = 0.02
	ac.VGCC.Ca = 0.25
	ac.AK.Defaults()
	ac.AK.Gk = 0.1
	ac.SKCa.Defaults()
	ac.SKCa.Gk = 0
	ac.SMaint.Defaults()
	ac.PopCode.Defaults()
	ac.Update()
}

// Update must be called after any changes to parameters
func (ac *ActParams) Update() {
	ac.Spikes.Update()
	ac.Dend.Update()
	ac.Init.Update()
	ac.Decay.Update()
	ac.Dt.Update()
	ac.Clamp.Update()
	ac.Noise.Update()
	ac.Mahp.Update()
	ac.Sahp.Update()
	ac.KNa.Update()
	ac.Kir.Update()
	ac.NMDA.Update()
	ac.MaintNMDA.Update()
	ac.GabaB.Update()
	ac.VGCC.Update()
	ac.AK.Update()
	ac.SKCa.Update()
	ac.SMaint.Update()
	ac.PopCode.Update()
}

////////  Init

// DecayLearnCa decays neuron-level calcium learning and spiking variables
// by given factor.  Note: this is generally NOT useful,
// causing variability in these learning factors as a function
// of the decay parameter that then has impacts on learning rates etc.
// see Act.Decay.LearnCa param controlling this
func (ac *ActParams) DecayLearnCa(ctx *Context, ni, di uint32, decay float32) {
	Neurons[ni, di, GnmdaLrn] -= decay * Neurons[ni, di, GnmdaLrn]
	Neurons[ni, di, NmdaCa] -= decay * Neurons[ni, di, NmdaCa]

	Neurons[ni, di, VgccCa] -= decay * Neurons[ni, di, VgccCa]
	Neurons[ni, di, VgccCaInt] -= decay * Neurons[ni, di, VgccCaInt]

	Neurons[ni, di, LearnCa] -= decay * Neurons[ni, di, LearnCa]

	Neurons[ni, di, CaM] -= decay * Neurons[ni, di, CaM]
	Neurons[ni, di, CaP] -= decay * Neurons[ni, di, CaP]
	Neurons[ni, di, CaD] -= decay * Neurons[ni, di, CaD]

	Neurons[ni, di, LearnCaM] -= decay * Neurons[ni, di, LearnCaM]
	Neurons[ni, di, LearnCaP] -= decay * Neurons[ni, di, LearnCaP]
	Neurons[ni, di, LearnCaD] -= decay * Neurons[ni, di, LearnCaD]

	Neurons[ni, di, ETrace] -= decay * Neurons[ni, di, ETrace]
	Neurons[ni, di, ETraceLearn] += decay * (1.0 - Neurons[ni, di, ETraceLearn])

	// recovers
	Neurons[ni, di, SKCaIn] += decay * (1.0 - Neurons[ni, di, SKCaIn])
	Neurons[ni, di, SKCaR] -= decay * Neurons[ni, di, SKCaR]
	Neurons[ni, di, SKCaM] -= decay * Neurons[ni, di, SKCaM]
}

// DecayAHP decays after-hyperpolarization variables
// by given factor (typically Decay.AHP)
func (ac *ActParams) DecayAHP(ctx *Context, ni, di uint32, decay float32) {
	Neurons[ni, di, MahpN] -= decay * Neurons[ni, di, MahpN]
	Neurons[ni, di, Gmahp] -= decay * Neurons[ni, di, Gmahp]
	Neurons[ni, di, SahpCa] -= decay * Neurons[ni, di, SahpCa]
	Neurons[ni, di, SahpN] -= decay * Neurons[ni, di, SahpN]
	Neurons[ni, di, Gsahp] -= decay * Neurons[ni, di, Gsahp]
	Neurons[ni, di, GknaMed] -= decay * Neurons[ni, di, GknaMed]
	Neurons[ni, di, GknaSlow] -= decay * Neurons[ni, di, GknaSlow]
	kirMrest := ac.Kir.Mrest
	Neurons[ni, di, KirM] += decay * (kirMrest - Neurons[ni, di, KirM])
	Neurons[ni, di, Gkir] -= decay * Neurons[ni, di, Gkir]
}

// DecayState decays the activation state toward initial values
// in proportion to given decay parameter.  Special case values
// such as Glong and KNa are also decayed with their
// separately parameterized values.
// Called with ac.Decay.Act by Layer during NewState
func (ac *ActParams) DecayState(ctx *Context, ni, di uint32, decay, glong, ahp float32) {
	// always reset these -- otherwise get insanely large values that take forever to update
	Neurons[ni, di, ISIAvg] = -1.0
	Neurons[ni, di, ActInt] = ac.Init.Act
	Neurons[ni, di, Spiked] = 0.0

	if decay > 0 { // no-op for most, but not all..
		Neurons[ni, di, Spike] = 0.0
		Neurons[ni, di, Act] -= decay * (Neurons[ni, di, Act] - ac.Init.Act)
		Neurons[ni, di, ActInt] -= decay * (Neurons[ni, di, ActInt] - ac.Init.Act)
		Neurons[ni, di, GeSyn] -= decay * (Neurons[ni, di, GeSyn] - NeuronAvgs[ni, GeBase])
		Neurons[ni, di, Ge] -= decay * (Neurons[ni, di, Ge] - NeuronAvgs[ni, GeBase])
		Neurons[ni, di, Gi] -= decay * (Neurons[ni, di, Gi] - NeuronAvgs[ni, GiBase])
		Neurons[ni, di, Gk] -= decay * Neurons[ni, di, Gk]

		Neurons[ni, di, Vm] -= decay * (Neurons[ni, di, Vm] - ac.Init.Vm)

		Neurons[ni, di, GeNoise] -= decay * Neurons[ni, di, GeNoise]
		Neurons[ni, di, GiNoise] -= decay * Neurons[ni, di, GiNoise]

		Neurons[ni, di, GiSyn] -= decay * Neurons[ni, di, GiSyn]

		Neurons[ni, di, GeInt] -= decay * Neurons[ni, di, GeInt]
		Neurons[ni, di, GiInt] -= decay * Neurons[ni, di, GiInt]
		Neurons[ni, di, GeIntNorm] -= decay * Neurons[ni, di, GeIntNorm]
	}

	Neurons[ni, di, VmDend] -= glong * (Neurons[ni, di, VmDend] - ac.Init.Vm)

	if ahp > 0 {
		ac.DecayAHP(ctx, ni, di, ahp)
	}
	Neurons[ni, di, GgabaB] -= glong * Neurons[ni, di, GgabaB]
	Neurons[ni, di, GababM] -= glong * Neurons[ni, di, GababM]
	Neurons[ni, di, GababX] -= glong * Neurons[ni, di, GababX]

	Neurons[ni, di, GnmdaSyn] -= glong * Neurons[ni, di, GnmdaSyn]
	Neurons[ni, di, Gnmda] -= glong * Neurons[ni, di, Gnmda]
	Neurons[ni, di, GMaintSyn] -= glong * Neurons[ni, di, GMaintSyn]
	Neurons[ni, di, GnmdaMaint] -= glong * Neurons[ni, di, GnmdaMaint]

	Neurons[ni, di, Gvgcc] -= glong * Neurons[ni, di, Gvgcc]
	Neurons[ni, di, VgccM] -= glong * Neurons[ni, di, VgccM]
	Neurons[ni, di, VgccH] -= glong * Neurons[ni, di, VgccH]
	Neurons[ni, di, Gak] -= glong * Neurons[ni, di, Gak]

	// don't mess with SKCa -- longer time scale
	Neurons[ni, di, Gsk] -= glong * Neurons[ni, di, Gsk]

	if ac.Decay.LearnCa > 0 { // learning-based Ca values -- not usual
		ac.DecayLearnCa(ctx, ni, di, ac.Decay.LearnCa)
	}

	Neurons[ni, di, Inet] = 0.0
	Neurons[ni, di, GeRaw] = 0.0
	Neurons[ni, di, GiRaw] = 0.0
	Neurons[ni, di, GModRaw] = 0.0
	Neurons[ni, di, GModSyn] = 0.0
	Neurons[ni, di, GMaintRaw] = 0.0
	Neurons[ni, di, SSGiDend] = 0.0
	Neurons[ni, di, GeExt] = 0.0

	Neurons[ni, di, CtxtGeOrig] -= glong * Neurons[ni, di, CtxtGeOrig]
}

// InitActs initializes activation state in neuron -- called during InitWeights but otherwise not
// automatically called (DecayState is used instead)
func (ac *ActParams) InitActs(ctx *Context, ni, di uint32) {
	Neurons[ni, di, Spike] = 0
	Neurons[ni, di, Spiked] = 0
	Neurons[ni, di, ISI] = -1
	Neurons[ni, di, ISIAvg] = -1
	Neurons[ni, di, Act] = ac.Init.Act
	Neurons[ni, di, ActInt] = ac.Init.Act
	Neurons[ni, di, GeSyn] = NeuronAvgs[ni, GeBase]
	Neurons[ni, di, Ge] = NeuronAvgs[ni, GeBase]
	Neurons[ni, di, Gi] = NeuronAvgs[ni, GiBase]
	Neurons[ni, di, Gk] = 0
	Neurons[ni, di, Inet] = 0
	Neurons[ni, di, Vm] = ac.Init.Vm
	Neurons[ni, di, VmDend] = ac.Init.Vm
	Neurons[ni, di, Target] = 0
	Neurons[ni, di, Ext] = 0

	Neurons[ni, di, CaPMaxCa] = 0
	Neurons[ni, di, CaPMax] = 0
	Neurons[ni, di, RLRate] = 1

	Neurons[ni, di, GeNoiseP] = 1
	Neurons[ni, di, GeNoise] = 0
	Neurons[ni, di, GiNoiseP] = 1
	Neurons[ni, di, GiNoise] = 0
	Neurons[ni, di, GiSyn] = 0
	Neurons[ni, di, SMaintP] = 1

	Neurons[ni, di, GeInt] = 0
	Neurons[ni, di, GeIntNorm] = 0
	Neurons[ni, di, GiInt] = 0

	Neurons[ni, di, MahpN] = 0
	Neurons[ni, di, Gmahp] = 0
	Neurons[ni, di, SahpCa] = 0
	Neurons[ni, di, SahpN] = 0
	Neurons[ni, di, Gsahp] = 0
	Neurons[ni, di, GknaMed] = 0
	Neurons[ni, di, GknaSlow] = 0
	Neurons[ni, di, KirM] = ac.Kir.Mrest
	Neurons[ni, di, Gkir] = 0

	Neurons[ni, di, GnmdaSyn] = 0
	Neurons[ni, di, Gnmda] = 0
	Neurons[ni, di, GnmdaMaint] = 0
	Neurons[ni, di, GnmdaLrn] = 0
	Neurons[ni, di, NmdaCa] = 0

	Neurons[ni, di, GgabaB] = 0
	Neurons[ni, di, GababM] = 0
	Neurons[ni, di, GababX] = 0

	Neurons[ni, di, Gvgcc] = 0
	Neurons[ni, di, VgccM] = 0
	Neurons[ni, di, VgccH] = 0
	Neurons[ni, di, Gak] = 0
	Neurons[ni, di, VgccCaInt] = 0

	Neurons[ni, di, SKCaIn] = 1
	Neurons[ni, di, SKCaR] = 0
	Neurons[ni, di, SKCaM] = 0
	Neurons[ni, di, Gsk] = 0

	Neurons[ni, di, GeExt] = 0
	Neurons[ni, di, GeRaw] = 0
	Neurons[ni, di, GiRaw] = 0
	Neurons[ni, di, GModRaw] = 0
	Neurons[ni, di, GModSyn] = 0
	Neurons[ni, di, GMaintRaw] = 0
	Neurons[ni, di, GMaintSyn] = 0

	Neurons[ni, di, SSGiDend] = 0

	Neurons[ni, di, Burst] = 0
	Neurons[ni, di, BurstPrv] = 0

	Neurons[ni, di, CtxtGe] = 0
	Neurons[ni, di, CtxtGeRaw] = 0
	Neurons[ni, di, CtxtGeOrig] = 0

	mx := NetworkIxs[0].NCaBins
	for i := range mx {
		Neurons[ni, di, CaBins+NeuronVars(i)] = 0.0
	}

	ac.InitLongActs(ctx, ni, di)
}

// InitLongActs initializes longer time-scale activation states in neuron
// (CaDPrev, Beta1, Beta2, ActM, ActP)
// Called from InitActs, which is called from InitWeights,
// but otherwise not automatically called
// (DecayState is used instead)
func (ac *ActParams) InitLongActs(ctx *Context, ni, di uint32) {
	Neurons[ni, di, CaDPrev] = 0
	Neurons[ni, di, Beta1] = 0
	Neurons[ni, di, Beta2] = 0
	Neurons[ni, di, ActM] = 0
	Neurons[ni, di, ActP] = 0
	Neurons[ni, di, ETrace] = 0
	Neurons[ni, di, ETraceLearn] = 1
}

////////  Cycle

// NMDAFromRaw updates all the NMDA variables from
// total Ge (GeRaw + Ext) and current Vm, Spiking
func (ac *ActParams) NMDAFromRaw(ctx *Context, ni, di uint32, geTot float32) {
	if ac.NMDA.Ge == 0 {
		return
	}
	geT := max(geTot, 0.0)
	Neurons[ni, di, GnmdaSyn] = ac.NMDA.NMDASyn(Neurons[ni, di, GnmdaSyn], geT)
	Neurons[ni, di, Gnmda] = ac.NMDA.Gnmda(Neurons[ni, di, GnmdaSyn], Neurons[ni, di, VmDend])
	// note: nrn.NmdaCa computed via Learn.LearnNMDA in learn.go, CaM method
}

// MaintNMDAFromRaw updates all the Maint NMDA variables from
// GModRaw and current Vm, Spiking
func (ac *ActParams) MaintNMDAFromRaw(ctx *Context, ni, di uint32) {
	if ac.MaintNMDA.Ge == 0 {
		return
	}
	if ac.SMaint.On.IsTrue() {
		ac.SMaintFromISI(ctx, ni, di)
	}
	Neurons[ni, di, GMaintSyn] = ac.MaintNMDA.NMDASyn(Neurons[ni, di, GMaintSyn], Neurons[ni, di, GMaintRaw])
	Neurons[ni, di, GnmdaMaint] = ac.MaintNMDA.Gnmda(Neurons[ni, di, GMaintSyn], Neurons[ni, di, VmDend])
}

// SMaintFromISI updates the SMaint self-maintenance current into GMaintRaw
func (ac *ActParams) SMaintFromISI(ctx *Context, ni, di uint32) {
	nix := GetNetworkIxs(0)
	isi := Neurons[ni, di, ISIAvg]
	if isi < ac.SMaint.ISI.Min || isi > ac.SMaint.ISI.Max {
		return
	}
	ndi := di*nix.NNeurons + ni
	smp := Neurons[ni, di, SMaintP]
	smp *= GetRandomNumber(ndi, ctx.RandCounter.Counter, RandFunActSMaintP)
	trg := ac.SMaint.ExpInt(isi)
	if smp <= trg {
		smp = 1
		Neurons[ni, di, GMaintRaw] += ac.SMaint.Ge
	}
	Neurons[ni, di, SMaintP] = smp
}

// GvgccFromVm updates all the VGCC voltage-gated calcium channel variables
// from VmDend
func (ac *ActParams) GvgccFromVm(ctx *Context, ni, di uint32) {
	if ac.VGCC.Ge == 0 {
		return
	}
	v := Neurons[ni, di, VmDend]
	Neurons[ni, di, Gvgcc] = ac.VGCC.Gvgcc(v, Neurons[ni, di, VgccM], Neurons[ni, di, VgccH])
	dm := ac.VGCC.DeltaMFromV(v, Neurons[ni, di, VgccM])
	dh := ac.VGCC.DeltaHFromV(v, Neurons[ni, di, VgccH])
	Neurons[ni, di, VgccM] += dm
	Neurons[ni, di, VgccH] += dh
	// note: may be overwritten!
	Neurons[ni, di, VgccCa] = ac.VGCC.CaFromG(v, Neurons[ni, di, Gvgcc], Neurons[ni, di, VgccCa])
}

// GkFromVm updates all the Gk-based conductances: Mahp, KNa, Gak
func (ac *ActParams) GkFromVm(ctx *Context, ni, di uint32) {
	vm := Neurons[ni, di, Vm]
	vmd := Neurons[ni, di, VmDend]
	mahpN := Neurons[ni, di, MahpN]
	gmahp := ac.Mahp.GmAHP(vm, &mahpN)
	Neurons[ni, di, Gmahp] = gmahp
	Neurons[ni, di, MahpN] = mahpN

	gsahp := Neurons[ni, di, Gsahp]

	gak := ac.AK.Gak(vmd)
	Neurons[ni, di, Gak] = gak

	nkirM := Neurons[ni, di, KirM]
	gkir := ac.Kir.Gkir(vm, nkirM)
	Neurons[ni, di, Gkir] = gkir
	nkirM += ac.Kir.DM(vm, nkirM)
	Neurons[ni, di, KirM] = nkirM

	gktot := gmahp + gsahp + gak + gkir

	if ac.KNa.On.IsTrue() {
		gknaMed := Neurons[ni, di, GknaMed]
		gknaSlow := Neurons[ni, di, GknaSlow]
		ac.KNa.GcFromSpike(&gknaMed, &gknaSlow, Neurons[ni, di, Spike] > .5)
		Neurons[ni, di, GknaMed] = gknaMed
		Neurons[ni, di, GknaSlow] = gknaSlow
		gktot += gknaMed + gknaSlow
	}

	Neurons[ni, di, Gk] = gktot
}

// KNaNewState does TrialSlow version of KNa during NewState if option is set
func (ac *ActParams) KNaNewState(ctx *Context, ni, di uint32) {
	if ac.KNa.On.IsTrue() && ac.KNa.TrialSlow.IsTrue() {
		Neurons[ni, di, GknaSlow] += ac.KNa.Slow.Gk * Neurons[ni, di, CaDPrev]
	}
}

// GSkCaFromCa updates the SKCa channel if used
func (ac *ActParams) GSkCaFromCa(ctx *Context, ni, di uint32) {
	if ac.SKCa.Gk == 0 {
		return
	}
	skcar := Neurons[ni, di, SKCaR]
	skcain := Neurons[ni, di, SKCaIn]
	Neurons[ni, di, SKCaM] = ac.SKCa.MFromCa(skcar, Neurons[ni, di, SKCaM])
	ac.SKCa.CaInRFromSpike(Neurons[ni, di, Spike], Neurons[ni, di, CaD], &skcain, &skcar)
	Neurons[ni, di, SKCaR] = skcar
	Neurons[ni, di, SKCaIn] = skcain
	Neurons[ni, di, Gsk] = ac.SKCa.Gk * Neurons[ni, di, SKCaM]
	Neurons[ni, di, Gk] += Neurons[ni, di, Gsk]
}

// GeFromSyn integrates Ge excitatory conductance from GeSyn.
// geExt is extra conductance to add to the final Ge value
func (ac *ActParams) GeFromSyn(ctx *Context, ni, di uint32, geSyn, geExt float32) {
	Neurons[ni, di, GeExt] = 0.0
	geS := geSyn
	geE := geExt
	if ac.Clamp.Add.IsTrue() && NeuronHasFlag(NeuronHasExt, ni, di) {
		Neurons[ni, di, GeExt] = Neurons[ni, di, Ext] * ac.Clamp.Ge
		geS += Neurons[ni, di, GeExt]
	}

	if ac.Clamp.Add.IsFalse() && NeuronHasFlag(NeuronHasExt, ni, di) {
		geS = Neurons[ni, di, Ext] * ac.Clamp.Ge
		Neurons[ni, di, GeExt] = geS
		geE = 0 // no extra in this case
	}

	Neurons[ni, di, Ge] = geS + geE
	if Neurons[ni, di, Ge] < 0.0 {
		Neurons[ni, di, Ge] = 0.0
	}
	ac.AddGeNoise(ctx, ni, di)
}

// AddGeNoise updates nrn.GeNoise if active
func (ac *ActParams) AddGeNoise(ctx *Context, ni, di uint32) {
	if ac.Noise.On.IsFalse() || ac.Noise.Ge == 0 {
		return
	}
	p := Neurons[ni, di, GeNoiseP]
	ge := ac.Noise.PGe(ctx, &p, ni, di)
	Neurons[ni, di, GeNoiseP] = p
	Neurons[ni, di, GeNoise] = ac.Dt.GeSynFromRaw(Neurons[ni, di, GeNoise], ge)
	Neurons[ni, di, Ge] += Neurons[ni, di, GeNoise]
}

// AddGiNoise updates nrn.GiNoise if active
func (ac *ActParams) AddGiNoise(ctx *Context, ni, di uint32) {
	if ac.Noise.On.IsFalse() || ac.Noise.Gi == 0 {
		return
	}
	p := Neurons[ni, di, GiNoiseP]
	gi := ac.Noise.PGi(ctx, &p, ni, di)
	Neurons[ni, di, GiNoiseP] = p
	Neurons[ni, di, GiNoise] = ac.Dt.GiSynFromRaw(Neurons[ni, di, GiNoise], gi)
}

// GiFromSyn integrates GiSyn inhibitory synaptic conductance from GiRaw value
// (can add other terms to geRaw prior to calling this)
func (ac *ActParams) GiFromSyn(ctx *Context, ni, di uint32, giSyn float32) float32 {
	ac.AddGiNoise(ctx, ni, di)
	if giSyn < 0 { // negative inhib G doesn't make any sense
		return 0
	}
	return giSyn
}

// InetFromG computes net current from conductances and Vm
func (ac *ActParams) InetFromG(vm, ge, gl, gi, gk float32) float32 {
	inet := ge*(ac.Erev.E-vm) + gl*ac.Gbar.L*(ac.Erev.L-vm) + gi*(ac.Erev.I-vm) + gk*(ac.Erev.K-vm)
	if inet > ac.Dt.MaxI {
		inet = ac.Dt.MaxI
	} else if inet < -ac.Dt.MaxI {
		inet = -ac.Dt.MaxI
	}
	return inet
}

// VmFromInet computes new Vm value from inet, clamping range
func (ac *ActParams) VmFromInet(vm, dt, inet float32) float32 {
	return ac.VmRange.ClampValue(vm + dt*inet)
}

// VmInteg integrates Vm over VmSteps to obtain a more stable value
// Returns the new Vm and inet values.
func (ac *ActParams) VmInteg(vm, dt, ge, gl, gi, gk float32, nvm, inet *float32) {
	dtEff := dt * ac.Dt.DtStep
	*nvm = vm
	for i := int32(0); i < ac.Dt.VmSteps; i++ {
		*inet = ac.InetFromG(*nvm, ge, gl, gi, gk)
		*nvm = ac.VmFromInet(*nvm, dtEff, *inet)
	}
}

// VmFromG computes membrane potential Vm from conductances Ge, Gi, and Gk.
func (ac *ActParams) VmFromG(ctx *Context, ni, di uint32) {
	updtVm := true
	// note: nrn.ISI has NOT yet been updated at this point: 0 right after spike, etc
	// so it takes a full 3 time steps after spiking for Tr period
	isi := Neurons[ni, di, ISI]
	if ac.Spikes.Tr > 0 && isi >= 0 && isi < float32(ac.Spikes.Tr) {
		updtVm = false // don't update the spiking vm during refract
	}

	ge := Neurons[ni, di, Ge] * ac.Gbar.E
	gi := Neurons[ni, di, Gi] * ac.Gbar.I
	gk := Neurons[ni, di, Gk] * ac.Gbar.K
	var nvm, inet, expi float32
	if updtVm {
		ac.VmInteg(Neurons[ni, di, Vm], ac.Dt.VmDt, ge, 1, gi, gk, &nvm, &inet)
		if updtVm && ac.Spikes.Exp.IsTrue() { // add spike current if relevant
			var exVm float32
			exVm = 0.5 * (nvm + Neurons[ni, di, Vm]) // midpoint for this
			expi = ac.Gbar.L*ac.Spikes.ExpSlope *
				math32.FastExp((exVm-ac.Spikes.Thr)/ac.Spikes.ExpSlope)
			if expi > ac.Dt.MaxI  {
				expi = ac.Dt.MaxI
			}
			inet += expi
			nvm = ac.VmFromInet(nvm, ac.Dt.VmDt, expi)
		}
		Neurons[ni, di, Vm] = nvm
		Neurons[ni, di, Inet] = inet
	} else { // decay back to VmR
		var dvm float32
		if int32(isi) == ac.Spikes.Tr-1 {
			dvm = ac.Spikes.VmR - Neurons[ni, di, Vm]
		} else {
			dvm = ac.Spikes.RDt * (ac.Spikes.VmR - Neurons[ni, di, Vm])
		}
		Neurons[ni, di, Vm] += dvm
		Neurons[ni, di, Inet] = dvm * ac.Dt.VmC
	}

	glEff := float32(1)
	if !updtVm {
		glEff += ac.Dend.GR
	}
	var giEff float32
	giEff = gi + ac.Gbar.I*Neurons[ni, di, SSGiDend]
	ac.VmInteg(Neurons[ni, di, VmDend], ac.Dt.VmDendDt, ge, glEff, giEff, gk, &nvm, &inet)
	if updtVm {
		nvm = ac.VmFromInet(nvm, ac.Dt.VmDendDt, ac.Dend.GExp*expi)
	}
	Neurons[ni, di, VmDend] = nvm
}

// SpikeFromVmVars computes Spike from Vm and ISI-based activation, using pointers to variables
func (ac *ActParams) SpikeFromVmVars(nrnISI, nrnISIAvg, nrnSpike, nrnSpiked, nrnAct *float32, nrnVm float32) {
	var thr float32
	if ac.Spikes.Exp.IsTrue() {
		thr = ac.Spikes.ExpThr
	} else {
		thr = ac.Spikes.Thr
	}
	if nrnVm >= thr {
		*nrnSpike = 1
		if *nrnISIAvg == -1 {
			*nrnISIAvg = -2
		} else if *nrnISI > 0 { // must have spiked to update
			*nrnISIAvg = ac.Spikes.AvgFromISI(*nrnISIAvg, *nrnISI+1)
		}
		*nrnISI = 0
	} else {
		*nrnSpike = 0
		if *nrnISI >= 0 {
			*nrnISI += 1
			if *nrnISI < 10 {
				*nrnSpiked = 1
			} else {
				*nrnSpiked = 0
			}
			if *nrnISI > 200 { // keep from growing infinitely large
				// used to do this arbitrarily in DecayState but that
				// caused issues with missing refractory periods
				*nrnISI = -1
			}
		} else {
			*nrnSpiked = 0
		}
		if *nrnISIAvg >= 0 && *nrnISI > 0 && *nrnISI > 1.2**nrnISIAvg {
			*nrnISIAvg = ac.Spikes.AvgFromISI(*nrnISIAvg, *nrnISI)
		}
	}

	nwAct := ac.Spikes.ActFromISI(*nrnISIAvg, .001, ac.Dt.Integ)
	if nwAct > 1 {
		nwAct = 1
	}
	nwAct = *nrnAct + 100 * ac.Dt.VmDt*(nwAct-*nrnAct) // 100 restores to prior behavior
	*nrnAct = nwAct
}

// SpikeFromVm computes Spike from Vm and ISI-based activation
func (ac *ActParams) SpikeFromVm(ctx *Context, ni, di uint32) {
	nrnISI := Neurons[ni, di, ISI]
	nrnISIAvg := Neurons[ni, di, ISIAvg]
	nrnSpike := Neurons[ni, di, Spike]
	nrnSpiked := Neurons[ni, di, Spiked]
	nrnAct := Neurons[ni, di, Act]
	nrnVm := Neurons[ni, di, Vm]
	ac.SpikeFromVmVars(&nrnISI, &nrnISIAvg, &nrnSpike, &nrnSpiked, &nrnAct, nrnVm)
	Neurons[ni, di, ISI] = nrnISI
	Neurons[ni, di, ISIAvg] = nrnISIAvg
	Neurons[ni, di, Spike] = nrnSpike
	Neurons[ni, di, Spiked] = nrnSpiked
	Neurons[ni, di, Act] = nrnAct
}

//gosl:end

// Decode decodes value from a pattern of activation
// as the activation-weighted-average of the unit's preferred
// tuning values.
// must have 2 or more values in pattern pat.
func (pc *PopCodeParams) Decode(acts []float32) float32 {
	n := len(acts)
	if n < 2 {
		return 0
	}
	rng := pc.Max - pc.Min
	incr := rng / float32(n-1)
	avg := float32(0)
	sum := float32(0)
	for i, act := range acts {
		if act < 0.1 {
			act = 0
		}
		trg := pc.Min + incr*float32(i)
		avg += trg * act
		sum += act
	}
	sum = math32.Max(sum, 0.2)
	avg /= sum
	return avg
}

// Uncertainty returns the uncertainty of the given distribution of
// activities relative to a perfect code for the given value.
// Uncertainty is the average unit-wise standard deviation between the
// pop code encoding and the max-normalized activities.
func (pc *PopCodeParams) Uncertainty(val float32, acts []float32) float32 {
	n := len(acts)
	if n < 2 {
		return 0
	}
	mx := float32(0)
	for _, act := range acts {
		if act > mx {
			mx = act
		}
	}
	if mx == 0 {
		mx = 1
	}
	vr := float32(0)
	for i, act := range acts {
		trg := pc.EncodeValue(uint32(i), uint32(n), val)
		vi := trg - (act / mx)
		vr += vi * vi
	}
	vr /= float32(n)
	return math32.Sqrt(vr)
}
