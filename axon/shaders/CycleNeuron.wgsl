// Code generated by "gosl"; DO NOT EDIT
// kernel: CycleNeuron

// // Layers are all the layer parameters. 
@group(0) @binding(0)
var<storage, read> TensorStrides: array<u32>;
@group(0) @binding(1)
var<storage, read> Layers: array<LayerParams>;
@group(0) @binding(2)
var<storage, read> Paths: array<PathParams>;
@group(0) @binding(3)
var<storage, read> NetworkIxs: array<NetworkIndexes>;
@group(0) @binding(4)
var<storage, read> PoolIxs: array<u32>;
@group(0) @binding(5)
var<storage, read> NeuronIxs: array<u32>;
// // SynapseIxs have index values for each synapse: // providing index into recv, send neurons, path. // [Indexes][NSyns]; NSyns = [Layer][SendPaths][SendNeurons][Syns] 
@group(1) @binding(0)
var<storage, read> SynapseIxs: array<u32>;
@group(1) @binding(1)
var<storage, read> PathSendCon: array<u32>;
@group(1) @binding(2)
var<storage, read> RecvPathIxs: array<u32>;
@group(1) @binding(3)
var<storage, read> PathRecvCon: array<u32>;
@group(1) @binding(4)
var<storage, read> RecvSynIxs: array<u32>;
// // Ctx is the current context state (one only). This is read-only except in // specific kernels. 
@group(2) @binding(0)
var<storage, read_write> Ctx: array<Context>;
@group(2) @binding(1)
var<storage, read_write> Neurons: array<f32>;
@group(2) @binding(2)
var<storage, read_write> NeuronAvgs: array<f32>;
@group(2) @binding(3)
var<storage, read_write> LayerStates: array<f32>;
@group(2) @binding(4)
var<storage, read_write> GlobalScalars: array<f32>;
@group(2) @binding(5)
var<storage, read_write> GlobalVectors: array<f32>;
@group(2) @binding(6)
var<storage, read_write> Exts: array<f32>;
// // Pools are the [PoolVars] float32 state values for layer and sub-pool inhibition, // Including the float32 AvgMax values by Phase and variable: use [AvgMaxVarIndex]. // [Layer * Pools][Data][PoolVars+AvgMax] 
@group(3) @binding(0)
var<storage, read_write> Pools: array<f32>;
@group(3) @binding(1)
var<storage, read_write> PoolsInt: array<i32>;
@group(3) @binding(2)
var<storage, read_write> PathGBuf: array<i32>;
@group(3) @binding(3)
var<storage, read_write> PathGSyns: array<f32>;
@group(3) @binding(4)
var<storage, read_write> Synapses: array<f32>;
@group(3) @binding(5)
var<storage, read_write> SynapseTraces: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(workgroup_id) wgid: vec3<u32>, @builtin(num_workgroups) nwg: vec3<u32>, @builtin(local_invocation_index) loci: u32) {
	let idx = loci + (wgid.x + wgid.y * nwg.x + wgid.z * nwg.x * nwg.y) * 64;
	CycleNeuron(idx);
}

fn Index2D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return s0 * i0 + s1 * i1;
}

fn Index1D(s0: u32, i0: u32) -> u32 {
	return s0 * i0;
}

fn Index3D(s0: u32, s1: u32, s2: u32, i0: u32, i1: u32, i2: u32) -> u32 {
	return s0 * i0 + s1 * i1 + s2 * i2;
}


//////// import: "vars.go"

//////// import: "act-layer.go"
fn SetNeuronExtPosNeg(ctx: Context, ni: u32,di: u32, val: f32) {
	if (ni == 0) {
		if (val >= 0) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ext))] = val;
		} else {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ext))] = f32(0);
		}
	} else {
		if (val >= 0) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ext))] = f32(0);
		} else {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
			u32(ni), u32(di), u32(Ext))] = -val;
		}
	}
}
fn LayerParams_IsTarget(ly: LayerParams) -> bool {
	return ly.Type == TargetLayer || ly.Type == PulvinarLayer;
}
fn LayerParams_IsInput(ly: LayerParams) -> bool {
	return ly.Type == InputLayer;
}
fn LayerParams_IsInputOrTarget(ly: LayerParams) -> bool {
	return (LayerParams_IsTarget(ly) || LayerParams_IsInput(ly));
}
fn LayerParams_CycleNeuron(ly: LayerParams, ctx: Context, ni: u32,di: u32) {
	var pi = LayerParams_PoolIndex(ly, NeuronIxs[Index2D(TensorStrides[10], TensorStrides[11], u32(ni), u32(NrnSubPool))]);
	var lpi = LayerParams_PoolIndex(ly, u32(u32(0)));
	LayerParams_GInteg(ly, ctx, pi, ni, di);
	LayerParams_SpikeFromG(ly, ctx, lpi, ni, di);
}
fn LayerParams_PulvinarDriver(ly: LayerParams, ctx: Context, lni: u32,di: u32, drvGe: ptr<function,f32>,nonDrivePct: ptr<function,f32>) {
	var dli = u32(ly.Pulv.DriveLayIndex);
	let dly = Layers[dli];
	var dpi = LayerParams_PoolIndex(dly, u32(u32(0)));
	var drvMax = PoolAvgMax(AMCaP, AMCycle, Max, dpi, di);
	*nonDrivePct = PulvParams_NonDrivePct(ly.Pulv, drvMax); // how much non-driver to keep
	var burst = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(dly.Indexes.NeurSt + lni), u32(di), u32(Burst))];
	*drvGe = PulvParams_DriveGe(ly.Pulv, burst);
}
fn LayerParams_GInteg(ly: LayerParams, ctx: Context, pi: u32,ni: u32,di: u32) {
	var drvGe = f32(0);
	var nonDrivePct = f32(0);
	if (ly.Type == PulvinarLayer) {
		LayerParams_PulvinarDriver(ly, ctx, ni-ly.Indexes.NeurSt, di, &drvGe, &nonDrivePct);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], // use for regulating inhibition
		u32(ni), u32(di), u32(Ext))] = nonDrivePct;
	}
	var saveVal = LayerParams_SpecialPreGs(ly, ctx, pi, ni, di, drvGe, nonDrivePct);
	LayerParams_GFromRawSyn(ly, ctx, ni, di);
	LayerParams_GiInteg(ly, ctx, pi, ni, di);
	LayerParams_GNeuroMod(ly, ctx, ni, di);
	LayerParams_SpecialPostGs(ly, ctx, ni, di, saveVal);
}
fn LayerParams_SpecialPreGs(ly: LayerParams, ctx: Context, pi: u32,ni: u32,di: u32, drvGe: f32, nonDrivePct: f32) -> f32 {
	var saveVal = f32(0); // sometimes we need to use a value computed here, for the post Gs step
	var pil = pi - ly.PoolSt;
	var pnn = u32(PoolNNeurons(pi));
	var pni = NeuronIxs[Index2D(TensorStrides[10], TensorStrides[11], u32(ni), u32(NrnNeurIndex))] - u32(PoolIxs[Index2D(TensorStrides[0], TensorStrides[1], u32(pi), u32(PoolNeurSt))]);
	var nrnCtxtGe = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CtxtGe))];
	var nrnGeRaw = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))];
	var hasRew = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvHasRew), u32(di))] > 0;
	switch (ly.Type) {
	case PTPredLayer, CTLayer: {
		var geCtxt = ly.CT.GeGain * nrnCtxtGe;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] += geCtxt;
		if (ly.CT.DecayDt > 0) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CtxtGe))] -= ly.CT.DecayDt * nrnCtxtGe;
		}
		var ctxExt = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geCtxt);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] += ctxExt;
		saveVal = ctxExt;
	} // used In PostGs to set nrn.GeExt
	case PTMaintLayer: {
		if (ly.Acts.SMaint.On == 1) {
			saveVal = ly.Acts.SMaint.Inhib * Neurons[Index3D(TensorStrides[70], TensorStrides[71], // used In PostGs to set nrn.GeExt
			TensorStrides[72], u32(ni), u32(di), u32(GMaintRaw))];
		}
	}
	case PulvinarLayer: {
		if (ctx.PlusPhase == 0) {
			break;
		}
		saveVal = nonDrivePct*Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] + DtParams_GeSynFromRawSteady(ly.Acts.Dt, drvGe);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = nonDrivePct*nrnGeRaw + drvGe;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = saveVal;
	}
	case VSGatedLayer: {
		var dr = f32(0);
		if (pil == 0) {
			dr = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvVSMatrixJustGated), u32(di))];
		} else {
			dr = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvVSMatrixHasGated), u32(di))];
		}
		dr = abs(dr);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = dr;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, dr);
	}
	case BLALayer: {
		if (NeuroModParams_IsBLAExt(ly.Learn.NeuroMod)) {
			var md = max(-GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], // ext is modulated by negative da
			u32(GvDA), u32(di))], f32(0));
			var geCtxt = md * ly.CT.GeGain * Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CtxtGeOrig))];
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] += geCtxt;
			var ctxExt = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geCtxt);
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] += ctxExt;
			saveVal = ctxExt; // used In PostGs to set nrn.GeExt
		}
	}
	case LHbLayer: {
		var geRaw = f32(0);
		if (ni == 0) {
			geRaw = 0.2 * abs(GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvLHbDip), u32(di))]);
		} else {
			geRaw = 0.2 * abs(GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvLHbBurst), u32(di))]);
		}
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case DrivesLayer: {
		var dr = GlobalVectors[Index3D(TensorStrides[110], TensorStrides[111], TensorStrides[112], u32(GvDrives), u32(pil - 1), u32(di))];
		var geRaw = dr;
		if (dr > 0) {
			geRaw = PopCodeParams_EncodeGe(ly.Acts.PopCode, pni, pnn, dr);
		}
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case UrgencyLayer: {
		var ur = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvUrgency), u32(di))];
		var geRaw = ur;
		if (ur > 0) {
			geRaw = PopCodeParams_EncodeGe(ly.Acts.PopCode, pni, pnn, ur);
		}
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case USLayer: {
		var us = RubiconUSStimValue(di, pil-1, ly.Learn.NeuroMod.Valence);
		var geRaw = us;
		if (us > 0) {
			geRaw = PopCodeParams_EncodeGe(ly.Acts.PopCode, pni, pnn, us);
		}
		if (ly.Learn.NeuroMod.DAMod == D1Mod || (ly.Learn.NeuroMod.DAMod == D2Mod && hasRew && ctx.PlusPhase == 1)) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
		}
	}
	case PVLayer: {
		if (hasRew && ctx.PlusPhase == 1) {
			var pv = f32(0);
			if (ly.Learn.NeuroMod.Valence == Positive) {
				pv = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvPVpos), u32(di))];
			} else {
				pv = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvPVneg), u32(di))];
			}
			var pc = PopCodeParams_EncodeGe(ly.Acts.PopCode, pni, ly.Indexes.NNeurons, pv);
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = pc;
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, pc);
		}
	}
	case LDTLayer: {
		var geRaw = 0.4 * GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvACh), u32(di))];
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case VTALayer: {
		var geRaw = RWDaParams_GeFromDA(ly.RWDa, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvVtaDA), u32(di))]);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case RewLayer: {
		NeuronSetFlag(NeuronHasExt, ni, di);
		SetNeuronExtPosNeg(ctx, ni, di, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], // Rew must be set in Context!
		u32(GvRew), u32(di))]);
	}
	case RWDaLayer: {
		var geRaw = RWDaParams_GeFromDA(ly.RWDa, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvDA), u32(di))]);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case TDDaLayer: {
		var geRaw = TDDaParams_GeFromDA(ly.TDDa, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvDA), u32(di))]);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] = geRaw;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] = DtParams_GeSynFromRawSteady(ly.Acts.Dt, geRaw);
	}
	case TDIntegLayer: {
		NeuronSetFlag(NeuronHasExt, ni, di);
		SetNeuronExtPosNeg(ctx, ni, di, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvRewPred), u32(di))]);
	}
	default: {
	}
	}return saveVal;
}
fn LayerParams_SpecialPostGs(ly: LayerParams, ctx: Context, ni: u32,di: u32, saveVal: f32) {
	switch (ly.Type) {
	case PulvinarLayer, PTMaintLayer, CTLayer, BLALayer: {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeExt))] = saveVal;
	}
	case PTPredLayer: {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeExt))] = saveVal;
		var orig = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CtxtGeOrig))];
		if (orig < 0.05) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
			u32(ni), u32(di), u32(Ge))] = 0.0;
		}
	}
	default: {
	}
	}
}
fn LayerParams_GFromRawSyn(ly: LayerParams, ctx: Context, ni: u32,di: u32) {
	var extraRaw = f32(0);
	var extraSyn = f32(0);
	var nrnGModRaw = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GModRaw))];
	var nrnGModSyn = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GModSyn))];
	var ach = GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvACh), u32(di))];
	switch (ly.Type) {
	case PTMaintLayer: {
		var md = ly.Acts.Dend.ModGain * nrnGModSyn;
		if (ly.Acts.Dend.ModACh == 1) {
			md *= ach;
		}
		md += ly.Acts.Dend.ModBase;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] *= md;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] *= md;
		extraRaw = ly.Acts.Dend.ModGain * nrnGModRaw;
		if (ly.Acts.Dend.ModACh == 1) {
			extraRaw *= ach;
		}
		extraSyn = md;
	}
	case BLALayer: {
		var md = max(-GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], // ext is modulated by negative da
		u32(GvDA), u32(di))], 0.0);
		extraRaw = md * nrnGModRaw * ly.Acts.Dend.ModGain;
		extraSyn = md * nrnGModSyn * ly.Acts.Dend.ModGain;
	}
	default: {
		if (ly.Acts.Dend.HasMod == 1) {
			var md = ly.Acts.Dend.ModBase + ly.Acts.Dend.ModGain*nrnGModSyn;
			if (md > 1) {
				md = f32(1);
			}
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))] *= md;
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))] *= md;
		}
	}
	}
	var geRaw = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeRaw))];
	var geSyn = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeSyn))];
	ActParams_NMDAFromRaw(ly.Acts, ctx, ni, di, geRaw+extraRaw);
	ActParams_MaintNMDAFromRaw(ly.Acts, ctx, ni, di); // uses GMaintRaw directly
	LearnNeuronParams_LearnNMDAFromRaw(ly.Learn, ctx, ni, di, geRaw);
	ActParams_GvgccFromVm(ly.Acts, ctx, ni, di);
	var ege = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gnmda))] + Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaMaint))] + Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gvgcc))] + extraSyn;
	ActParams_GeFromSyn(ly.Acts, ctx, ni, di, geSyn, ege); // sets nrn.GeExt too
	ActParams_GkFromVm(ly.Acts, ctx, ni, di);
	ActParams_GSkCaFromCa(ly.Acts, ctx, ni, di);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiSyn))] = ActParams_GiFromSyn(ly.Acts, ctx, ni, di, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiSyn))]);
}
fn LayerParams_GiInteg(ly: LayerParams, ctx: Context, pi: u32,ni: u32,di: u32) {
	var giMult = LayerStates[Index3D(TensorStrides[90], TensorStrides[91], TensorStrides[92], u32(ly.Index), u32(di), u32(LayerGiMult))];
	var gi = giMult*Pools[Index3D(TensorStrides[130], TensorStrides[131], TensorStrides[132], u32(pi), u32(di), u32(TotalGi))] + Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiSyn))] + Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiNoise))] + NeuroModParams_GiFromACh(ly.Learn.NeuroMod, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvACh), u32(di))]);
	var ssgi = Pools[Index3D(TensorStrides[130], TensorStrides[131], TensorStrides[132], u32(pi), u32(di), u32(SSGi))];
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gi))] = gi;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SSGiDend))] = 0.0;
	if (ctx.PlusPhase == 1 && ly.Type == PulvinarLayer) {
		var ext = Neurons[Index3D(TensorStrides[70], TensorStrides[71], // nonDrivePct
		TensorStrides[72], u32(ni), u32(di), u32(Ext))];
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SSGiDend))] = ext * ly.Acts.Dend.SSGi * ssgi;
	} else {
		if (!LayerParams_IsInputOrTarget(ly)) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SSGiDend))] = ly.Acts.Dend.SSGi * ssgi;
		}
	}
	var vm = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))];
	var nrnGababM = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GababM))];
	var nrnGababX = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GababX))];
	GABABParams_MX(ly.Acts.GabaB, gi, &nrnGababM, &nrnGababX);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GababM))] = nrnGababM;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GababX))] = nrnGababX;
	var nrnGgabaB = GABABParams_GgabaB(ly.Acts.GabaB, nrnGababM, vm);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
	u32(ni), u32(di), u32(GgabaB))] = nrnGgabaB;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
	u32(ni), u32(di), u32(Gk))] += nrnGgabaB;
}
fn LayerParams_GNeuroMod(ly: LayerParams, ctx: Context, ni: u32,di: u32) {
	var ggain = NeuroModParams_GGain(ly.Learn.NeuroMod, GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvDA), u32(di))] + GlobalScalars[Index2D(TensorStrides[100], TensorStrides[101], u32(GvDAtonic), u32(di))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ge))] *= ggain;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
	u32(ni), u32(di), u32(Gi))] *= ggain;
}
fn LayerParams_SpikeFromG(ly: LayerParams, ctx: Context, lpi: u32,ni: u32,di: u32) {
	ActParams_VmFromG(ly.Acts, ctx, ni, di);
	ActParams_SpikeFromVm(ly.Acts, ctx, ni, di);
	LearnNeuronParams_CaFromSpike(ly.Learn, ctx, ni, di);
	var lmax = PoolAvgMax(AMGeInt, AMCycle, Max, lpi, di);
	if (lmax > 0) {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeIntNorm))] = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeInt))] / lmax;
	} else {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeIntNorm))] = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeInt))];
	}
	if (ctx.Cycle >= ly.Acts.Dt.MaxCycStart) {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaPMaxCa))] += ly.Learn.CaSpike.Dt.PDt * (Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaM))] - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaPMaxCa))]);
		var spkmax = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaPMaxCa))];
		if (spkmax > Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaPMax))]) {
			Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaPMax))] = spkmax;
		}
	}
	var mx = NetworkIxs[0].NCaBins;
	var bin = min(ctx.Cycle/ctx.CaBinCycles, mx);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaBins + NeuronVars(bin)))] += Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaSyn))] / f32(ctx.CaBinCycles);
}

//////// import: "act-net.go"
fn CycleNeuron(i: u32) { //gosl:kernel
	let ctx = Ctx[0];
	var ni = Context_ItemIndex(ctx, i);
	if (ni >= NetworkIxs[0].NNeurons) {
		return;
	}
	var di = Context_DataIndex(ctx, i);
	var li = NeuronIxs[Index2D(TensorStrides[10], TensorStrides[11], u32(ni), u32(NrnLayIndex))];
	let layers=Layers[li]; LayerParams_CycleNeuron(layers, ctx, ni, di);
}

//////// import: "act-path.go"
alias PathGTypes = i32; //enums:enum
const  ExcitatoryG: PathGTypes = 0;
const  InhibitoryG: PathGTypes = 1;
const  ModulatoryG: PathGTypes = 2;
const  MaintG: PathGTypes = 3;
const  ContextG: PathGTypes = 4;
struct SynComParams {
	GType: PathGTypes,
	Delay: u32,
	MaxDelay: u32,
	DelLen: u32,
}
struct PathScaleParams {
	Rel: f32,
	Abs: f32,
	pad: f32,
	pad1: f32,
}

//////// import: "act.go"
fn NeuronHasFlag(flag: NeuronFlags, ni: u32,di: u32) -> bool {
	return (NeuronFlags(bitcast<u32>(Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], // weird: != 0 does NOT work on GPU
	u32(ni), u32(di), u32(NeurFlags))])) & flag) > 0;
}
fn NeuronSetFlag(flag: NeuronFlags, ni: u32,di: u32) {
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(NeurFlags))] = bitcast<f32>(bitcast<u32>(Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(NeurFlags))]) | u32(flag));
}
struct SpikeParams {
	Thr: f32,
	VmR: f32,
	Tr: i32,
	RTau: f32,
	Exp: i32,
	ExpSlope: f32,
	ExpThr: f32,
	MaxHz: f32,
	ISITau: f32,
	ISIDt: f32,
	RDt: f32,
	pad: i32,
}
fn SpikeParams_ActFromISI(sk: SpikeParams, isi: f32,timeInc: f32,integ: f32) -> f32 {
	if (isi <= 0) {
		return f32(0);
	}
			var maxInt = 1.0 / (timeInc * integ * sk.MaxHz); // interval at max hz..
return maxInt / isi; // normalized
}
fn SpikeParams_AvgFromISI(sk: SpikeParams, avg: f32, isi: f32) -> f32 {
	var av = avg;
	if (av <= 0) {
		av = isi;
	} else if (isi < 0.8*av) {
		av = isi; // if significantly less than we take that
	} else { // integrate on slower
		av += sk.ISIDt * (isi - av); // running avg updt
	}return av;
}
struct DendParams {
	GExp: f32,
	GR: f32,
	SSGi: f32,
	HasMod: i32,
	ModGain: f32,
	ModACh: i32,
	ModBase: f32,
	pad: i32,
}
struct ActInitParams {
	Vm: f32,
	Act: f32,
	GeBase: f32,
	GiBase: f32,
	GeVar: f32,
	GiVar: f32,
	pad: i32,
	pad1: i32,
}
struct DecayParams {
	Act: f32,
	Glong: f32,
	AHP: f32,
	LearnCa: f32,
	OnRew: i32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
struct DtParams {
	Integ: f32,
	VmC: f32,
	VmDendC: f32,
	VmSteps: i32,
	GeTau: f32,
	GiTau: f32,
	IntTau: f32,
	LongAvgTau: f32,
	MaxCycStart: i32,
	VmDt: f32,
	VmDendDt: f32,
	DtStep: f32,
	GeDt: f32,
	GiDt: f32,
	IntDt: f32,
	LongAvgDt: f32,
	MaxI: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
fn DtParams_GeSynFromRaw(dp: DtParams, geSyn: f32,geRaw: f32) -> f32 {
	return geSyn + geRaw - dp.GeDt*geSyn;
}
fn DtParams_GeSynFromRawSteady(dp: DtParams, geRaw: f32) -> f32 {
	return geRaw * dp.GeTau;
}
fn DtParams_GiSynFromRaw(dp: DtParams, giSyn: f32,giRaw: f32) -> f32 {
	return giSyn + giRaw - dp.GiDt*giSyn;
}
struct SpikeNoiseParams {
	On: i32,
	GeHz: f32,
	Ge: f32,
	GiHz: f32,
	Gi: f32,
	MaintGe: i32,
	GeExpInt: f32,
	GiExpInt: f32,
}
fn SpikeNoiseParams_PGe(an: SpikeNoiseParams, ctx: Context, p: ptr<function,f32>, ni: u32,di: u32) -> f32 {
	let nix = NetworkIxs[0];
	var ndi = di*nix.NNeurons + ni;
	*p *= GetRandomNumber(ndi, ctx.RandCounter.Counter, RandFunActPGe);
	if (*p <= an.GeExpInt) {
		*p = f32(1);return an.Ge;
	}return f32(
0);
}
fn SpikeNoiseParams_PGi(an: SpikeNoiseParams, ctx: Context, p: ptr<function,f32>, ni: u32,di: u32) -> f32 {
	let nix = NetworkIxs[0];
	var ndi = di*nix.NNeurons + ni;
	*p *= GetRandomNumber(ndi, ctx.RandCounter.Counter, RandFunActPGi);
	if (*p <= an.GiExpInt) {
		*p = f32(1);return an.Gi;
	}return f32(
0);
}
struct ClampParams {
	Ge: f32,
	Add: i32,
	ErrThr: f32,
	pad: f32,
}
struct SMaintParams {
	On: i32,
	NNeurons: f32,
	Ge: f32,
	Inhib: f32,
	ISI: F32,
}
fn SMaintParams_ExpInt(sm: SMaintParams, isi: f32) -> f32 {
	if (isi <= 0) {
		return f32(0);
	}return FastExp(-max(isi, sm.ISI.Min) / sm.NNeurons);
}
struct PopCodeParams {
	On: i32,
	Ge: f32,
	Min: f32,
	Max: f32,
	MinAct: f32,
	MinSigma: f32,
	MaxSigma: f32,
	Clip: i32,
}
fn PopCodeParams_ClampValue(pc: PopCodeParams, val: f32) -> f32 {
	var clipVal = val;
	if (clipVal < pc.Min) {
		clipVal = pc.Min;
	}
	if (clipVal > pc.Max) {
		clipVal = pc.Max;
	}return clipVal;
}
fn PopCodeParams_ProjectParam(pc: PopCodeParams, minParam: f32,maxParam: f32,clipVal: f32) -> f32 {
	var normVal = (clipVal - pc.Min) / (pc.Max - pc.Min);return minParam + normVal*(maxParam-minParam);
}
fn PopCodeParams_EncodeValue(pc: PopCodeParams, i: u32,n: u32, val: f32) -> f32 {
	var eval = val;
	var clipVal = PopCodeParams_ClampValue(pc, eval);
	if (pc.Clip == 1) {
		eval = clipVal;
	}
	var rng = pc.Max - pc.Min;
	var act = f32(1);
	if (pc.MinAct < 1) {
		act = PopCodeParams_ProjectParam(pc, pc.MinAct, f32(1.0), clipVal);
	}
	var sig = pc.MinSigma;
	if (pc.MaxSigma > pc.MinSigma) {
		sig = PopCodeParams_ProjectParam(pc, pc.MinSigma, pc.MaxSigma, clipVal);
	}
	var gnrm = 1.0 / (rng * sig);
	var incr = rng / f32(n-1);
	var trg = pc.Min + incr*f32(i);
	var dist = gnrm * (trg - eval);return act * FastExp(-(dist * dist));
}
fn PopCodeParams_EncodeGe(pc: PopCodeParams, i: u32,n: u32, val: f32) -> f32 {
	return pc.Ge * PopCodeParams_EncodeValue(pc, i, n, val);
}
struct ActParams {
	Spikes: SpikeParams,
	Dend: DendParams,
	Init: ActInitParams,
	Decay: DecayParams,
	Dt: DtParams,
	Gbar: Chans,
	Erev: Chans,
	Clamp: ClampParams,
	Noise: SpikeNoiseParams,
	VmRange: F32,
	Mahp: MahpParams,
	Sahp: SahpParams,
	KNa: KNaMedSlow,
	Kir: KirParams,
	NMDA: NMDAParams,
	MaintNMDA: NMDAParams,
	GabaB: GABABParams,
	VGCC: VGCCParams,
	AK: AKsParams,
	SKCa: SKCaParams,
	SMaint: SMaintParams,
	PopCode: PopCodeParams,
}
fn ActParams_NMDAFromRaw(ac: ActParams, ctx: Context, ni: u32,di: u32, geTot: f32) {
	if (ac.NMDA.Ge == 0) {
		return;
	}
	var geT = max(geTot, 0.0);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaSyn))] = NMDAParams_NMDASyn(ac.NMDA, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaSyn))], geT);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gnmda))] = NMDAParams_Gnmda(ac.NMDA, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaSyn))], Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))]);
}
fn ActParams_MaintNMDAFromRaw(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	if (ac.MaintNMDA.Ge == 0) {
		return;
	}
	if (ac.SMaint.On == 1) {
		ActParams_SMaintFromISI(ac, ctx, ni, di);
	}
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GMaintSyn))] = NMDAParams_NMDASyn(ac.MaintNMDA, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GMaintSyn))], Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GMaintRaw))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaMaint))] = NMDAParams_Gnmda(ac.MaintNMDA, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GMaintSyn))], Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))]);
}
fn ActParams_SMaintFromISI(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	let nix = NetworkIxs[0];
	var isi = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(ISIAvg))];
	if (isi < ac.SMaint.ISI.Min || isi > ac.SMaint.ISI.Max) {
		return;
	}
	var ndi = di*nix.NNeurons + ni;
	var smp = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SMaintP))];
	smp *= GetRandomNumber(ndi, ctx.RandCounter.Counter, RandFunActSMaintP);
	var trg = SMaintParams_ExpInt(ac.SMaint, isi);
	if (smp <= trg) {
		smp = f32(1);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GMaintRaw))] += ac.SMaint.Ge;
	}
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
	u32(ni), u32(di), u32(SMaintP))] = smp;
}
fn ActParams_GvgccFromVm(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	if (ac.VGCC.Ge == 0) {
		return;
	}
	var v = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))];
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gvgcc))] = VGCCParams_Gvgcc(ac.VGCC, v, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccM))], Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccH))]);
	var dm = VGCCParams_DeltaMFromV(ac.VGCC, v, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccM))]);
	var dh = VGCCParams_DeltaHFromV(ac.VGCC, v, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccH))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccM))] += dm;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71],
	TensorStrides[72], u32(ni), u32(di), u32(VgccH))] += dh;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCa))] = VGCCParams_CaFromG(ac.VGCC, v, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gvgcc))], Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCa))]);
}
fn ActParams_GkFromVm(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	var vm = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))];
	var vmd = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))];
	var mahpN = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(MahpN))];
	var gmahp = MahpParams_GmAHP(ac.Mahp, vm, &mahpN);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gmahp))] = gmahp;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(MahpN))] = mahpN;
	var gsahp = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gsahp))];
	var gak = AKsParams_Gak(ac.AK, vmd);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gak))] = gak;
	var nkirM = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(KirM))];
	var gkir = KirParams_Gkir(ac.Kir, vm, nkirM);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gkir))] = gkir;
	nkirM += KirParams_DM(ac.Kir, vm, nkirM);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(KirM))] = nkirM;
	var gktot = gmahp + gsahp + gak + gkir;
	if (ac.KNa.On == 1) {
		var gknaMed = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GknaMed))];
		var gknaSlow = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GknaSlow))];
		KNaMedSlow_GcFromSpike(ac.KNa, &gknaMed, &gknaSlow, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spike))] > .5);
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GknaMed))] = gknaMed;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GknaSlow))] = gknaSlow;
		gktot += gknaMed + gknaSlow;
	}
	Neurons[Index3D(TensorStrides[70], TensorStrides[71],
	TensorStrides[72], u32(ni), u32(di), u32(Gk))] = gktot;
}
fn ActParams_GSkCaFromCa(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	if (ac.SKCa.Gk == 0) {
		return;
	}
	var skcar = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaR))];
	var skcain = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaIn))];
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaM))] = SKCaParams_MFromCa(ac.SKCa, skcar, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaM))]);
	SKCaParams_CaInRFromSpike(ac.SKCa, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spike))], Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaD))], &skcain, &skcar);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaR))] = skcar;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaIn))] = skcain;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gsk))] = ac.SKCa.Gk * Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SKCaM))];
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gk))] += Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gsk))];
}
fn ActParams_GeFromSyn(ac: ActParams, ctx: Context, ni: u32,di: u32, geSyn: f32,geExt: f32) {
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeExt))] = 0.0;
	var geS = geSyn;
	var geE = geExt;
	if (ac.Clamp.Add == 1 && NeuronHasFlag(NeuronHasExt, ni, di)) {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeExt))] = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ext))] * ac.Clamp.Ge;
		geS += Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeExt))];
	}
	if (ac.Clamp.Add == 0 && NeuronHasFlag(NeuronHasExt, ni, di)) {
		geS = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ext))] * ac.Clamp.Ge;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
		u32(ni), u32(di), u32(GeExt))] = geS;
		geE = f32(0);
	}
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ge))] = geS + geE;
	if (Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ge))] < 0.0) {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ge))] = 0.0;
	}
	ActParams_AddGeNoise(ac, ctx, ni, di);
}
fn ActParams_AddGeNoise(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	if (ac.Noise.On == 0 || ac.Noise.Ge == 0) {
		return;
	}
	var p = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeNoiseP))];
	var ge = SpikeNoiseParams_PGe(ac.Noise, ctx, &p, ni, di);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeNoiseP))] = p;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeNoise))] = DtParams_GeSynFromRaw(ac.Dt, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeNoise))], ge);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ge))] += Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GeNoise))];
}
fn ActParams_AddGiNoise(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	if (ac.Noise.On == 0 || ac.Noise.Gi == 0) {
		return;
	}
	var p = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiNoiseP))];
	var gi = SpikeNoiseParams_PGi(ac.Noise, ctx, &p, ni, di);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiNoiseP))] = p;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiNoise))] = DtParams_GiSynFromRaw(ac.Dt, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GiNoise))], gi);
}
fn ActParams_GiFromSyn(ac: ActParams, ctx: Context, ni: u32,di: u32, giSyn: f32) -> f32 {
	ActParams_AddGiNoise(ac, ctx, ni, di);
	if (giSyn < 0) { // negative inhib G doesn't make any sense
		return f32(0);
	}return giSyn;
}
fn ActParams_InetFromG(ac: ActParams, vm: f32,ge: f32,gl: f32,gi: f32,gk: f32) -> f32 {
	var inet = ge*(ac.Erev.E-vm) + gl*ac.Gbar.L*(ac.Erev.L-vm) + gi*(ac.Erev.I-vm) + gk*(ac.Erev.K-vm);
	if (inet > ac.Dt.MaxI) {
		inet = ac.Dt.MaxI;
	} else if (inet < -ac.Dt.MaxI) {
		inet = -ac.Dt.MaxI;
	}return inet;
}
fn ActParams_VmFromInet(ac: ActParams, vm: f32,dt: f32,inet: f32) -> f32 {
	return F32_ClampValue(ac.VmRange, vm + dt*inet);
}
fn ActParams_VmInteg(ac: ActParams, vm: f32,dt: f32,ge: f32,gl: f32,gi: f32,gk: f32, nvm: ptr<function,f32>,inet: ptr<function,f32>) {
	var dtEff = dt * ac.Dt.DtStep;
	*nvm = vm;
	for (var i = i32(0); i < ac.Dt.VmSteps; i++) {
		*inet = ActParams_InetFromG(ac, *nvm, ge, gl, gi, gk);
		*nvm = ActParams_VmFromInet(ac, *nvm, dtEff, *inet);
	}
}
fn ActParams_VmFromG(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	var updtVm = true;
	var isi = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(ISI))];
	if (ac.Spikes.Tr > 0 && isi >= 0 && isi < f32(ac.Spikes.Tr)) {
		updtVm = false; // don't update the spiking vm during refract
	}
	var ge = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Ge))] * ac.Gbar.E;
	var gi = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gi))] * ac.Gbar.I;
	var gk = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Gk))] * ac.Gbar.K;
	var nvm: f32;
	var inet: f32;
	var expi: f32;
	if (updtVm) {
		ActParams_VmInteg(ac, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))], ac.Dt.VmDt, ge, f32(f32(1)), gi, gk, &nvm, &inet);
		if (updtVm && ac.Spikes.Exp == 1) { // add spike current if relevant
			var exVm: f32;
			exVm = 0.5 * (nvm + Neurons[Index3D(TensorStrides[70], TensorStrides[71], // midpoint for this
			TensorStrides[72], u32(ni), u32(di), u32(Vm))]);
			expi = ac.Gbar.L * ac.Spikes.ExpSlope *
				FastExp((exVm-ac.Spikes.Thr)/ac.Spikes.ExpSlope);
			if (expi > ac.Dt.MaxI) {
				expi = ac.Dt.MaxI;
			}
			inet += expi;
			nvm = ActParams_VmFromInet(ac, nvm, ac.Dt.VmDt, expi);
		}
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))] = nvm;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72],
		u32(ni), u32(di), u32(Inet))] = inet;
	} else {
		var dvm: f32;
		if (i32(isi) == ac.Spikes.Tr-1) {
			dvm = ac.Spikes.VmR - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))];
		} else {
			dvm = ac.Spikes.RDt * (ac.Spikes.VmR - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))]);
		}
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))] += dvm;
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Inet))] = dvm * ac.Dt.VmC;
	}
	var glEff = f32(1);
	if (!updtVm) {
		glEff += ac.Dend.GR;
	}
	var giEff: f32;
	giEff = gi + ac.Gbar.I*Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(SSGiDend))];
	ActParams_VmInteg(ac, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))], ac.Dt.VmDendDt, ge, glEff, giEff, gk, &nvm, &inet);
	if (updtVm) {
		nvm = ActParams_VmFromInet(ac, nvm, ac.Dt.VmDendDt, ac.Dend.GExp*expi);
	}
	Neurons[Index3D(TensorStrides[70], TensorStrides[71],
	TensorStrides[72], u32(ni), u32(di), u32(VmDend))] = nvm;
}
fn ActParams_SpikeFromVmVars(ac: ActParams, nrnISI: ptr<function,f32>,nrnISIAvg: ptr<function,f32>,nrnSpike: ptr<function,f32>,nrnSpiked: ptr<function,f32>,nrnAct: ptr<function,f32>, nrnVm: f32) {
	var thr: f32;
	if (ac.Spikes.Exp == 1) {
		thr = ac.Spikes.ExpThr;
	} else {
		thr = ac.Spikes.Thr;
	}
	if (nrnVm >= thr) {
		*nrnSpike = f32(1);
		if (*nrnISIAvg == -1) {
			*nrnISIAvg = f32(-2);
		} else if (*nrnISI > 0) { // must have spiked to update
			*nrnISIAvg = SpikeParams_AvgFromISI(ac.Spikes, *nrnISIAvg, *nrnISI+1);
		}
		*nrnISI = f32(0);
	} else {
		*nrnSpike = f32(0);
		if (*nrnISI >= 0) {
			*nrnISI += f32(1);
			if (*nrnISI < 10) {
				*nrnSpiked = f32(1);
			} else {
				*nrnSpiked = f32(0);
			}
			if (*nrnISI > 200) { // keep from growing infinitely large
				*nrnISI = f32(-1);
			}
		} else {
			*nrnSpiked = f32(0);
		}
		if (*nrnISIAvg >= 0 && *nrnISI > 0 && *nrnISI > 1.2**nrnISIAvg) {
			*nrnISIAvg = SpikeParams_AvgFromISI(ac.Spikes, *nrnISIAvg, *nrnISI);
		}
	}
	var nwAct = SpikeParams_ActFromISI(ac.Spikes, *nrnISIAvg, f32(.001), ac.Dt.Integ);
	if (nwAct > 1) {
		nwAct = f32(1);
	}
	nwAct = *nrnAct + 100*ac.Dt.VmDt*(nwAct-*nrnAct); // 100 restores to prior behavior
	*nrnAct = nwAct;
}
fn ActParams_SpikeFromVm(ac: ActParams, ctx: Context, ni: u32,di: u32) {
	var nrnISI = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(ISI))];
	var nrnISIAvg = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(ISIAvg))];
	var nrnSpike = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spike))];
	var nrnSpiked = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spiked))];
	var nrnAct = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Act))];
	var nrnVm = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Vm))];
	ActParams_SpikeFromVmVars(ac, &nrnISI, &nrnISIAvg, &nrnSpike, &nrnSpiked, &nrnAct, nrnVm);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(ISI))] = nrnISI;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(ISIAvg))] = nrnISIAvg;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spike))] = nrnSpike;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spiked))] = nrnSpiked;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Act))] = nrnAct;
}

//////// import: "chans-ak.go"
struct AKsParams {
	Gk: f32,
	Hf: f32,
	Mf: f32,
	Voff: f32,
	Vmax: f32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}
fn AKsParams_MFromV(ap: AKsParams, v: f32) -> f32 {
	var av = v;
	if (v > ap.Vmax) {
		av = ap.Vmax;
	}return ap.Hf / (1.0 + FastExp(-ap.Mf*(av+ap.Voff)));
}
fn AKsParams_Gak(ap: AKsParams, v: f32) -> f32 {
	return ap.Gk * AKsParams_MFromV(ap, v);
}

//////// import: "chans-chans.go"
struct Chans {
	E: f32,
	L: f32,
	I: f32,
	K: f32,
}

//////// import: "chans-gabab.go"
struct GABABParams {
	Gk: f32,
	Rise: f32,
	Decay: f32,
	Gbase: f32,
	GiSpike: f32,
	MaxTime: f32,
	TauFact: f32,
	RiseDt: f32,
	DecayDt: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
fn GABABParams_GFromV(gp: GABABParams, v: f32) -> f32 {
	var ve = max(v, -90.0);return (ve + 90.0) / (1.0 + FastExp(0.1*((ve+90.0)+10.0)));
}
fn GABABParams_GFromS(gp: GABABParams, s: f32) -> f32 {
	var ss = s * gp.GiSpike;
	if (ss > 20) {
		return f32(1);
	}return 1.0 / (1.0 + FastExp(-(ss-7.1)/1.4));
}
fn GABABParams_DeltaM(gp: GABABParams, m: f32,x: f32) -> f32 {
	return (gp.TauFact*x - m) * gp.RiseDt;
}
fn GABABParams_MX(gp: GABABParams, gi: f32, m: ptr<function,f32>,x: ptr<function,f32>) {
	var dM = GABABParams_DeltaM(gp, *m, *x);
	*x += GABABParams_GFromS(gp, gi) - (*x)*gp.DecayDt;
	*m += dM;return;
}
fn GABABParams_GgabaB(gp: GABABParams, m: f32,v: f32) -> f32 {
	return gp.Gk * GABABParams_GFromV(gp, v) * (m + gp.Gbase);
}

//////// import: "chans-kir.go"
struct KirParams {
	Gk: f32,
	MinfOff: f32,
	MinfTau: f32,
	RiseOff: f32,
	RiseTau: f32,
	DecayOff: f32,
	DecayTau: f32,
	Mrest: f32,
}
fn KirParams_Minf(kp: KirParams, v: f32) -> f32 {
	return 1.0 / (1.0 + FastExp((v-kp.MinfOff)/kp.MinfTau));
}
fn KirParams_MTau(kp: KirParams, v: f32) -> f32 {
	var alpha = 0.1 * FastExp(-(v-kp.RiseOff)/kp.RiseTau);
	var beta = 0.27 / (1.0 + FastExp(-(v-kp.DecayOff)/kp.DecayTau));return 1.0 / (alpha + beta);
}
fn KirParams_DM(kp: KirParams, v: f32,m: f32) -> f32 {
	var minf = KirParams_Minf(kp, v);
	var mtau = KirParams_MTau(kp, v);
	var dm = (minf - m) / (mtau * 3); // 3 = Q10
return dm;
}
fn KirParams_Gkir(kp: KirParams, v: f32, m: f32) -> f32 {
	return kp.Gk * m;
}

//////// import: "chans-kna.go"
struct KNaParams {
	On: i32,
	Rise: f32,
	Decay: f32,
	Max: f32,
	DtRise: f32,
	DtDecay: f32,
	pad: i32,
	pad1: i32,
}
fn KNaParams_GcFromSpike(ka: KNaParams, gKNa: ptr<function,f32>, spike: bool) {
	if (ka.On == 1) {
		if (spike) {
			*gKNa += ka.DtRise * (ka.Max - *gKNa);
		} else {
			*gKNa -= ka.DtDecay * *gKNa;
		}
	} else {
		*gKNa = f32(0);
	}
}
struct KNaMedSlow {
	On: i32,
	TrialSlow: i32,
	pad: i32,
	pad1: i32,
	Med: KNaParams,
	Slow: KNaParams,
}
fn KNaMedSlow_GcFromSpike(ka: KNaMedSlow, gKNaM: ptr<function,f32>,gKNaS: ptr<function,f32>, spike: bool) {
	KNaParams_GcFromSpike(ka.Med, gKNaM, spike);
	if (ka.TrialSlow == 0) {
		KNaParams_GcFromSpike(ka.Slow, gKNaS, spike);
	}
}

//////// import: "chans-mahp.go"
struct MahpParams {
	Gk: f32,
	Off: f32,
	Slope: f32,
	TauMax: f32,
	Tadj: f32,
	DtMax: f32,
	pad: i32,
	pad2: i32,
}
fn MahpParams_EFun(mp: MahpParams, z: f32) -> f32 {
	if (abs(z) < 1.0e-4) {
		return 1.0 - 0.5*z;
	}return z / (FastExp(z) - 1.0);
}
fn MahpParams_NinfTauFromV(mp: MahpParams, v: f32, ninf: ptr<function,f32>,tau: ptr<function,f32>) {
	var vo = v - mp.Off;
	var a = mp.DtMax * mp.Slope * MahpParams_EFun(mp, -vo/mp.Slope);
	var b = mp.DtMax * mp.Slope * MahpParams_EFun(mp, vo/mp.Slope);
	*tau = 1.0 / (a + b);
	*ninf = a * *tau; // a / (a+b)
	*tau /= mp.Tadj;  // correct right away..
return;
}
fn MahpParams_DNFromV(mp: MahpParams, v: f32,n: f32) -> f32 {
	var ninf: f32;
	var tau: f32;
	MahpParams_NinfTauFromV(mp, v, &ninf, &tau);
	var dn = (ninf - n) / tau;return dn;
}
fn MahpParams_GmAHP(mp: MahpParams, v: f32, n: ptr<function,f32>) -> f32 {
	var dn = MahpParams_DNFromV(mp, v, *n);
	*n += dn;
	var g = mp.Tadj * mp.Gk * *n;return g;
}

//////// import: "chans-nmda.go"
struct NMDAParams {
	Ge: f32,
	Tau: f32,
	ITau: f32,
	MgC: f32,
	Voff: f32,
	Dt: f32,
	IDt: f32,
	MgFact: f32,
}
fn NMDAParams_MgGFromV(np: NMDAParams, v: f32) -> f32 {
	var av = v + np.Voff;
	if (av >= 0) {
		return f32(0);
	}return -av / (1.0 + np.MgFact*FastExp(-0.062*av));
}
fn NMDAParams_CaFromV(np: NMDAParams, v: f32) -> f32 {
	var av = v + np.Voff;
	if (av > -0.5 && av < 0.5) { // this eliminates div 0 at 0, and numerical "fuzz" around 0
		return 1.0 / (0.0756 * (1 + 0.0378*av));
	}return -av / (1.0 - FastExp(0.0756*av));
}
fn NMDAParams_NMDASyn(np: NMDAParams, nmda: f32,raw: f32) -> f32 {
	return nmda + raw - np.Dt*nmda;
}
fn NMDAParams_Gnmda(np: NMDAParams, nmda: f32,vm: f32) -> f32 {
	return np.Ge * NMDAParams_MgGFromV(np, vm) * nmda;
}

//////// import: "chans-sahp.go"
struct SahpParams {
	Gk: f32,
	CaTau: f32,
	Off: f32,
	Slope: f32,
	TauMax: f32,
	CaDt: f32,
	DtMax: f32,
	pad: i32,
}

//////// import: "chans-skca.go"
struct SKCaParams {
	Gk: f32,
	C50: f32,
	Rise: f32,
	Decay: f32,
	KCaR: f32,
	CaRDecayTau: f32,
	CaInThr: f32,
	CaInTau: f32,
	RiseDt: f32,
	DecayDt: f32,
	CaRDecayDt: f32,
	CaInDt: f32,
}
fn SKCaParams_MAsympHill(sp: SKCaParams, cai: f32) -> f32 {
	var caia = cai / sp.C50;
	var capow = caia * caia * caia * caia;return capow / (1 + capow);
}
fn SKCaParams_CaInRFromSpike(sp: SKCaParams, spike: f32,caD: f32, caIn: ptr<function,f32>,caR: ptr<function,f32>) {
	*caR -= *caR * sp.CaRDecayDt;
	if (spike > 0) {
		var x = *caIn * sp.KCaR;
		*caR += x;
		*caIn -= x;
	}
	if (caD < sp.CaInThr) {
		*caIn += sp.CaInDt * (1.0 - *caIn);
	}
}
fn SKCaParams_MFromCa(sp: SKCaParams, caR: f32,mcur: f32) -> f32 {
	var mas = SKCaParams_MAsympHill(sp, caR);
	if (mas > mcur) {
		return mcur + sp.RiseDt*(mas-mcur);
	}return mcur + sp.DecayDt*(mas-mcur);
}

//////// import: "chans-vgcc.go"
struct VGCCParams {
	Ge: f32,
	Ca: f32,
	pad: i32,
	pad1: i32,
}
fn VGCCParams_GFromV(np: VGCCParams, v: f32) -> f32 {
	if (v > -0.5 && v < 0.5) { // this avoids divide by 0, and numerical instability around 0
		return 1.0 / (0.0756 * (1 + 0.0378*v));
	}return -v / (1.0 - FastExp(0.0756*v));
}
fn VGCCParams_MFromV(np: VGCCParams, v: f32) -> f32 {
	if (v < -60) {
		return f32(0);
	}
	if (v > -10) {
		return f32(1);
	}return 1.0 / (1.0 + FastExp(-(v + 37)));
}
fn VGCCParams_HFromV(np: VGCCParams, v: f32) -> f32 {
	if (v < -50) {
		return f32(1);
	}
	if (v > -10) {
		return f32(0);
	}return 1.0 / (1.0 + FastExp((v+41)*2));
}
fn VGCCParams_DeltaMFromV(np: VGCCParams, v: f32,m: f32) -> f32 {
	var vb = min(v, 0.0);return (VGCCParams_MFromV(np, vb) - m) / 3.6;
}
fn VGCCParams_DeltaHFromV(np: VGCCParams, v: f32,h: f32) -> f32 {
	var vb = min(v, 0.0);return (VGCCParams_HFromV(np, vb) - h) / 29.0;
}
fn VGCCParams_Gvgcc(np: VGCCParams, v: f32,m: f32,h: f32) -> f32 {
	return np.Ge * VGCCParams_GFromV(np, v) * m * m * m * h;
}
fn VGCCParams_CaFromG(np: VGCCParams, v: f32,g: f32,ca: f32) -> f32 {
	return -v * np.Ca * g;
}

//////// import: "context.go"
struct Context { //types:add -setters
	NData: u32,
	Mode: i32,
	Testing: i32,
	Phase: i32,
	PlusPhase: i32,
	PhaseCycle: i32,
	Cycle: i32,
	ThetaCycles: i32,
	PlusCycles: i32,
	CaBinCycles: i32,
	CyclesTotal: i32,
	Time: f32,
	TrialsTotal: i32,
	TimePerCycle: f32,
	SlowInterval: i32,
	SlowCounter: i32,
	AdaptGiInterval: i32,
	AdaptGiCounter: i32,
	pad: i32,
	pad1: i32,
	RandCounter: RandCounter,
}
fn Context_ItemIndex(ctx: Context, idx: u32) -> u32 {
	return idx / ctx.NData;
}
fn Context_DataIndex(ctx: Context, idx: u32) -> u32 {
	return idx % ctx.NData;
}

//////// import: "deep-layer.go"
struct BurstParams {
	ThrRel: f32,
	ThrAbs: f32,
	pad: f32,
	pad1: f32,
}
struct CTParams {
	GeGain: f32,
	DecayTau: f32,
	OFCposPT: i32,
	DecayDt: f32,
}
struct PulvParams {
	DriveScale: f32,
	FullDriveAct: f32,
	DriveLayIndex: i32,
	pad: f32,
}
fn PulvParams_DriveGe(tp: PulvParams, act: f32) -> f32 {
	return tp.DriveScale * act;
}
fn PulvParams_NonDrivePct(tp: PulvParams, drvMax: f32) -> f32 {
	return 1.0 - min(1.0, drvMax/tp.FullDriveAct);
}

//////// import: "deep-path.go"

//////// import: "enumgen.go"
const PathGTypesN: PathGTypes = 5;
const GlobalScalarVarsN: GlobalScalarVars = 58;
const GlobalVectorVarsN: GlobalVectorVars = 10;
const GPUVarsN: GPUVars = 23;
const LayerTypesN: LayerTypes = 30;
const LayerVarsN: LayerVars = 12;
const ViewTimesN: ViewTimes = 7;
const DAModTypesN: DAModTypes = 4;
const ValenceTypesN: ValenceTypes = 3;
const NeuronFlagsN: NeuronFlags = 9;
const NeuronVarsN: NeuronVars = 85;
const NeuronAvgVarsN: NeuronAvgVars = 7;
const NeuronIndexVarsN: NeuronIndexVars = 3;
const PathTypesN: PathTypes = 12;
const GPLayerTypesN: GPLayerTypes = 3;
const PoolIndexVarsN: PoolIndexVars = 4;
const PoolIntVarsN: PoolIntVars = 6;
const AvgMaxN: AvgMax = 2;
const AvgMaxPhasesN: AvgMaxPhases = 4;
const AvgMaxVarsN: AvgMaxVars = 7;
const SynapseVarsN: SynapseVars = 5;
const SynapseTraceVarsN: SynapseTraceVars = 3;
const SynapseIndexVarsN: SynapseIndexVars = 3;

//////// import: "fsfffb-enumgen.go"
const InhibVarsN: InhibVars = 16;

//////// import: "fsfffb-fsfffb.go"
struct GiParams {
	On: i32,
	Gi: f32,
	FB: f32,
	FSTau: f32,
	SS: f32,
	SSfTau: f32,
	SSiTau: f32,
	FS0: f32,
	FFAvgTau: f32,
	FFPrv: f32,
	ClampExtMin: f32,
	FSDt: f32,
	SSfDt: f32,
	SSiDt: f32,
	FFAvgDt: f32,
	pad: f32,
}

//////// import: "fsfffb-inhib.go"
alias InhibVars = i32; //enums:enum
const  FFsRaw: InhibVars = 0;
const  FBsRaw: InhibVars = 1;
const  GeExtRaw: InhibVars = 2;
const  FFs: InhibVars = 3;
const  FBs: InhibVars = 4;
const  GeExts: InhibVars = 5;
const  FSi: InhibVars = 6;
const  SSi: InhibVars = 7;
const  SSf: InhibVars = 8;
const  FSGi: InhibVars = 9;
const  SSGi: InhibVars = 10;
const  TotalGi: InhibVars = 11;
const  GiOrig: InhibVars = 12;
const  LayGi: InhibVars = 13;
const  FFAvg: InhibVars = 14;
const  FFAvgPrv: InhibVars = 15;

//////// import: "globals.go"
alias GlobalScalarVars = i32; //enums:enum
const  GvRew: GlobalScalarVars = 0;
const  GvHasRew: GlobalScalarVars = 1;
const  GvRewPred: GlobalScalarVars = 2;
const  GvPrevPred: GlobalScalarVars = 3;
const  GvHadRew: GlobalScalarVars = 4;
const  GvDA: GlobalScalarVars = 5;
const  GvDAtonic: GlobalScalarVars = 6;
const  GvACh: GlobalScalarVars = 7;
const  GvNE: GlobalScalarVars = 8;
const  GvSer: GlobalScalarVars = 9;
const  GvAChRaw: GlobalScalarVars = 10;
const  GvGoalMaint: GlobalScalarVars = 11;
const  GvVSMatrixJustGated: GlobalScalarVars = 12;
const  GvVSMatrixHasGated: GlobalScalarVars = 13;
const  GvCuriosityPoolGated: GlobalScalarVars = 14;
const  GvTime: GlobalScalarVars = 15;
const  GvEffort: GlobalScalarVars = 16;
const  GvUrgencyRaw: GlobalScalarVars = 17;
const  GvUrgency: GlobalScalarVars = 18;
const  GvHasPosUS: GlobalScalarVars = 19;
const  GvHadPosUS: GlobalScalarVars = 20;
const  GvNegUSOutcome: GlobalScalarVars = 21;
const  GvHadNegUSOutcome: GlobalScalarVars = 22;
const  GvPVposSum: GlobalScalarVars = 23;
const  GvPVpos: GlobalScalarVars = 24;
const  GvPVnegSum: GlobalScalarVars = 25;
const  GvPVneg: GlobalScalarVars = 26;
const  GvPVposEst: GlobalScalarVars = 27;
const  GvPVposVar: GlobalScalarVars = 28;
const  GvPVnegEst: GlobalScalarVars = 29;
const  GvPVnegVar: GlobalScalarVars = 30;
const  GvGoalDistEst: GlobalScalarVars = 31;
const  GvGoalDistPrev: GlobalScalarVars = 32;
const  GvProgressRate: GlobalScalarVars = 33;
const  GvGiveUpUtility: GlobalScalarVars = 34;
const  GvContUtility: GlobalScalarVars = 35;
const  GvGiveUpTiming: GlobalScalarVars = 36;
const  GvContTiming: GlobalScalarVars = 37;
const  GvGiveUpProgress: GlobalScalarVars = 38;
const  GvContProgress: GlobalScalarVars = 39;
const  GvGiveUpSum: GlobalScalarVars = 40;
const  GvContSum: GlobalScalarVars = 41;
const  GvGiveUpProb: GlobalScalarVars = 42;
const  GvGiveUp: GlobalScalarVars = 43;
const  GvGaveUp: GlobalScalarVars = 44;
const  GvVSPatchPos: GlobalScalarVars = 45;
const  GvVSPatchPosThr: GlobalScalarVars = 46;
const  GvVSPatchPosRPE: GlobalScalarVars = 47;
const  GvVSPatchPosSum: GlobalScalarVars = 48;
const  GvVSPatchPosPrev: GlobalScalarVars = 49;
const  GvVSPatchPosVar: GlobalScalarVars = 50;
const  GvLHbDip: GlobalScalarVars = 51;
const  GvLHbBurst: GlobalScalarVars = 52;
const  GvLHbPVDA: GlobalScalarVars = 53;
const  GvCeMpos: GlobalScalarVars = 54;
const  GvCeMneg: GlobalScalarVars = 55;
const  GvVtaDA: GlobalScalarVars = 56;
const  GvCaBinWts: GlobalScalarVars = 57;
const MaxGlobalVecN = 16;
alias GlobalVectorVars = i32; //enums:enum
const  GvCost: GlobalVectorVars = 0;
const  GvCostRaw: GlobalVectorVars = 1;
const  GvUSneg: GlobalVectorVars = 2;
const  GvUSnegRaw: GlobalVectorVars = 3;
const  GvDrives: GlobalVectorVars = 4;
const  GvUSpos: GlobalVectorVars = 5;
const  GvVSPatchD1: GlobalVectorVars = 6;
const  GvVSPatchD2: GlobalVectorVars = 7;
const  GvOFCposPTMaint: GlobalVectorVars = 8;
const  GvVSMatrixPoolGated: GlobalVectorVars = 9;

//////// import: "hip_paths.go"
struct HipPathParams {
	Hebb: f32,
	Err: f32,
	SAvgCor: f32,
	SAvgThr: f32,
	SNominal: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}

//////// import: "inhib.go"
struct ActAvgParams {
	Nominal: f32,
	RTThr: f32,
	AdaptGi: i32,
	Offset: f32,
	HiTol: f32,
	LoTol: f32,
	AdaptRate: f32,
	AdaptMax: f32,
}
struct InhibParams {
	ActAvg: ActAvgParams,
	Layer: GiParams,
	Pool: GiParams,
}

//////// import: "init-layer.go"

//////// import: "kinase-params.go"
struct CaDtParams { //types:add
	MTau: f32,
	PTau: f32,
	DTau: f32,
	MDt: f32,
	PDt: f32,
	DDt: f32,
	pad: i32,
	pad1: i32,
}
fn CaDtParams_FromCa(kp: CaDtParams, ca: f32, caM: ptr<function,f32>,caP: ptr<function,f32>,caD: ptr<function,f32>) {
	*caM += kp.MDt * (ca - *caM);
	*caP += kp.PDt * (*caM - *caP);
	*caD += kp.DDt * (*caP - *caD);
}
struct CaSpikeParams {
	SpikeCaM: f32,
	SpikeCaSyn: f32,
	CaSynTau: f32,
	CaSynDt: f32,
	Dt: CaDtParams,
}
fn CaSpikeParams_CaMFromSpike(sp: CaSpikeParams, spike: f32, caM: ptr<function,f32>,caP: ptr<function,f32>,caD: ptr<function,f32>) {
	var ca = sp.SpikeCaM * spike;
	CaDtParams_FromCa(sp.Dt, ca, caM, caP, caD);
}
fn CaSpikeParams_CaSynFromSpike(sp: CaSpikeParams, spike: f32, caSyn: f32) -> f32 {
	var ca = sp.SpikeCaSyn * spike;return caSyn + sp.CaSynDt*(ca-caSyn);
}

//////// import: "layerparams.go"
struct LayerIndexes {
	NPools: u32,
	NeurSt: u32,
	NNeurons: u32,
	RecvSt: u32,
	RecvN: u32,
	SendSt: u32,
	SendN: u32,
	ExtsSt: u32,
	ShpPlY: i32,
	ShpPlX: i32,
	ShpUnY: i32,
	ShpUnX: i32,
}
struct LayerInhibIndexes {
	Index1: i32,
	Index2: i32,
	Index3: i32,
	Index4: i32,
}
struct LayerParams {
	Type: LayerTypes,
	Index: u32,
	MaxData: u32,
	PoolSt: u32,
	Acts: ActParams,
	Inhib: InhibParams,
	LayInhib: LayerInhibIndexes,
	Learn: LearnNeuronParams,
	Bursts: BurstParams,
	CT: CTParams,
	Pulv: PulvParams,
	Matrix: MatrixParams,
	GP: GPParams,
	LDT: LDTParams,
	VTA: VTAParams,
	RWPred: RWPredParams,
	RWDa: RWDaParams,
	TDInteg: TDIntegParams,
	TDDa: TDDaParams,
	Indexes: LayerIndexes,
}
fn LayerParams_PoolIndex(ly: LayerParams, pi: u32) -> u32 {
	return ly.PoolSt + pi;
}

//////// import: "layertypes.go"
alias LayerTypes = i32; //enums:enum
const  SuperLayer: LayerTypes = 0;
const  InputLayer: LayerTypes = 1;
const  TargetLayer: LayerTypes = 2;
const  CompareLayer: LayerTypes = 3;
const  CTLayer: LayerTypes = 4;
const  PulvinarLayer: LayerTypes = 5;
const  TRNLayer: LayerTypes = 6;
const  PTMaintLayer: LayerTypes = 7;
const  PTPredLayer: LayerTypes = 8;
const  MatrixLayer: LayerTypes = 9;
const  STNLayer: LayerTypes = 10;
const  GPLayer: LayerTypes = 11;
const  BGThalLayer: LayerTypes = 12;
const  VSGatedLayer: LayerTypes = 13;
const  BLALayer: LayerTypes = 14;
const  CeMLayer: LayerTypes = 15;
const  VSPatchLayer: LayerTypes = 16;
const  LHbLayer: LayerTypes = 17;
const  DrivesLayer: LayerTypes = 18;
const  UrgencyLayer: LayerTypes = 19;
const  USLayer: LayerTypes = 20;
const  PVLayer: LayerTypes = 21;
const  LDTLayer: LayerTypes = 22;
const  VTALayer: LayerTypes = 23;
const  RewLayer: LayerTypes = 24;
const  RWPredLayer: LayerTypes = 25;
const  RWDaLayer: LayerTypes = 26;
const  TDPredLayer: LayerTypes = 27;
const  TDIntegLayer: LayerTypes = 28;
const  TDDaLayer: LayerTypes = 29;

//////// import: "layervars.go"
alias LayerVars = i32; //enums:enum
const  LayerActMAvg: LayerVars = 0;
const  LayerActPAvg: LayerVars = 1;
const  LayerAvgMaxGeM: LayerVars = 2;
const  LayerAvgMaxGiM: LayerVars = 3;
const  LayerGiMult: LayerVars = 4;
const  LayerPhaseDiff: LayerVars = 5;
const  LayerPhaseDiffAvg: LayerVars = 6;
const  LayerPhaseDiffVar: LayerVars = 7;
const  LayerRT: LayerVars = 8;
const  GatedRT: LayerVars = 9;
const  LayerRewPredPos: LayerVars = 10;
const  LayerRewPredNeg: LayerVars = 11;

//////// import: "learn-layer.go"

//////// import: "learn-net.go"

//////// import: "learn-path.go"

//////// import: "learn.go"
struct LearnCaParams {
	Norm: f32,
	SpikeVGCC: i32,
	SpikeVgccCa: f32,
	VgccTau: f32,
	ETraceTau: f32,
	ETraceScale: f32,
	pad: f32,
	pad1: f32,
	Dt: CaDtParams,
	VgccDt: f32,
	ETraceDt: f32,
	NormInv: f32,
	pad2: i32,
}
fn LearnCaParams_VgccCaFromSpike(lc: LearnCaParams, ctx: Context, ni: u32,di: u32) {
	if (lc.SpikeVGCC == 1) {
		Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCa))] = lc.SpikeVgccCa * Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spike))];
	}
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCaInt))] += Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCa))] - lc.VgccDt*Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCaInt))];
}
fn LearnCaParams_LearnCas(lc: LearnCaParams, ctx: Context, ni: u32,di: u32) {
	LearnCaParams_VgccCaFromSpike(lc, ctx, ni, di);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCa))] = lc.NormInv * (Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(NmdaCa))] + Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VgccCaInt))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaM))] += lc.Dt.MDt * (Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCa))] - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaM))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaP))] += lc.Dt.PDt * (Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaM))] - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaP))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaD))] += lc.Dt.DDt * (Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaP))] - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaD))]);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaDiff))] = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaP))] - Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(LearnCaD))];
}
struct TrgAvgActParams {
	GiBaseInit: f32,
	RescaleOn: i32,
	ErrLRate: f32,
	SynScaleRate: f32,
	SubMean: f32,
	Permute: i32,
	Pool: i32,
	pad: i32,
	TrgRange: F32,
}
struct RLRateParams {
	On: i32,
	SigmoidLinear: i32,
	SigmoidMin: f32,
	Diff: i32,
	SpikeThr: f32,
	DiffThr: f32,
	Min: f32,
	pad: i32,
}
struct LearnNeuronParams {
	CaLearn: LearnCaParams,
	CaSpike: CaSpikeParams,
	LearnNMDA: NMDAParams,
	TrgAvgAct: TrgAvgActParams,
	RLRate: RLRateParams,
	NeuroMod: NeuroModParams,
}
fn LearnNeuronParams_LearnNMDAFromRaw(ln: LearnNeuronParams, ctx: Context, ni: u32,di: u32, geTot: f32) {
	var geEff = max(geTot, 0.0);
	var vmd = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(VmDend))];
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaLrn))] = NMDAParams_NMDASyn(ln.LearnNMDA, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaLrn))], geEff);
	var gnmda = NMDAParams_Gnmda(ln.LearnNMDA, Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(GnmdaLrn))], vmd);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(NmdaCa))] = f32(gnmda * NMDAParams_CaFromV(ln.LearnNMDA, vmd));
}
fn LearnNeuronParams_CaFromSpike(ln: LearnNeuronParams, ctx: Context, ni: u32,di: u32) {
	var caM = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaM))];
	var caP = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaP))];
	var caD = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaD))];
	var spike = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(Spike))];
	CaSpikeParams_CaMFromSpike(ln.CaSpike, spike, &caM, &caP, &caD);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaM))] = caM;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaP))] = caP;
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaD))] = caD;
	var caSyn = Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaSyn))];
	caSyn = CaSpikeParams_CaSynFromSpike(ln.CaSpike, spike, caSyn);
	Neurons[Index3D(TensorStrides[70], TensorStrides[71], TensorStrides[72], u32(ni), u32(di), u32(CaSyn))] = caSyn;
	LearnCaParams_LearnCas(ln.CaLearn, ctx, ni, di);
}
struct SWtInitParams {
	SPct: f32,
	Mean: f32,
	Var: f32,
	Sym: i32,
}
struct SWtAdaptParams {
	On: i32,
	LRate: f32,
	SubMean: f32,
	HiMeanDecay: f32,
	HiMeanThr: f32,
	SigGain: f32,
	pad: f32,
	pad1: f32,
}
struct SWtParams {
	Init: SWtInitParams,
	Adapt: SWtAdaptParams,
	Limit: F32,
}
struct LRateParams {
	Base: f32,
	Sched: f32,
	Mod: f32,
	Eff: f32,
}
struct DWtParams {
	SynCa20: i32,
	CaPScale: f32,
	SubMean: f32,
	SynTraceTau: f32,
	LearnThr: f32,
	SynTraceDt: f32,
	pad: f32,
	pad1: f32,
}
struct HebbParams {
	On: i32,
	Up: f32,
	Down: f32,
	pad: f32,
}
struct LearnSynParams {
	Learn: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
	LRate: LRateParams,
	DWt: DWtParams,
	Hebb: HebbParams,
}

//////// import: "looper.go"
alias ViewTimes = i32; //enums:enum
const  Cycle: ViewTimes = 0;
const  FastSpike: ViewTimes = 1;
const  Gamma: ViewTimes = 2;
const  Beta: ViewTimes = 3;
const  Alpha: ViewTimes = 4;
const  Phase: ViewTimes = 5;
const  Theta: ViewTimes = 6;

//////// import: "math32-fastexp.go"
fn FastExp(x: f32) -> f32 {
	if (x <= -88.02969) { // this doesn't add anything and -exp is main use-case anyway
		return f32(0.0);
	}
	var i = i32(12102203*x) + i32(127)*(i32(1)<<23);
	var m = (i >> 7) & 0xFFFF; // copy mantissa
	i += (((((((((((3537 * m) >> 16) + 13668) * m) >> 18) + 15817) * m) >> 14) - 80470) * m) >> 11);return bitcast<f32>(u32(i));
}

//////// import: "minmax-avgmax.go"
const  MaxFloat32: f32 = 3.402823466e+38;
const  MinFloat32: f32 = 1.175494351e-38;
struct AvgMax32 {
	Avg: f32,
	Max: f32,
	Sum: f32,
	MaxIndex: i32,
	N: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}

//////// import: "minmax-minmax32.go"
struct F32 {
	Min: f32,
	Max: f32,
	pad: i32,
	pad1: i32, // for gpu use
}
fn F32_ClampValue(mr: F32, val: f32) -> f32 {
	if (val < mr.Min) {
		return mr.Min;
	}
	if (val > mr.Max) {
		return mr.Max;
	}return val;
}

//////// import: "network.go"
struct NetworkIndexes {
	MaxData: u32,
	MaxDelay: u32,
	NCaBins: i32,
	NLayers: u32,
	NNeurons: u32,
	NPools: u32,
	NPaths: u32,
	NSyns: u32,
	RubiconNPosUSs: u32,
	RubiconNCosts: u32,
	RubiconNNegUSs: u32,
	GPUMaxBuffFloats: u32,
	GPUSynCaBanks: u32,
	pad: u32,
	pad1: u32,
	pad2: u32,
}

//////// import: "neuromod.go"
alias DAModTypes = i32; //enums:enum
const  NoDAMod: DAModTypes = 0;
const  D1Mod: DAModTypes = 1;
const  D2Mod: DAModTypes = 2;
const  D1AbsMod: DAModTypes = 3;
alias ValenceTypes = i32; //enums:enum
const  Positive: ValenceTypes = 0;
const  Negative: ValenceTypes = 1;
const  Cost: ValenceTypes = 2;
struct NeuroModParams {
	DAMod: DAModTypes,
	Valence: ValenceTypes,
	DAModGain: f32,
	DALRateSign: i32,
	DALRateMod: f32,
	AChLRateMod: f32,
	AChDisInhib: f32,
	BurstGain: f32,
	DipGain: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
fn NeuroModParams_IsBLAExt(nm: NeuroModParams) -> bool {
	return (nm.Valence == Positive && nm.DAMod == D2Mod) ||
		(nm.Valence == Negative && nm.DAMod == D1Mod);
}
fn NeuroModParams_GGain(nm: NeuroModParams, da: f32) -> f32 {
	var ada = da;
	if (da > 0) {
		ada *= nm.BurstGain;
	} else {
		ada *= nm.DipGain;
	}
	var gain = f32(1);
	switch (nm.DAMod) {
	case NoDAMod: {
	}
	case D1Mod: {
		gain += nm.DAModGain * ada;
	}
	case D2Mod: {
		gain -= nm.DAModGain * ada;
	}
	case D1AbsMod: {
		gain += nm.DAModGain * abs(ada);
	}
	default: {
	}
	}
	if (gain < 0) {
		gain = f32(0);
	}return gain;
}
fn NeuroModParams_GiFromACh(nm: NeuroModParams, ach: f32) -> f32 {
	var ai = 1 - ach;
	if (ai < 0) {
		ai = f32(0);
	}return nm.AChDisInhib * ai;
}

//////// import: "neuron.go"
alias NeuronFlags = i32; //enums:enum
const  NeuronOff: NeuronFlags = 1;
const  NeuronHasExt: NeuronFlags = 2;
const  NeuronHasTarg: NeuronFlags = 4;
const  NeuronHasCmpr: NeuronFlags = 8;
alias NeuronVars = i32; //enums:enum
const  Spike: NeuronVars = 0;
const  Spiked: NeuronVars = 1;
const  Act: NeuronVars = 2;
const  ActInt: NeuronVars = 3;
const  Ge: NeuronVars = 4;
const  Gi: NeuronVars = 5;
const  Gk: NeuronVars = 6;
const  Inet: NeuronVars = 7;
const  Vm: NeuronVars = 8;
const  VmDend: NeuronVars = 9;
const  ISI: NeuronVars = 10;
const  ISIAvg: NeuronVars = 11;
const  Ext: NeuronVars = 12;
const  Target: NeuronVars = 13;
const  CaM: NeuronVars = 14;
const  CaP: NeuronVars = 15;
const  CaD: NeuronVars = 16;
const  CaDPrev: NeuronVars = 17;
const  CaSyn: NeuronVars = 18;
const  LearnCa: NeuronVars = 19;
const  LearnCaM: NeuronVars = 20;
const  LearnCaP: NeuronVars = 21;
const  LearnCaD: NeuronVars = 22;
const  CaDiff: NeuronVars = 23;
const  RLRate: NeuronVars = 24;
const  ETrace: NeuronVars = 25;
const  ETraceLearn: NeuronVars = 26;
const  GnmdaSyn: NeuronVars = 27;
const  Gnmda: NeuronVars = 28;
const  GnmdaLrn: NeuronVars = 29;
const  GnmdaMaint: NeuronVars = 30;
const  NmdaCa: NeuronVars = 31;
const  Gvgcc: NeuronVars = 32;
const  VgccM: NeuronVars = 33;
const  VgccH: NeuronVars = 34;
const  VgccCa: NeuronVars = 35;
const  VgccCaInt: NeuronVars = 36;
const  Burst: NeuronVars = 37;
const  BurstPrv: NeuronVars = 38;
const  CtxtGe: NeuronVars = 39;
const  CtxtGeRaw: NeuronVars = 40;
const  CtxtGeOrig: NeuronVars = 41;
const  GgabaB: NeuronVars = 42;
const  GababM: NeuronVars = 43;
const  GababX: NeuronVars = 44;
const  Gak: NeuronVars = 45;
const  SSGiDend: NeuronVars = 46;
const  GknaMed: NeuronVars = 47;
const  GknaSlow: NeuronVars = 48;
const  Gkir: NeuronVars = 49;
const  KirM: NeuronVars = 50;
const  Gsk: NeuronVars = 51;
const  SKCaIn: NeuronVars = 52;
const  SKCaR: NeuronVars = 53;
const  SKCaM: NeuronVars = 54;
const  Gmahp: NeuronVars = 55;
const  MahpN: NeuronVars = 56;
const  Gsahp: NeuronVars = 57;
const  SahpCa: NeuronVars = 58;
const  SahpN: NeuronVars = 59;
const  ActM: NeuronVars = 60;
const  ActP: NeuronVars = 61;
const  Beta1: NeuronVars = 62;
const  Beta2: NeuronVars = 63;
const  CaPMax: NeuronVars = 64;
const  CaPMaxCa: NeuronVars = 65;
const  GeNoise: NeuronVars = 66;
const  GeNoiseP: NeuronVars = 67;
const  GiNoise: NeuronVars = 68;
const  GiNoiseP: NeuronVars = 69;
const  GeExt: NeuronVars = 70;
const  GeRaw: NeuronVars = 71;
const  GeSyn: NeuronVars = 72;
const  GiRaw: NeuronVars = 73;
const  GiSyn: NeuronVars = 74;
const  GeInt: NeuronVars = 75;
const  GeIntNorm: NeuronVars = 76;
const  GiInt: NeuronVars = 77;
const  GModRaw: NeuronVars = 78;
const  GModSyn: NeuronVars = 79;
const  SMaintP: NeuronVars = 80;
const  GMaintRaw: NeuronVars = 81;
const  GMaintSyn: NeuronVars = 82;
const  NeurFlags: NeuronVars = 83;
const  CaBins: NeuronVars = 84;
alias NeuronAvgVars = i32; //enums:enum
const  ActAvg: NeuronAvgVars = 0;
const  AvgPct: NeuronAvgVars = 1;
const  TrgAvg: NeuronAvgVars = 2;
const  DTrgAvg: NeuronAvgVars = 3;
const  AvgDif: NeuronAvgVars = 4;
const  GeBase: NeuronAvgVars = 5;
const  GiBase: NeuronAvgVars = 6;
alias NeuronIndexVars = i32; //enums:enum
const  NrnNeurIndex: NeuronIndexVars = 0;
const  NrnLayIndex: NeuronIndexVars = 1;
const  NrnSubPool: NeuronIndexVars = 2;

//////// import: "pathparams.go"
const  StartOff: i32 = 0;
const  Nitems: i32 = 1;
const  StartNN: i32 = 2;
struct StartN {
	Start: u32,
	N: u32,
	pad: u32,
	pad1: u32, // todo: see if we can do without these?
}
struct PathIndexes {
	RecvLayer: u32,
	RecvNeurSt: u32,
	RecvNeurN: u32,
	SendLayer: u32,
	SendNeurSt: u32,
	SendNeurN: u32,
	SynapseSt: u32,
	SendConSt: u32,
	RecvConSt: u32,
	RecvSynSt: u32,
	NPathNeurSt: u32,
	pad: u32,
}
struct GScaleValues {
	Scale: f32,
	Rel: f32,
	pad: f32,
	pad1: f32,
}
struct PathParams {
	Type: PathTypes,
	Index: u32,
	pad: i32,
	pad1: i32,
	Indexes: PathIndexes,
	Com: SynComParams,
	PathScale: PathScaleParams,
	SWts: SWtParams,
	Learn: LearnSynParams,
	GScale: GScaleValues,
	RLPred: RLPredPathParams,
	Matrix: MatrixPathParams,
	BLA: BLAPathParams,
	Hip: HipPathParams,
}

//////// import: "pathtypes.go"
alias PathTypes = i32; //enums:enum
const  ForwardPath: PathTypes = 0;
const  BackPath: PathTypes = 1;
const  LateralPath: PathTypes = 2;
const  InhibPath: PathTypes = 3;
const  CTCtxtPath: PathTypes = 4;
const  RWPath: PathTypes = 5;
const  TDPredPath: PathTypes = 6;
const  BLAPath: PathTypes = 7;
const  HipPath: PathTypes = 8;
const  VSPatchPath: PathTypes = 9;
const  VSMatrixPath: PathTypes = 10;
const  DSMatrixPath: PathTypes = 11;

//////// import: "pcore-layer.go"
struct MatrixParams {
	GateThr: f32,
	IsVS: i32,
	OtherMatrixIndex: i32,
	ThalLay1Index: i32,
	ThalLay2Index: i32,
	ThalLay3Index: i32,
	ThalLay4Index: i32,
	ThalLay5Index: i32,
	ThalLay6Index: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}
alias GPLayerTypes = i32; //enums:enum
const  GPePr: GPLayerTypes = 0;
const  GPeAk: GPLayerTypes = 1;
const  GPi: GPLayerTypes = 2;
struct GPParams {
	GPType: GPLayerTypes,
	pad: u32,
	pad1: u32,
	pad2: u32,
}

//////// import: "pcore-path.go"
struct MatrixPathParams {
	Credit: f32,
	BasePF: f32,
	Delta: f32,
	VSRewLearn: i32,
}

//////// import: "pool.go"
alias PoolIndexVars = i32; //enums:enum
const  PoolNeurSt: PoolIndexVars = 0;
const  PoolNeurEd: PoolIndexVars = 1;
const  PoolLayerIdx: PoolIndexVars = 2;
const  PoolIsLayer: PoolIndexVars = 3;
alias PoolIntVars = i32; //enums:enum
const  Clamped: PoolIntVars = 0;
const  PoolGated: PoolIntVars = 1;
const  FFsRawInt: PoolIntVars = 2;
const  FBsRawInt: PoolIntVars = 3;
const  GeExtRawInt: PoolIntVars = 4;
const  PoolIntAvgMaxStart: PoolIntVars = 5;
alias AvgMax = i32; //enums:enum
const  Avg: AvgMax = 0;
const  Max: AvgMax = 1;
alias AvgMaxPhases = i32; //enums:enum -trim-prefix AM
const  AMCycle: AvgMaxPhases = 0;
const  AMMinus: AvgMaxPhases = 1;
const  AMPlus: AvgMaxPhases = 2;
const  AMPrev: AvgMaxPhases = 3;
alias AvgMaxVars = i32; //enums:enum -trim-prefix AM
const  AMCaP: AvgMaxVars = 0;
const  AMCaD: AvgMaxVars = 1;
const  AMCaPMax: AvgMaxVars = 2;
const  AMAct: AvgMaxVars = 3;
const  AMGeInt: AvgMaxVars = 4;
const  AMGiInt: AvgMaxVars = 5;
const  AMAvgDif: AvgMaxVars = 6;
const  poolFloatAvgMaxStart = InhibVarsN;
const  PoolVarsN = poolFloatAvgMaxStart + InhibVars(i32(AvgMaxVarsN)*i32(AvgMaxN)*i32(AvgMaxPhasesN));
const  PoolIntVarsTot = PoolIntAvgMaxStart + PoolIntVars(i32(AvgMaxVarsN)*i32(AvgMaxN));
const avgMaxToNeuron = array(CaP, CaD, CaPMax, Act, GeInt, GiInt);
fn AvgMaxVarIndex(vr: AvgMaxVars, phase: AvgMaxPhases, am: AvgMax) -> u32 {
	return u32(poolFloatAvgMaxStart) + u32(vr)*u32(AvgMaxN)*u32(AvgMaxPhasesN) + u32(phase)*u32(AvgMaxN) + u32(am);
}
fn PoolAvgMax(vr: AvgMaxVars, phase: AvgMaxPhases, am: AvgMax, pi: u32,di: u32) -> f32 {
	return Pools[Index3D(TensorStrides[130], TensorStrides[131], TensorStrides[132],
	u32(pi), u32(di), u32(AvgMaxVarIndex(vr, phase, am)))];
}
fn PoolNNeurons(pi: u32) -> i32 {
	return i32(PoolIxs[Index2D(TensorStrides[0], TensorStrides[1], u32(pi), u32(PoolNeurEd))] - PoolIxs[Index2D(TensorStrides[0], TensorStrides[1],
	u32(pi), u32(PoolNeurSt))]);
}

//////// import: "rand.go"
alias RandFunIndex = u32;
const  RandFunActPGe: RandFunIndex = 0;
const  RandFunActPGi: RandFunIndex = 1;
const  RandFunActSMaintP: RandFunIndex = 2;
const  RandFunIndexN: RandFunIndex = 3;
fn GetRandomNumber(index: u32, counter: su64, funIndex: RandFunIndex) -> f32 {
	return RandFloat32(counter, u32(funIndex), index);
}

//////// import: "rl-layer.go"
struct RWPredParams {
	PredRange: F32,
}
struct RWDaParams {
	TonicGe: f32,
	RWPredLayIndex: i32,
	pad: u32,
	pad1: u32,
}
fn RWDaParams_GeFromDA(rp: RWDaParams, da: f32) -> f32 {
	var ge = rp.TonicGe * (1.0 + da);
	if (ge < 0) {
		ge = f32(0);
	}return ge;
}
struct TDIntegParams {
	Discount: f32,
	PredGain: f32,
	TDPredLayIndex: i32,
	pad: u32,
}
struct TDDaParams {
	TonicGe: f32,
	TDIntegLayIndex: i32,
	pad: u32,
	pad1: u32,
}
fn TDDaParams_GeFromDA(tp: TDDaParams, da: f32) -> f32 {
	return tp.TonicGe * (1.0 + da);
}

//////// import: "rl-path.go"
struct RLPredPathParams {
	OppSignLRate: f32,
	DaTol: f32,
	pad: f32,
	pad1: f32,
}

//////// import: "rubicon-layer.go"
struct LDTParams {
	SrcThr: f32,
	Rew: i32,
	MaintInhib: f32,
	SrcLay1Index: i32,
	SrcLay2Index: i32,
	SrcLay3Index: i32,
	SrcLay4Index: i32,
	pad: f32,
}
struct VTAParams {
	CeMGain: f32,
	LHbGain: f32,
	AChThr: f32,
	pad: f32,
}

//////// import: "rubicon-path.go"
struct BLAPathParams {
	NegDeltaLRate: f32,
	AChThr: f32,
	USTrace: f32,
	pad: f32,
}

//////// import: "rubicon.go"
fn RubiconUSStimValue(di: u32, usIndex: u32, valence: ValenceTypes) -> f32 {
	let nix = NetworkIxs[0];
	var us = f32(0);
	switch (valence) {
	case Positive: {
		if (usIndex < nix.RubiconNPosUSs) {
			us = GlobalVectors[Index3D(TensorStrides[110], TensorStrides[111], TensorStrides[112], u32(GvUSpos), u32(usIndex), u32(di))];
		}
	}
	case Negative: {
		if (usIndex < nix.RubiconNNegUSs) {
			us = GlobalVectors[Index3D(TensorStrides[110], TensorStrides[111], TensorStrides[112], u32(GvUSneg), u32(usIndex), u32(di))];
		}
	}
	case Cost: {
		if (usIndex < nix.RubiconNCosts) {
			us = GlobalVectors[Index3D(TensorStrides[110], TensorStrides[111], TensorStrides[112], u32(GvCost), u32(usIndex), u32(di))];
		}
	}
	default: {
	}
	}return us;
}

//////// import: "stats.go"

//////// import: "synapse.go"
alias SynapseVars = i32; //enums:enum
const  Wt: SynapseVars = 0;
const  LWt: SynapseVars = 1;
const  SWt: SynapseVars = 2;
const  DWt: SynapseVars = 3;
const  DSWt: SynapseVars = 4;
alias SynapseTraceVars = i32; //enums:enum
const  Tr: SynapseTraceVars = 0;
const  DTr: SynapseTraceVars = 1;
const  DiDWt: SynapseTraceVars = 2;
alias SynapseIndexVars = i32; //enums:enum
const  SynRecvIndex: SynapseIndexVars = 0;
const  SynSendIndex: SynapseIndexVars = 1;
const  SynPathIndex: SynapseIndexVars = 2;

//////// import: "slrand.wgsl"
fn Philox2x32round(counter: su64, key: u32) -> su64 {
	let mul = Uint32Mul64(u32(0xD256D193), counter.x);
	var ctr: su64;
	ctr.x = mul.y ^ key ^ counter.y;
	ctr.y = mul.x;
	return ctr;
}
fn Philox2x32bumpkey(key: u32) -> u32 {
	return key + u32(0x9E3779B9);
}
fn Philox2x32(counter: su64, key: u32) -> vec2<u32> {
	var ctr = Philox2x32round(counter, key); // 1
	var ky = Philox2x32bumpkey(key);
	ctr = Philox2x32round(ctr, ky); // 2
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 3
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 4
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 5
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 6
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 7
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 8
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 9
	ky = Philox2x32bumpkey(ky);
	return Philox2x32round(ctr, ky); // 10
}
fn RandUint32Vec2(counter: su64, funcIndex: u32, key: u32) -> vec2<u32> {
	return Philox2x32(Uint64Add32(counter, funcIndex), key);
}
fn RandUint32(counter: su64, funcIndex: u32, key: u32) -> u32 {
	return Philox2x32(Uint64Add32(counter, funcIndex), key).x;
}
fn RandFloat32Vec2(counter: su64, funcIndex: u32, key: u32) -> vec2<f32> {
	return Uint32ToFloat32Vec2(RandUint32Vec2(counter, funcIndex, key));
}
fn RandFloat32(counter: su64, funcIndex: u32, key: u32) -> f32 { 
	return Uint32ToFloat32(RandUint32(counter, funcIndex, key));
}
fn RandFloat32Range11Vec2(counter: su64, funcIndex: u32, key: u32) -> vec2<f32> {
	return Uint32ToFloat32Vec2(RandUint32Vec2(counter, funcIndex, key));
}
fn RandFloat32Range11(counter: su64, funcIndex: u32, key: u32) -> f32 { 
	return Uint32ToFloat32Range11(RandUint32(counter, funcIndex, key));
}
fn RandBoolP(counter: su64, funcIndex: u32, key: u32, p: f32) -> bool { 
	return (RandFloat32(counter, funcIndex, key) < p);
}
fn sincospi(x: f32) -> vec2<f32> {
	let PIf = 3.1415926535897932;
	var r: vec2<f32>;
	r.x = cos(PIf*x);
	r.y = sin(PIf*x);
	return r;
}
fn RandFloat32NormVec2(counter: su64, funcIndex: u32, key: u32) -> vec2<f32> { 
	let ur = RandUint32Vec2(counter, funcIndex, key);
	var f = sincospi(Uint32ToFloat32Range11(ur.x));
	let r = sqrt(-2.0 * log(Uint32ToFloat32(ur.y))); // guaranteed to avoid 0.
	return f * r;
}
fn RandFloat32Norm(counter: su64, funcIndex: u32, key: u32) -> f32 { 
	return RandFloat32Vec2(counter, funcIndex, key).x;
}
fn RandUint32N(counter: su64, funcIndex: u32, key: u32, n: u32) -> u32 { 
	let v = RandFloat32(counter, funcIndex, key);
	return u32(v * f32(n));
}
struct RandCounter {
	Counter: su64,
	HiSeed: u32,
	pad: u32,
}
fn RandCounter_Reset(ct: ptr<function,RandCounter>) {
	(*ct).Counter.x = u32(0);
	(*ct).Counter.y = (*ct).HiSeed;
}
fn RandCounter_Seed(ct: ptr<function,RandCounter>, seed: u32) {
	(*ct).HiSeed = seed;
	RandCounter_Reset(ct);
}
fn RandCounter_Add(ct: ptr<function,RandCounter>, inc: u32) {
	(*ct).Counter = Uint64Add32((*ct).Counter, inc);
}

//////// import: "sltype.wgsl"
alias su64 = vec2<u32>;
fn Uint32Mul64(a: u32, b: u32) -> su64 {
	let LOMASK = (((u32(1))<<16)-1);
	var r: su64;
	r.x = a * b;               /* full low multiply */
	let ahi = a >> 16;
	let alo = a & LOMASK;
	let bhi = b >> 16;
	let blo = b & LOMASK;
	let ahbl = ahi * blo;
	let albh = alo * bhi;
	let ahbl_albh = ((ahbl&LOMASK) + (albh&LOMASK));
	var hit = ahi*bhi + (ahbl>>16) +  (albh>>16);
	hit += ahbl_albh >> 16; /* carry from the sum of lo(ahbl) + lo(albh) ) */
	/* carry from the sum with alo*blo */
	if ((r.x >> u32(16)) < (ahbl_albh&LOMASK)) {
		hit += u32(1);
	}
	r.y = hit; 
	return r;
}
/*
fn Uint32Mul64(a: u32, b: u32) -> su64 {
	return su64(a) * su64(b);
}
*/
fn Uint64Add32(a: su64, b: u32) -> su64 {
	if (b == 0) {
		return a;
	}
	var s = a;
	if (s.x > u32(0xffffffff) - b) {
		s.y++;
		s.x = (b - 1) - (u32(0xffffffff) - s.x);
	} else {
		s.x += b;
	}
	return s;
}
fn Uint64Incr(a: su64) -> su64 {
	var s = a;
	if(s.x == 0xffffffff) {
		s.y++;
		s.x = u32(0);
	} else {
		s.x++;
	}
	return s;
}
fn Uint32ToFloat32(val: u32) -> f32 {
	let factor = f32(1.0) / (f32(u32(0xffffffff)) + f32(1.0));
	let halffactor = f32(0.5) * factor;
	var f = f32(val) * factor + halffactor;
	if (f == 1.0) { // exclude 1
		return bitcast<f32>(0x3F7FFFFF);
	}
	return f;
}
fn Uint32ToFloat32Vec2(val: vec2<u32>) -> vec2<f32> {
	var r: vec2<f32>;
	r.x = Uint32ToFloat32(val.x);
	r.y = Uint32ToFloat32(val.y);
	return r;
}
fn Uint32ToFloat32Range11(val: u32) -> f32 {
	let factor = f32(1.0) / (f32(i32(0x7fffffff)) + f32(1.0));
	let halffactor = f32(0.5) * factor;
	return (f32(val) * factor + halffactor);
}
fn Uint32ToFloat32Range11Vec2(val: vec2<u32>) -> vec2<f32> {
	var r: vec2<f32>;
	r.x = Uint32ToFloat32Range11(val.x);
	r.y = Uint32ToFloat32Range11(val.y);
	return r;
}