// Code generated by "gosl"; DO NOT EDIT
// kernel: CycleNeuron

// // Layers are all the layer parameters. 
@group(0) @binding(0)
var<storage, read_write> Layers: array<LayerParams>;
@group(0) @binding(1)
var<storage, read_write> Paths: array<PathParams>;
// // NetworkIxs have indexes and sizes for entire network (one only). 
@group(1) @binding(0)
var<storage, read_write> NetworkIxs: array<NetworkIndexes>;
@group(1) @binding(1)
var<storage, read_write> NeuronIxs: array<u32>;
@group(1) @binding(2)
var<storage, read_write> SynapseIxs: array<u32>;
@group(1) @binding(3)
var<storage, read_write> PathSendCon: array<u32>;
@group(1) @binding(4)
var<storage, read_write> RecvPathIxs: array<u32>;
@group(1) @binding(5)
var<storage, read_write> PathRecvCon: array<u32>;
@group(1) @binding(6)
var<storage, read_write> RecvSynIxs: array<u32>;
// // Ctx is the current context state (one only). 
@group(2) @binding(0)
var<storage, read_write> Ctx: array<Context>;
@group(2) @binding(1)
var<storage, read_write> Neurons: array<f32>;
@group(2) @binding(2)
var<storage, read_write> NeuronAvgs: array<f32>;
@group(2) @binding(3)
var<storage, read_write> LayerStates: array<f32>;
@group(2) @binding(4)
var<storage, read_write> GlobalScalars: array<f32>;
@group(2) @binding(5)
var<storage, read_write> GlobalVectors: array<f32>;
@group(2) @binding(6)
var<storage, read_write> Exts: array<f32>;
// // Pools are the [PoolVars] float32 state values for layer and sub-pool inhibition, // Including the float32 AvgMax values by Phase and variable: use [AvgMaxVarIndex]. // [Layer * Pools][PoolVars+AvgMax][Data] 
@group(3) @binding(0)
var<storage, read_write> Pools: array<f32>;
@group(3) @binding(1)
var<storage, read_write> PoolsInt: array<i32>;
@group(3) @binding(2)
var<storage, read_write> PathGBuf: array<i32>;
@group(3) @binding(3)
var<storage, read_write> PathGSyns: array<f32>;
@group(3) @binding(4)
var<storage, read_write> Synapses: array<f32>;
@group(3) @binding(5)
var<storage, read_write> SynapseTraces: array<f32>;

alias GPUVars = i32;

@compute @workgroup_size(64, 1, 1)
fn main(@builtin(global_invocation_id) idx: vec3<u32>) {
	CycleNeuron(idx.x);
}

fn IndexU322D(s0: u32, s1: u32, i0: u32, i1: u32) -> u32 {
	return u32(2) + s0 * i0 + s1 * i1;
}

fn IndexU321D(s0: u32, i0: u32) -> u32 {
	return u32(1) + s0 * i0;
}

fn IndexF323D(s0: f32, s1: f32, s2: f32, i0: u32, i1: u32, i2: u32) -> u32 {
	return u32(3) + bitcast<u32>(s0) * i0 + bitcast<u32>(s1) * i1 + bitcast<u32>(s2) * i2;
}

fn IndexF322D(s0: f32, s1: f32, i0: u32, i1: u32) -> u32 {
	return u32(2) + bitcast<u32>(s0) * i0 + bitcast<u32>(s1) * i1;
}

fn IndexI323D(s0: i32, s1: i32, s2: i32, i0: u32, i1: u32, i2: u32) -> u32 {
	return u32(3) + u32(s0) * i0 + u32(s1) * i1 + u32(s2) * i2;
}


///////////// import: "vars.go"

///////////// import: "act-layer.go"
fn SetNeuronExtPosNeg(ctx: ptr<function,Context>, ni: u32,di: u32, val: f32) {
	if (ni == 0) {
		if (val >= 0) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] = val;
		} else {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] = f32(0);
		}
	} else {
		if (val >= 0) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] = f32(0);
		} else {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] = -val;
		}
	}
}
fn LayerParams_CycleNeuron(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var pi = LayerParams_PoolIndex(ly, NeuronIxs[IndexU322D(NeuronIxs[0], NeuronIxs[1], u32(ni),u32(NrnSubPool))]);
	var lpi = LayerParams_PoolIndex(ly, u32(u32(0)));
	LayerParams_GInteg(ly, ctx, pi, ni, di);
	LayerParams_SpikeFromG(ly, ctx, lpi, ni, di);
}
fn LayerParams_PulvinarDriver(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, lni: u32,di: u32, drvGe: ptr<function,f32>,nonDrivePct: ptr<function,f32>) {
	var dli = u32((*ly).Pulv.DriveLayIndex);
	var dly = Layers[dli];
	var dpi = LayerParams_PoolIndex(&dly, u32(u32(0)));
	var drvMax = PoolAvgMax(AMCaP, AMCycle, Max, dpi, di);
	*nonDrivePct = PulvParams_NonDrivePct(&(*ly).Pulv, drvMax); // how much non-driver to keep
	var burst = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(dly.Indexes.NeurSt + lni),u32(di),u32(Burst))];
	*drvGe = PulvParams_DriveGe(&(*ly).Pulv, burst);
}
fn LayerParams_GInteg(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, pi: u32,ni: u32,di: u32) {
	var drvGe = f32(0);
	var nonDrivePct = f32(0);
	if ((*ly).Type == PulvinarLayer) {
		LayerParams_PulvinarDriver(ly, ctx, ni-(*ly).Indexes.NeurSt, di, &drvGe, &nonDrivePct);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] = nonDrivePct; // use for regulating inhibition
	}
	var saveVal = LayerParams_SpecialPreGs(ly, ctx, pi, ni, di, drvGe, nonDrivePct);
	LayerParams_GFromRawSyn(ly, ctx, ni, di);
	LayerParams_GiInteg(ly, ctx, pi, ni, di);
	LayerParams_GNeuroMod(ly, ctx, ni, di);
	LayerParams_SpecialPostGs(ly, ctx, ni, di, saveVal);
}
fn LayerParams_SpecialPreGs(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, pi: u32,ni: u32,di: u32, drvGe: f32, nonDrivePct: f32) -> f32 {
	var saveVal = f32(0); // sometimes we need to use a value computed here, for the post Gs step
	var pil = pi - (*ly).PoolSt;
	var pnn = u32(PoolNNeurons(pi));
	var pni = NeuronIxs[IndexU322D(NeuronIxs[0], NeuronIxs[1], u32(ni),u32(NrnNeurIndex))] - u32(PoolsInt[IndexI323D(PoolsInt[0], PoolsInt[1], PoolsInt[2], u32(pi),u32(di),u32(PoolNeurSt))]);
	var nrnCtxtGe = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CtxtGe))];
	var nrnGeRaw = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))];
	var hasRew = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvHasRew),u32(di))] > 0;
	switch ((*ly).Type) {
	case PTPredLayer, CTLayer: {
		var geCtxt = (*ly).CT.GeGain * nrnCtxtGe;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] += geCtxt;
		if ((*ly).CT.DecayDt > 0) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CtxtGe))] -= (*ly).CT.DecayDt * nrnCtxtGe;
		}
		var ctxExt = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geCtxt);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] += ctxExt;
		saveVal = ctxExt;
	} // used In PostGs to set nrn.GeExt
	case PTMaintLayer: {
		if ((*ly).Acts.SMaint.On == 1) {
			saveVal = (*ly).Acts.SMaint.Inhib * Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[ // used In PostGs to set nrn.GeExt
			2], u32(ni),u32(di),u32(GMaintRaw))];
		}
	}
	case PulvinarLayer: {
		if ((*ctx).PlusPhase == 0) {
			break;
		}
		saveVal = nonDrivePct*Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] + DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, drvGe);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = nonDrivePct*nrnGeRaw + drvGe;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = saveVal;
	}
	case VSGatedLayer: {
		var dr = f32(0);
		if (pil == 0) {
			dr = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvVSMatrixJustGated),u32(di))];
		} else {
			dr = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvVSMatrixHasGated),u32(di))];
		}
		dr = abs(dr);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = dr;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, dr);
	}
	case BLALayer: {
		if (NeuroModParams_IsBLAExt(&(*ly).Learn.NeuroMod)) {
			var md = max(-GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[ // ext is modulated by negative da
			1], u32(GvDA),u32(di))], f32(0));
			var geCtxt = md * (*ly).CT.GeGain * Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CtxtGeOrig))];
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] += geCtxt;
			var ctxExt = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geCtxt);
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] += ctxExt;
			saveVal = ctxExt; // used In PostGs to set nrn.GeExt
		}
	}
	case LHbLayer: {
		var geRaw = f32(0);
		if (ni == 0) {
			geRaw = 0.2 * abs(GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvLHbDip),u32(di))]);
		} else {
			geRaw = 0.2 * abs(GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvLHbBurst),u32(di))]);
		}
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case DrivesLayer: {
		var dr = GlobalVectors[IndexF323D(GlobalVectors[0], GlobalVectors[1], GlobalVectors[2], u32(GvDrives),u32(pil - 1),u32(di))];
		var geRaw = dr;
		if (dr > 0) {
			geRaw = PopCodeParams_EncodeGe(&(*ly).Acts.PopCode, pni, pnn, dr);
		}
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case UrgencyLayer: {
		var ur = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvUrgency),u32(di))];
		var geRaw = ur;
		if (ur > 0) {
			geRaw = PopCodeParams_EncodeGe(&(*ly).Acts.PopCode, pni, pnn, ur);
		}
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case USLayer: {
		var us = RubiconUSStimValue(di, pil-1, (*ly).Learn.NeuroMod.Valence);
		var geRaw = us;
		if (us > 0) {
			geRaw = PopCodeParams_EncodeGe(&(*ly).Acts.PopCode, pni, pnn, us);
		}
		if ((*ly).Learn.NeuroMod.DAMod == D1Mod || ((*ly).Learn.NeuroMod.DAMod == D2Mod && hasRew && (*ctx).PlusPhase == 1)) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
		}
	}
	case PVLayer: {
		if (hasRew && (*ctx).PlusPhase == 1) {
			var pv = f32(0);
			if ((*ly).Learn.NeuroMod.Valence == Positive) {
				pv = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvPVpos),u32(di))];
			} else {
				pv = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvPVneg),u32(di))];
			}
			var pc = PopCodeParams_EncodeGe(&(*ly).Acts.PopCode, pni, (*ly).Indexes.NNeurons, pv);
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = pc;
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, pc);
		}
	}
	case LDTLayer: {
		var geRaw = 0.4 * GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvACh),u32(di))];
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case VTALayer: {
		var geRaw = RWDaParams_GeFromDA(&(*ly).RWDa, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvVtaDA),u32(di))]);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case RewLayer: {
		NeuronSetFlag(NeuronHasExt, ni, di);
		SetNeuronExtPosNeg(ctx, ni, di, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[ // Rew must be set in Context!
		1], u32(GvRew),u32(di))]);
	}
	case RWDaLayer: {
		var geRaw = RWDaParams_GeFromDA(&(*ly).RWDa, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvDA),u32(di))]);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case TDDaLayer: {
		var geRaw = TDDaParams_GeFromDA(&(*ly).TDDa, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvDA),u32(di))]);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] = geRaw;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] = DtParams_GeSynFromRawSteady(&(*ly).Acts.Dt, geRaw);
	}
	case TDIntegLayer: {
		NeuronSetFlag(NeuronHasExt, ni, di);
		SetNeuronExtPosNeg(ctx, ni, di, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvRewPred),u32(di))]);
	}
	default: {
	}
	}return saveVal;
}
fn LayerParams_SpecialPostGs(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, ni: u32,di: u32, saveVal: f32) {
	switch ((*ly).Type) {
	case PulvinarLayer, PTMaintLayer, CTLayer, BLALayer: {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeExt))] = saveVal;
	}
	case PTPredLayer: {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeExt))] = saveVal;
		var orig = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CtxtGeOrig))];
		if (orig < 0.05) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] = 0.0;
		}
	}
	default: {
	}
	}
}
fn LayerParams_GFromRawSyn(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var extraRaw = f32(0);
	var extraSyn = f32(0);
	var nrnGModRaw = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GModRaw))];
	var nrnGModSyn = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GModSyn))];
	var ach = GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvACh),u32(di))];
	switch ((*ly).Type) {
	case PTMaintLayer: {
		var md = (*ly).Acts.Dend.ModGain * nrnGModSyn;
		if ((*ly).Acts.Dend.ModACh == 1) {
			md *= ach;
		}
		md += (*ly).Acts.Dend.ModBase;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] *= md;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] *= md;
		extraRaw = (*ly).Acts.Dend.ModGain * nrnGModRaw;
		if ((*ly).Acts.Dend.ModACh == 1) {
			extraRaw *= ach;
		}
		extraSyn = md;
	}
	case BLALayer: {
		var md = max(-GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[ // ext is modulated by negative da
		1], u32(GvDA),u32(di))], 0.0);
		extraRaw = md * nrnGModRaw * (*ly).Acts.Dend.ModGain;
		extraSyn = md * nrnGModSyn * (*ly).Acts.Dend.ModGain;
	}
	default: {
		if ((*ly).Acts.Dend.HasMod == 1) {
			var md = (*ly).Acts.Dend.ModBase + (*ly).Acts.Dend.ModGain*nrnGModSyn;
			if (md > 1) {
				md = f32(1);
			}
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))] *= md;
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))] *= md;
		}
	}
	}
	var geRaw = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeRaw))];
	var geSyn = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeSyn))];
	ActParams_NMDAFromRaw(&(*ly).Acts, ctx, ni, di, geRaw+extraRaw);
	ActParams_MaintNMDAFromRaw(&(*ly).Acts, ctx, ni, di); // uses GMaintRaw directly
	LearnNeurParams_LrnNMDAFromRaw(&(*ly).Learn, ctx, ni, di, geRaw);
	ActParams_GvgccFromVm(&(*ly).Acts, ctx, ni, di);
	var ege = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gnmda))] + Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaMaint))] + Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gvgcc))] + extraSyn;
	ActParams_GeFromSyn(&(*ly).Acts, ctx, ni, di, geSyn, ege); // sets nrn.GeExt too
	ActParams_GkFromVm(&(*ly).Acts, ctx, ni, di);
	ActParams_GSkCaFromCa(&(*ly).Acts, ctx, ni, di);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiSyn))] = ActParams_GiFromSyn(&(*ly).Acts, ctx, ni, di, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiSyn))]);
}
fn LayerParams_GiInteg(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, pi: u32,ni: u32,di: u32) {
	var giMult = LayerStates[IndexF323D(LayerStates[0], LayerStates[1], LayerStates[2], u32((*ly).Index),u32(di),u32(LayerGiMult))];
	var gi = giMult*Pools[IndexF323D(Pools[0], Pools[1], Pools[2], u32(pi),u32(di),u32(TotalGi))] + Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiSyn))] + Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiNoise))] + NeuroModParams_GiFromACh(&(*ly).Learn.NeuroMod, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvACh),u32(di))]);
	var ssgi = Pools[IndexF323D(Pools[0], Pools[1], Pools[2], u32(pi),u32(di),u32(SSGi))];
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gi))] = gi;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SSGiDend))] = 0.0;
	if ((*ctx).PlusPhase == 1 && (*ly).Type == PulvinarLayer) {
		var ext = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[ // nonDrivePct
		2], u32(ni),u32(di),u32(Ext))];
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SSGiDend))] = ext * (*ly).Acts.Dend.SSGi * ssgi;
	} else {
		if (!((*ly).Acts.Clamp.IsInput == 1 || (*ly).Acts.Clamp.IsTarget == 1)) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SSGiDend))] = (*ly).Acts.Dend.SSGi * ssgi;
		}
	}
	var vm = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))];
	var nrnGABAB = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GABAB))];
	var nrnGABABx = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GABABx))];
	GABABParams_GABAB(&(*ly).Acts.GabaB, gi, &nrnGABAB, &nrnGABABx);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GABAB))] = nrnGABAB;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GABABx))] = nrnGABABx;
	var nrnGgabaB = GABABParams_GgabaB(&(*ly).Acts.GabaB, nrnGABAB, vm);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GgabaB))] = nrnGgabaB;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gk))] += nrnGgabaB;
}
fn LayerParams_GNeuroMod(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var ggain = NeuroModParams_GGain(&(*ly).Learn.NeuroMod, GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvDA),u32(di))] + GlobalScalars[IndexF322D(GlobalScalars[0], GlobalScalars[1], u32(GvDAtonic),u32(di))]);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] *= ggain;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gi))] *= ggain;
}
fn LayerParams_SpikeFromG(ly: ptr<function,LayerParams>, ctx: ptr<function,Context>, lpi: u32,ni: u32,di: u32) {
	ActParams_VmFromG(&(*ly).Acts, ctx, ni, di);
	ActParams_SpikeFromVm(&(*ly).Acts, ctx, ni, di);
	LearnNeurParams_CaFromSpike(&(*ly).Learn, ctx, ni, di);
	var lmax = PoolAvgMax(AMGeInt, AMCycle, Max, lpi, di);
	if (lmax > 0) {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeIntNorm))] = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeInt))] / lmax;
	} else {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeIntNorm))] = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeInt))];
	}
	if ((*ctx).Cycle >= (*ly).Acts.Dt.MaxCycStart) {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SpkMaxCa))] += (*ly).Learn.CaSpk.Dt.PDt * (Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaM))] - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SpkMaxCa))]);
		var spkmax = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SpkMaxCa))];
		if (spkmax > Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SpkMax))]) {
			Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SpkMax))] = spkmax;
		}
	}
	var spk = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))];
	if (spk > 0) {
		var spksper = (*ctx).ThetaCycles / 8;
		var bin = min((*ctx).Cycle/spksper, 7);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SpkBin0 + NeuronVars(bin)))] += spk;
	}
}

///////////// import: "act-net.go"
fn CycleNeuron(i: u32) { //gosl:kernel
	var ctx = Ctx[0];
	var di = Context_DataIndex(&ctx, i);
	var ni = Context_ItemIndex(&ctx, i);
	var li = NeuronIxs[IndexU322D(NeuronIxs[0], NeuronIxs[1], u32(ni),u32(NrnLayIndex))];
	var layers=Layers[li]; LayerParams_CycleNeuron(&layers, &ctx, ni, di);
	Ctx[0] = ctx;
}

///////////// import: "act-path.go"
alias PathGTypes = i32; //enums:enum
const  ExcitatoryG: PathGTypes = 0;
const  InhibitoryG: PathGTypes = 1;
const  ModulatoryG: PathGTypes = 2;
const  MaintG: PathGTypes = 3;
const  ContextG: PathGTypes = 4;
struct SynComParams {
	GType: PathGTypes,
	Delay: u32,
	MaxDelay: u32,
	DelLen: u32,
}
struct PathScaleParams {
	Rel: f32,
	Abs: f32,
	pad: f32,
	pad1: f32,
}

///////////// import: "act.go"
fn NeuronHasFlag(flag: NeuronFlags, ni: u32,di: u32) -> bool {
	return (NeuronFlags(bitcast<u32>(Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(NeurFlags))])) & flag) > 0; // weird: != 0 does NOT work on GPU
}
fn NeuronSetFlag(flag: NeuronFlags, ni: u32,di: u32) {
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(NeurFlags))] = bitcast<f32>(bitcast<u32>(Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(NeurFlags))]) | u32(flag));
}
struct SpikeParams {
	Thr: f32,
	VmR: f32,
	Tr: i32,
	RTau: f32,
	Exp: i32,
	ExpSlope: f32,
	ExpThr: f32,
	MaxHz: f32,
	ISITau: f32,
	ISIDt: f32,
	RDt: f32,
	pad: i32,
}
fn SpikeParams_ActFromISI(sk: ptr<function,SpikeParams>, isi: f32,timeInc: f32,integ: f32) -> f32 {
	if (isi <= 0) {
		return f32(0);
	}
			var maxInt = 1.0 / (timeInc * integ * (*sk).MaxHz); // interval at max hz..
return maxInt / isi; // normalized
}
fn SpikeParams_AvgFromISI(sk: ptr<function,SpikeParams>, avg: f32, isi: f32) -> f32 {
	var av = avg;
	if (av <= 0) {
		av = isi;
	} else if (isi < 0.8*av) {
		av = isi; // if significantly less than we take that
	} else { // integrate on slower
		av += (*sk).ISIDt * (isi - av); // running avg updt
	}return av;
}
struct DendParams {
	GbarExp: f32,
	GbarR: f32,
	SSGi: f32,
	HasMod: i32,
	ModGain: f32,
	ModACh: i32,
	ModBase: f32,
	pad: i32,
}
struct ActInitParams {
	Vm: f32,
	Act: f32,
	GeBase: f32,
	GiBase: f32,
	GeVar: f32,
	GiVar: f32,
	pad: i32,
	pad1: i32,
}
struct DecayParams {
	Act: f32,
	Glong: f32,
	AHP: f32,
	LearnCa: f32,
	OnRew: i32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
struct DtParams {
	Integ: f32,
	VmTau: f32,
	VmDendTau: f32,
	VmSteps: i32,
	GeTau: f32,
	GiTau: f32,
	IntTau: f32,
	LongAvgTau: f32,
	MaxCycStart: i32,
	VmDt: f32,
	VmDendDt: f32,
	DtStep: f32,
	GeDt: f32,
	GiDt: f32,
	IntDt: f32,
	LongAvgDt: f32,
}
fn DtParams_GeSynFromRaw(dp: ptr<function,DtParams>, geSyn: f32,geRaw: f32) -> f32 {
	return geSyn + geRaw - (*dp).GeDt*geSyn;
}
fn DtParams_GeSynFromRawSteady(dp: ptr<function,DtParams>, geRaw: f32) -> f32 {
	return geRaw * (*dp).GeTau;
}
fn DtParams_GiSynFromRaw(dp: ptr<function,DtParams>, giSyn: f32,giRaw: f32) -> f32 {
	return giSyn + giRaw - (*dp).GiDt*giSyn;
}
struct SpikeNoiseParams {
	On: i32,
	GeHz: f32,
	Ge: f32,
	GiHz: f32,
	Gi: f32,
	MaintGe: i32,
	GeExpInt: f32,
	GiExpInt: f32,
}
fn SpikeNoiseParams_PGe(an: ptr<function,SpikeNoiseParams>, ctx: ptr<function,Context>, p: ptr<function,f32>, ni: u32,di: u32) -> f32 {
	var nix = NetworkIxs[0];
	var ndi = di*nix.NNeurons + ni;
	*p *= GetRandomNumber(ndi, (*ctx).RandCounter.Counter, RandFunActPGe);
	if (*p <= (*an).GeExpInt) {
		*p = f32(1);return (*an).Ge;
	}return f32(
0);
}
fn SpikeNoiseParams_PGi(an: ptr<function,SpikeNoiseParams>, ctx: ptr<function,Context>, p: ptr<function,f32>, ni: u32,di: u32) -> f32 {
	var nix = NetworkIxs[0];
	var ndi = di*nix.NNeurons + ni;
	*p *= GetRandomNumber(ndi, (*ctx).RandCounter.Counter, RandFunActPGi);
	if (*p <= (*an).GiExpInt) {
		*p = f32(1);return (*an).Gi;
	}return f32(
0);
}
struct ClampParams {
	IsInput: i32,
	IsTarget: i32,
	Ge: f32,
	Add: i32,
	ErrThr: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
struct SMaintParams {
	On: i32,
	NNeurons: f32,
	Gbar: f32,
	Inhib: f32,
	ISI: F32,
}
fn SMaintParams_ExpInt(sm: ptr<function,SMaintParams>, isi: f32) -> f32 {
	if (isi <= 0) {
		return f32(0);
	}return FastExp(-max(isi, (*sm).ISI.Min) / (*sm).NNeurons);
}
struct PopCodeParams {
	On: i32,
	Ge: f32,
	Min: f32,
	Max: f32,
	MinAct: f32,
	MinSigma: f32,
	MaxSigma: f32,
	Clip: i32,
}
fn PopCodeParams_ClipValue(pc: ptr<function,PopCodeParams>, val: f32) -> f32 {
	var clipVal = val;
	if (clipVal < (*pc).Min) {
		clipVal = (*pc).Min;
	}
	if (clipVal > (*pc).Max) {
		clipVal = (*pc).Max;
	}return clipVal;
}
fn PopCodeParams_ProjectParam(pc: ptr<function,PopCodeParams>, minParam: f32,maxParam: f32,clipVal: f32) -> f32 {
	var normVal = (clipVal - (*pc).Min) / ((*pc).Max - (*pc).Min);return minParam + normVal*(maxParam-minParam);
}
fn PopCodeParams_EncodeValue(pc: ptr<function,PopCodeParams>, i: u32,n: u32, val: f32) -> f32 {
	var eval = val;
	var clipVal = PopCodeParams_ClipValue(pc, eval);
	if ((*pc).Clip == 1) {
		eval = clipVal;
	}
	var rng = (*pc).Max - (*pc).Min;
	var act = f32(1);
	if ((*pc).MinAct < 1) {
		act = PopCodeParams_ProjectParam(pc, (*pc).MinAct, f32(1.0), clipVal);
	}
	var sig = (*pc).MinSigma;
	if ((*pc).MaxSigma > (*pc).MinSigma) {
		sig = PopCodeParams_ProjectParam(pc, (*pc).MinSigma, (*pc).MaxSigma, clipVal);
	}
	var gnrm = 1.0 / (rng * sig);
	var incr = rng / f32(n-1);
	var trg = (*pc).Min + incr*f32(i);
	var dist = gnrm * (trg - eval);return act * FastExp(-(dist * dist));
}
fn PopCodeParams_EncodeGe(pc: ptr<function,PopCodeParams>, i: u32,n: u32, val: f32) -> f32 {
	return (*pc).Ge * PopCodeParams_EncodeValue(pc, i, n, val);
}
struct ActParams {
	Spikes: SpikeParams,
	Dend: DendParams,
	Init: ActInitParams,
	Decay: DecayParams,
	Dt: DtParams,
	Gbar: Chans,
	Erev: Chans,
	Clamp: ClampParams,
	Noise: SpikeNoiseParams,
	VmRange: F32,
	Mahp: MahpParams,
	Sahp: SahpParams,
	KNa: KNaMedSlow,
	Kir: KirParams,
	NMDA: NMDAParams,
	MaintNMDA: NMDAParams,
	GabaB: GABABParams,
	VGCC: VGCCParams,
	AK: AKsParams,
	SKCa: SKCaParams,
	SMaint: SMaintParams,
	PopCode: PopCodeParams,
}
fn ActParams_NMDAFromRaw(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32, geTot: f32) {
	if ((*ac).NMDA.Gbar == 0) {
		return;
	}
	var geT = max(geTot, 0.0);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaSyn))] = NMDAParams_NMDASyn(&(*ac).NMDA, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaSyn))], geT);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gnmda))] = NMDAParams_Gnmda(&(*ac).NMDA, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaSyn))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))]);
}
fn ActParams_MaintNMDAFromRaw(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	if ((*ac).MaintNMDA.Gbar == 0) {
		return;
	}
	if ((*ac).SMaint.On == 1) {
		ActParams_SMaintFromISI(ac, ctx, ni, di);
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GMaintSyn))] = NMDAParams_NMDASyn(&(*ac).MaintNMDA, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GMaintSyn))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GMaintRaw))]);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaMaint))] = NMDAParams_Gnmda(&(*ac).MaintNMDA, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GMaintSyn))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))]);
}
fn ActParams_SMaintFromISI(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var nix = NetworkIxs[0];
	var isi = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(ISIAvg))];
	if (isi < (*ac).SMaint.ISI.Min || isi > (*ac).SMaint.ISI.Max) {
		return;
	}
	var ndi = di*nix.NNeurons + ni;
	var smp = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SMaintP))];
	smp *= GetRandomNumber(ndi, (*ctx).RandCounter.Counter, RandFunActSMaintP);
	var trg = SMaintParams_ExpInt(&(*ac).SMaint, isi);
	if (smp <= trg) {
		smp = f32(1);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GMaintRaw))] += (*ac).SMaint.Gbar;
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SMaintP))] = smp;
}
fn ActParams_GvgccFromVm(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	if ((*ac).VGCC.Gbar == 0) {
		return;
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gvgcc))] = VGCCParams_Gvgcc(&(*ac).VGCC, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccM))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccH))]);
	var dm: f32;
	var dh: f32;
	VGCCParams_DMHFromV(&(*ac).VGCC, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccM))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccH))], &dm, &dh);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccM))] += dm;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2],
	u32(ni),u32(di),u32(VgccH))] += dh;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCa))] = VGCCParams_CaFromG(&(*ac).VGCC, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gvgcc))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCa))]);
}
fn ActParams_GkFromVm(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var vm = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))];
	var vmd = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))];
	var mahpN = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(MahpN))];
	var gmahp = MahpParams_GmAHP(&(*ac).Mahp, vm, &mahpN);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gmahp))] = gmahp;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(MahpN))] = mahpN;
	var gsahp = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gsahp))];
	var gak = AKsParams_Gak(&(*ac).AK, vmd);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gak))] = gak;
	var nkirM = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(KirM))];
	var gkir = KirParams_Gkir(&(*ac).Kir, vm, nkirM);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gkir))] = gkir;
	nkirM += KirParams_DM(&(*ac).Kir, VToBio(vm), nkirM);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(KirM))] = nkirM;
	var gktot = gmahp + gsahp + gak + gkir;
	if ((*ac).KNa.On == 1) {
		var gknaMed = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GknaMed))];
		var gknaSlow = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GknaSlow))];
		KNaMedSlow_GcFromSpike(&(*ac).KNa, &gknaMed, &gknaSlow, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))] > .5);
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GknaMed))] = gknaMed;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GknaSlow))] = gknaSlow;
		gktot += gknaMed + gknaSlow;
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2],
	u32(ni),u32(di),u32(Gk))] = gktot;
}
fn ActParams_GSkCaFromCa(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	if ((*ac).SKCa.Gbar == 0) {
		return;
	}
	var skcar = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaR))];
	var skcain = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaIn))];
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaM))] = SKCaParams_MFromCa(&(*ac).SKCa, skcar, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaM))]);
	SKCaParams_CaInRFromSpike(&(*ac).SKCa, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))], Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaD))], &skcain, &skcar);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaR))] = skcar;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaIn))] = skcain;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gsk))] = (*ac).SKCa.Gbar * Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SKCaM))];
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gk))] += Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gsk))];
}
fn ActParams_GeFromSyn(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32, geSyn: f32,geExt: f32) {
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeExt))] = 0.0;
	var geS = geSyn;
	var geE = geExt;
	if ((*ac).Clamp.Add == 1 && NeuronHasFlag(NeuronHasExt, ni, di)) {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeExt))] = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] * (*ac).Clamp.Ge;
		geS += Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeExt))];
	}
	if ((*ac).Clamp.Add == 0 && NeuronHasFlag(NeuronHasExt, ni, di)) {
		geS = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ext))] * (*ac).Clamp.Ge;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeExt))] = geS;
		geE = f32(0); // no extra in this case
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] = geS + geE;
	if (Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] < 0.0) {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] = 0.0;
	}
	ActParams_AddGeNoise(ac, ctx, ni, di);
}
fn ActParams_AddGeNoise(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	if ((*ac).Noise.On == 0 || (*ac).Noise.Ge == 0) {
		return;
	}
	var p = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeNoiseP))];
	var ge = SpikeNoiseParams_PGe(&(*ac).Noise, ctx, &p, ni, di);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeNoiseP))] = p;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeNoise))] = DtParams_GeSynFromRaw(&(*ac).Dt, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeNoise))], ge);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] += Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GeNoise))];
}
fn ActParams_AddGiNoise(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	if ((*ac).Noise.On == 0 || (*ac).Noise.Gi == 0) {
		return;
	}
	var p = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiNoiseP))];
	var gi = SpikeNoiseParams_PGi(&(*ac).Noise, ctx, &p, ni, di);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiNoiseP))] = p;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiNoise))] = DtParams_GiSynFromRaw(&(*ac).Dt, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GiNoise))], gi);
}
fn ActParams_GiFromSyn(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32, giSyn: f32) -> f32 {
	ActParams_AddGiNoise(ac, ctx, ni, di);
	if (giSyn < 0) { // negative inhib G doesn't make any sense
		return f32(0);
	}return giSyn;
}
fn ActParams_InetFromG(ac: ptr<function,ActParams>, vm: f32,ge: f32,gl: f32,gi: f32,gk: f32) -> f32 {
	var inet = ge*((*ac).Erev.E-vm) + gl*(*ac).Gbar.L*((*ac).Erev.L-vm) + gi*((*ac).Erev.I-vm) + gk*((*ac).Erev.K-vm);
	if (inet > (*ac).Dt.VmTau) {
		inet = (*ac).Dt.VmTau;
	} else if (inet < -(*ac).Dt.VmTau) {
		inet = -(*ac).Dt.VmTau;
	}return inet;
}
fn ActParams_VmFromInet(ac: ptr<function,ActParams>, vm: f32,dt: f32,inet: f32) -> f32 {
	return F32_ClipValue(&(*ac).VmRange, vm + dt*inet);
}
fn ActParams_VmInteg(ac: ptr<function,ActParams>, vm: f32,dt: f32,ge: f32,gl: f32,gi: f32,gk: f32, nvm: ptr<function,f32>,inet: ptr<function,f32>) {
	var dtEff = dt * (*ac).Dt.DtStep;
	*nvm = vm;
	for (var i = i32(0); i < (*ac).Dt.VmSteps; i++) {
		*inet = ActParams_InetFromG(ac, *nvm, ge, gl, gi, gk);
		*nvm = ActParams_VmFromInet(ac, *nvm, dtEff, *inet);
	}
}
fn ActParams_VmFromG(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var updtVm = true;
	var isi = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(ISI))];
	if ((*ac).Spikes.Tr > 0 && isi >= 0 && isi < f32((*ac).Spikes.Tr)) {
		updtVm = false; // don't update the spiking vm during refract
	}
	var ge = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Ge))] * (*ac).Gbar.E;
	var gi = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gi))] * (*ac).Gbar.I;
	var gk = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Gk))] * (*ac).Gbar.K;
	var nvm: f32;
	var inet: f32;
	var expi: f32;
	if (updtVm) {
		ActParams_VmInteg(ac, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))], (*ac).Dt.VmDt, ge, f32(f32(1)), gi, gk, &nvm, &inet);
		if (updtVm && (*ac).Spikes.Exp == 1) { // add spike current if relevant
			var exVm: f32;
			exVm = 0.5 * (nvm + Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[ // midpoint for this
			2], u32(ni),u32(di),u32(Vm))]);
			expi = (*ac).Gbar.L * (*ac).Spikes.ExpSlope *
				FastExp((exVm-(*ac).Spikes.Thr)/(*ac).Spikes.ExpSlope);
			if (expi > (*ac).Dt.VmTau) {
				expi = (*ac).Dt.VmTau;
			}
			inet += expi;
			nvm = ActParams_VmFromInet(ac, nvm, (*ac).Dt.VmDt, expi);
		}
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))] = nvm;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Inet))] = inet;
	} else { // decay back to VmR
		var dvm: f32;
		if (i32(isi) == (*ac).Spikes.Tr-1) {
			dvm = (*ac).Spikes.VmR - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))];
		} else {
			dvm = (*ac).Spikes.RDt * ((*ac).Spikes.VmR - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))]);
		}
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))] += dvm;
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Inet))] = dvm * (*ac).Dt.VmTau;
	}
	var glEff = f32(1);
	if (!updtVm) {
		glEff += (*ac).Dend.GbarR;
	}
	var giEff: f32;
	giEff = gi + (*ac).Gbar.I*Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(SSGiDend))];
	ActParams_VmInteg(ac, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))], (*ac).Dt.VmDendDt, ge, glEff, giEff, gk, &nvm, &inet);
	if (updtVm) {
		nvm = ActParams_VmFromInet(ac, nvm, (*ac).Dt.VmDendDt, (*ac).Dend.GbarExp*expi);
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2],
	u32(ni),u32(di),u32(VmDend))] = nvm;
}
fn ActParams_SpikeFromVmVars(ac: ptr<function,ActParams>, nrnISI: ptr<function,f32>,nrnISIAvg: ptr<function,f32>,nrnSpike: ptr<function,f32>,nrnSpiked: ptr<function,f32>,nrnAct: ptr<function,f32>, nrnVm: f32) {
	var thr: f32;
	if ((*ac).Spikes.Exp == 1) {
		thr = (*ac).Spikes.ExpThr;
	} else {
		thr = (*ac).Spikes.Thr;
	}
	if (nrnVm >= thr) {
		*nrnSpike = f32(1);
		if (*nrnISIAvg == -1) {
			*nrnISIAvg = f32(-2);
		} else if (*nrnISI > 0) { // must have spiked to update
			*nrnISIAvg = SpikeParams_AvgFromISI(&(*ac).Spikes, *nrnISIAvg, *nrnISI+1);
		}
		*nrnISI = f32(0);
	} else {
		*nrnSpike = f32(0);
		if (*nrnISI >= 0) {
			*nrnISI += f32(1);
			if (*nrnISI < 10) {
				*nrnSpiked = f32(1);
			} else {
				*nrnSpiked = f32(0);
			}
			if (*nrnISI > 200) { // keep from growing infinitely large
				*nrnISI = f32(-1);
			}
		} else {
			*nrnSpiked = f32(0);
		}
		if (*nrnISIAvg >= 0 && *nrnISI > 0 && *nrnISI > 1.2**nrnISIAvg) {
			*nrnISIAvg = SpikeParams_AvgFromISI(&(*ac).Spikes, *nrnISIAvg, *nrnISI);
		}
	}
	var nwAct = SpikeParams_ActFromISI(&(*ac).Spikes, *nrnISIAvg, f32(.001), (*ac).Dt.Integ);
	if (nwAct > 1) {
		nwAct = f32(1);
	}
	nwAct = *nrnAct + (*ac).Dt.VmDt*(nwAct-*nrnAct);
	*nrnAct = nwAct;
}
fn ActParams_SpikeFromVm(ac: ptr<function,ActParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var nrnISI = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(ISI))];
	var nrnISIAvg = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(ISIAvg))];
	var nrnSpike = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))];
	var nrnSpiked = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spiked))];
	var nrnAct = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Act))];
	var nrnVm = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Vm))];
	ActParams_SpikeFromVmVars(ac, &nrnISI, &nrnISIAvg, &nrnSpike, &nrnSpiked, &nrnAct, nrnVm);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(ISI))] = nrnISI;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(ISIAvg))] = nrnISIAvg;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))] = nrnSpike;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spiked))] = nrnSpiked;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Act))] = nrnAct;
}

///////////// import: "chans-ak.go"
struct AKsParams {
	Gbar: f32,
	Hf: f32,
	Mf: f32,
	Voff: f32,
	Vmax: f32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}
fn AKsParams_MFromV(ap: ptr<function,AKsParams>, vbio: f32) -> f32 {
	var av = vbio;
	if (vbio > (*ap).Vmax) {
		av = (*ap).Vmax;
	}return (*ap).Hf / (1.0 + FastExp(-(*ap).Mf*(av+(*ap).Voff)));
}
fn AKsParams_MFromVnorm(ap: ptr<function,AKsParams>, v: f32) -> f32 {
	return AKsParams_MFromV(ap, VToBio(v));
}
fn AKsParams_Gak(ap: ptr<function,AKsParams>, v: f32) -> f32 {
	return (*ap).Gbar * AKsParams_MFromVnorm(ap, v);
}

///////////// import: "chans-chans.go"
struct Chans {
	E: f32,
	L: f32,
	I: f32,
	K: f32,
}
fn VToBio(vm: f32) -> f32 {
	return vm*100 - 100;
}

///////////// import: "chans-gabab.go"
struct GABABParams {
	Gbar: f32,
	RiseTau: f32,
	DecayTau: f32,
	Gbase: f32,
	GiSpike: f32,
	MaxTime: f32,
	TauFact: f32,
	RiseDt: f32,
	DecayDt: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
fn GABABParams_GFromV(gp: ptr<function,GABABParams>, v: f32) -> f32 {
	var vbio = VToBio(v);
	if (vbio < -90) {
		vbio = f32(-90);
	}return (vbio + 90.0) / (1.0 + FastExp(0.1*((vbio+90.0)+10.0)));
}
fn GABABParams_GFromS(gp: ptr<function,GABABParams>, s: f32) -> f32 {
	var ss = s * (*gp).GiSpike;
	if (ss > 20) {
		return f32(1);
	}return 1.0 / (1.0 + FastExp(-(ss-7.1)/1.4));
}
fn GABABParams_BiExp(gp: ptr<function,GABABParams>, g: f32,x: f32, dG: ptr<function,f32>,dX: ptr<function,f32>) {
	*dG = ((*gp).TauFact*x - g) * (*gp).RiseDt;
	*dX = -x * (*gp).DecayDt;return;
}
fn GABABParams_GABAB(gp: ptr<function,GABABParams>, gi: f32, gabaB: ptr<function,f32>,gabaBx: ptr<function,f32>) {
	var dG: f32;
	var dX: f32;
	GABABParams_BiExp(gp, *gabaB, *gabaBx, &dG, &dX);
	*gabaBx += GABABParams_GFromS(gp, gi) + dX; // gets new input
	*gabaB += dG;return;
}
fn GABABParams_GgabaB(gp: ptr<function,GABABParams>, gabaB: f32,vm: f32) -> f32 {
	return (*gp).Gbar * GABABParams_GFromV(gp, vm) * (gabaB + (*gp).Gbase);
}

///////////// import: "chans-kir.go"
struct KirParams {
	Gbar: f32,
	MinfOff: f32,
	MinfTau: f32,
	RiseOff: f32,
	RiseTau: f32,
	DecayOff: f32,
	DecayTau: f32,
	Mrest: f32,
}
fn KirParams_Minf(kp: ptr<function,KirParams>, vbio: f32) -> f32 {
	return 1.0 / (1.0 + FastExp((vbio-((*kp).MinfOff))/(*kp).MinfTau));
}
fn KirParams_DM(kp: ptr<function,KirParams>, vbio: f32,m: f32) -> f32 {
	var minf = KirParams_Minf(kp, vbio);
	var mtau = f32(4.0);
	var dm = (minf - m) / (mtau * 3); // 3 = Q10
return dm;
}
fn KirParams_Gkir(kp: ptr<function,KirParams>, v: f32, m: f32) -> f32 {
	return (*kp).Gbar * m;
}

///////////// import: "chans-kna.go"
struct KNaParams {
	On: i32,
	Rise: f32,
	Max: f32,
	Tau: f32,
	Dt: f32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}
fn KNaParams_GcFromSpike(ka: ptr<function,KNaParams>, gKNa: ptr<function,f32>, spike: bool) {
	if ((*ka).On == 1) {
		if (spike) {
			*gKNa += (*ka).Rise * ((*ka).Max - *gKNa);
		} else {
			*gKNa -= (*ka).Dt * *gKNa;
		}
	} else {
		*gKNa = f32(0);
	}
}
struct KNaMedSlow {
	On: i32,
	TrialSlow: i32,
	pad: i32,
	pad1: i32,
	Med: KNaParams,
	Slow: KNaParams,
}
fn KNaMedSlow_GcFromSpike(ka: ptr<function,KNaMedSlow>, gKNaM: ptr<function,f32>,gKNaS: ptr<function,f32>, spike: bool) {
	KNaParams_GcFromSpike(&(*ka).Med, gKNaM, spike);
	if ((*ka).TrialSlow == 0) {
		KNaParams_GcFromSpike(&(*ka).Slow, gKNaS, spike);
	}
}

///////////// import: "chans-mahp.go"
struct MahpParams {
	Gbar: f32,
	Voff: f32,
	Vslope: f32,
	TauMax: f32,
	Tadj: f32,
	DtMax: f32,
	pad: i32,
	pad2: i32,
}
fn MahpParams_EFun(mp: ptr<function,MahpParams>, z: f32) -> f32 {
	if (abs(z) < 1.0e-4) {
		return 1.0 - 0.5*z;
	}return z / (FastExp(z) - 1.0);
}
fn MahpParams_NinfTauFromV(mp: ptr<function,MahpParams>, vbio: f32, ninf: ptr<function,f32>,tau: ptr<function,f32>) {
	var vo = vbio - (*mp).Voff;
	var a = (*mp).DtMax * (*mp).Vslope * MahpParams_EFun(mp, -vo/(*mp).Vslope);
	var b = (*mp).DtMax * (*mp).Vslope * MahpParams_EFun(mp, vo/(*mp).Vslope);
	*tau = 1.0 / (a + b);
	*ninf = a * *tau;   // a / (a+b)
	*tau /= (*mp).Tadj; // correct right away..
return;
}
fn MahpParams_NinfTauFromVnorm(mp: ptr<function,MahpParams>, v: f32, ninf: ptr<function,f32>,tau: ptr<function,f32>) {
	MahpParams_NinfTauFromV(mp, VToBio(v), ninf, tau);
}
fn MahpParams_DNFromV(mp: ptr<function,MahpParams>, v: f32,n: f32) -> f32 {
	var ninf: f32;
	var tau: f32;
	MahpParams_NinfTauFromVnorm(mp, v, &ninf, &tau);
	var dn = (ninf - n) / tau;return dn;
}
fn MahpParams_GmAHP(mp: ptr<function,MahpParams>, v: f32, n: ptr<function,f32>) -> f32 {
	var dn = MahpParams_DNFromV(mp, v, *n);
	*n += dn;
	var g = (*mp).Tadj * (*mp).Gbar * *n;return g;
}

///////////// import: "chans-nmda.go"
struct NMDAParams {
	Gbar: f32,
	Tau: f32,
	ITau: f32,
	MgC: f32,
	Voff: f32,
	Dt: f32,
	IDt: f32,
	MgFact: f32,
}
fn NMDAParams_MgGFromVbio(np: ptr<function,NMDAParams>, vbio: f32) -> f32 {
	var av = vbio + (*np).Voff;
	if (av >= 0) {
		return f32(0);
	}return -av / (1.0 + (*np).MgFact*FastExp(-0.062*av));
}
fn NMDAParams_MgGFromV(np: ptr<function,NMDAParams>, v: f32) -> f32 {
	return NMDAParams_MgGFromVbio(np, VToBio(v));
}
fn NMDAParams_CaFromVbio(np: ptr<function,NMDAParams>, vbio: f32) -> f32 {
	var av = vbio + (*np).Voff;
	if (av > -0.5 && av < 0.5) { // this eliminates div 0 at 0, and numerical "fuzz" around 0
		return 1.0 / (0.0756 * (1 + 0.0378*av));
	}return -av / (1.0 - FastExp(0.0756*av));
}
fn NMDAParams_CaFromV(np: ptr<function,NMDAParams>, v: f32) -> f32 {
	return NMDAParams_CaFromVbio(np, VToBio(v));
}
fn NMDAParams_NMDASyn(np: ptr<function,NMDAParams>, nmda: f32,raw: f32) -> f32 {
	return nmda + raw - (*np).Dt*nmda;
}
fn NMDAParams_Gnmda(np: ptr<function,NMDAParams>, nmda: f32,vm: f32) -> f32 {
	return (*np).Gbar * NMDAParams_MgGFromV(np, vm) * nmda;
}

///////////// import: "chans-sahp.go"
struct SahpParams {
	Gbar: f32,
	CaTau: f32,
	Off: f32,
	Slope: f32,
	TauMax: f32,
	CaDt: f32,
	DtMax: f32,
	pad: i32,
}

///////////// import: "chans-skca.go"
struct SKCaParams {
	Gbar: f32,
	C50: f32,
	ActTau: f32,
	DeTau: f32,
	KCaR: f32,
	CaRDecayTau: f32,
	CaInThr: f32,
	CaInTau: f32,
	ActDt: f32,
	DeDt: f32,
	CaRDecayDt: f32,
	CaInDt: f32,
}
fn SKCaParams_MAsympHill(sp: ptr<function,SKCaParams>, cai: f32) -> f32 {
	var caia = cai / (*sp).C50;
	var capow = caia * caia * caia * caia;return capow / (1 + capow);
}
fn SKCaParams_CaInRFromSpike(sp: ptr<function,SKCaParams>, spike: f32,caD: f32, caIn: ptr<function,f32>,caR: ptr<function,f32>) {
	*caR -= *caR * (*sp).CaRDecayDt;
	if (spike > 0) {
		var x = *caIn * (*sp).KCaR;
		*caR += x;
		*caIn -= x;
	}
	if (caD < (*sp).CaInThr) {
		*caIn += (*sp).CaInDt * (1.0 - *caIn);
	}
}
fn SKCaParams_MFromCa(sp: ptr<function,SKCaParams>, caR: f32,mcur: f32) -> f32 {
	var mas = SKCaParams_MAsympHill(sp, caR);
	if (mas > mcur) {
		return mcur + (*sp).ActDt*(mas-mcur);
	}return mcur + (*sp).DeDt*(mas-mcur);
}

///////////// import: "chans-vgcc.go"
struct VGCCParams {
	Gbar: f32,
	Ca: f32,
	pad: i32,
	pad1: i32,
}
fn VGCCParams_GFromV(np: ptr<function,VGCCParams>, v: f32) -> f32 {
	var vbio = VToBio(v);
	if (vbio > -0.5 && vbio < 0.5) { // this avoids divide by 0, and numerical instability around 0
		return 1.0 / (0.0756 * (1 + 0.0378*vbio));
	}return -vbio / (1.0 - FastExp(0.0756*vbio));
}
fn VGCCParams_MFromV(np: ptr<function,VGCCParams>, vbio: f32) -> f32 {
	if (vbio < -60) {
		return f32(0);
	}
	if (vbio > -10) {
		return f32(1);
	}return 1.0 / (1.0 + FastExp(-(vbio + 37)));
}
fn VGCCParams_HFromV(np: ptr<function,VGCCParams>, vbio: f32) -> f32 {
	if (vbio < -50) {
		return f32(1);
	}
	if (vbio > -10) {
		return f32(0);
	}return 1.0 / (1.0 + FastExp((vbio+41)*2));
}
fn VGCCParams_DMHFromV(np: ptr<function,VGCCParams>, v: f32,m: f32,h: f32, dm: ptr<function,f32>,dh: ptr<function,f32>) {
	var vbio = VToBio(v);
	if (vbio > 0) {
		vbio = f32(0);
	}
	*dm = (VGCCParams_MFromV(np, vbio) - m) / 3.6;
	*dh = (VGCCParams_HFromV(np, vbio) - h) / 29.0;
}
fn VGCCParams_Gvgcc(np: ptr<function,VGCCParams>, vm: f32,m: f32,h: f32) -> f32 {
	return (*np).Gbar * VGCCParams_GFromV(np, vm) * m * m * m * h;
}
fn VGCCParams_CaFromG(np: ptr<function,VGCCParams>, v: f32,g: f32,ca: f32) -> f32 {
	var vbio = VToBio(v);return -vbio * (*np).Ca * g;
}

///////////// import: "context.go"
struct Context {
	NData: u32,
	Mode: i32,
	Testing: i32,
	Phase: i32,
	PlusPhase: i32,
	PhaseCycle: i32,
	Cycle: i32,
	ThetaCycles: i32,
	CyclesTotal: i32,
	Time: f32,
	TrialsTotal: i32,
	TimePerCycle: f32,
	SlowInterval: i32,
	SlowCounter: i32,
	pad: i32,
	pad1: i32,
	RandCounter: RandCounter,
}
fn Context_ItemIndex(ctx: ptr<function,Context>, idx: u32) -> u32 {
	return idx / (*ctx).NData;
}
fn Context_DataIndex(ctx: ptr<function,Context>, idx: u32) -> u32 {
	return idx % (*ctx).NData;
}

///////////// import: "deep-layer.go"
struct BurstParams {
	ThrRel: f32,
	ThrAbs: f32,
	pad: f32,
	pad1: f32,
}
struct CTParams {
	GeGain: f32,
	DecayTau: f32,
	OFCposPT: i32,
	DecayDt: f32,
}
struct PulvParams {
	DriveScale: f32,
	FullDriveAct: f32,
	DriveLayIndex: i32,
	pad: f32,
}
fn PulvParams_DriveGe(tp: ptr<function,PulvParams>, act: f32) -> f32 {
	return (*tp).DriveScale * act;
}
fn PulvParams_NonDrivePct(tp: ptr<function,PulvParams>, drvMax: f32) -> f32 {
	return 1.0 - min(1.0, drvMax/(*tp).FullDriveAct);
}

///////////// import: "deep-path.go"

///////////// import: "enumgen.go"
const PathGTypesN: PathGTypes = 5;
const GlobalScalarVarsN: GlobalScalarVars = 57;
const GlobalVectorVarsN: GlobalVectorVars = 10;
const GPUVarsN: GPUVars = 22;
const LayerTypesN: LayerTypes = 30;
const LayerVarsN: LayerVars = 11;
const ViewTimesN: ViewTimes = 7;
const DAModTypesN: DAModTypes = 4;
const ValenceTypesN: ValenceTypes = 3;
const NeuronFlagsN: NeuronFlags = 9;
const NeuronVarsN: NeuronVars = 89;
const NeuronAvgVarsN: NeuronAvgVars = 7;
const NeuronIndexVarsN: NeuronIndexVars = 3;
const PathTypesN: PathTypes = 12;
const GPLayerTypesN: GPLayerTypes = 3;
const PoolIntVarsN: PoolIntVars = 10;
const AvgMaxN: AvgMax = 2;
const AvgMaxPhasesN: AvgMaxPhases = 4;
const AvgMaxVarsN: AvgMaxVars = 7;
const SynapseVarsN: SynapseVars = 5;
const SynapseTraceVarsN: SynapseTraceVars = 3;
const SynapseIndexVarsN: SynapseIndexVars = 3;

///////////// import: "fsfffb-enumgen.go"
const InhibVarsN: InhibVars = 16;

///////////// import: "fsfffb-fsfffb.go"
struct GiParams {
	On: i32,
	Gi: f32,
	FB: f32,
	FSTau: f32,
	SS: f32,
	SSfTau: f32,
	SSiTau: f32,
	FS0: f32,
	FFAvgTau: f32,
	FFPrv: f32,
	ClampExtMin: f32,
	FSDt: f32,
	SSfDt: f32,
	SSiDt: f32,
	FFAvgDt: f32,
	pad: f32,
}

///////////// import: "fsfffb-inhib.go"
alias InhibVars = i32; //enums:enum
const  FFsRaw: InhibVars = 0;
const  FBsRaw: InhibVars = 1;
const  GeExtRaw: InhibVars = 2;
const  FFs: InhibVars = 3;
const  FBs: InhibVars = 4;
const  GeExts: InhibVars = 5;
const  FSi: InhibVars = 6;
const  SSi: InhibVars = 7;
const  SSf: InhibVars = 8;
const  FSGi: InhibVars = 9;
const  SSGi: InhibVars = 10;
const  TotalGi: InhibVars = 11;
const  GiOrig: InhibVars = 12;
const  LayGi: InhibVars = 13;
const  FFAvg: InhibVars = 14;
const  FFAvgPrv: InhibVars = 15;

///////////// import: "globals.go"
alias GlobalScalarVars = i32; //enums:enum
const  GvRew: GlobalScalarVars = 0;
const  GvHasRew: GlobalScalarVars = 1;
const  GvRewPred: GlobalScalarVars = 2;
const  GvPrevPred: GlobalScalarVars = 3;
const  GvHadRew: GlobalScalarVars = 4;
const  GvDA: GlobalScalarVars = 5;
const  GvDAtonic: GlobalScalarVars = 6;
const  GvACh: GlobalScalarVars = 7;
const  GvNE: GlobalScalarVars = 8;
const  GvSer: GlobalScalarVars = 9;
const  GvAChRaw: GlobalScalarVars = 10;
const  GvGoalMaint: GlobalScalarVars = 11;
const  GvVSMatrixJustGated: GlobalScalarVars = 12;
const  GvVSMatrixHasGated: GlobalScalarVars = 13;
const  GvCuriosityPoolGated: GlobalScalarVars = 14;
const  GvTime: GlobalScalarVars = 15;
const  GvEffort: GlobalScalarVars = 16;
const  GvUrgencyRaw: GlobalScalarVars = 17;
const  GvUrgency: GlobalScalarVars = 18;
const  GvHasPosUS: GlobalScalarVars = 19;
const  GvHadPosUS: GlobalScalarVars = 20;
const  GvNegUSOutcome: GlobalScalarVars = 21;
const  GvHadNegUSOutcome: GlobalScalarVars = 22;
const  GvPVposSum: GlobalScalarVars = 23;
const  GvPVpos: GlobalScalarVars = 24;
const  GvPVnegSum: GlobalScalarVars = 25;
const  GvPVneg: GlobalScalarVars = 26;
const  GvPVposEst: GlobalScalarVars = 27;
const  GvPVposVar: GlobalScalarVars = 28;
const  GvPVnegEst: GlobalScalarVars = 29;
const  GvPVnegVar: GlobalScalarVars = 30;
const  GvGoalDistEst: GlobalScalarVars = 31;
const  GvGoalDistPrev: GlobalScalarVars = 32;
const  GvProgressRate: GlobalScalarVars = 33;
const  GvGiveUpUtility: GlobalScalarVars = 34;
const  GvContUtility: GlobalScalarVars = 35;
const  GvGiveUpTiming: GlobalScalarVars = 36;
const  GvContTiming: GlobalScalarVars = 37;
const  GvGiveUpProgress: GlobalScalarVars = 38;
const  GvContProgress: GlobalScalarVars = 39;
const  GvGiveUpSum: GlobalScalarVars = 40;
const  GvContSum: GlobalScalarVars = 41;
const  GvGiveUpProb: GlobalScalarVars = 42;
const  GvGiveUp: GlobalScalarVars = 43;
const  GvGaveUp: GlobalScalarVars = 44;
const  GvVSPatchPos: GlobalScalarVars = 45;
const  GvVSPatchPosThr: GlobalScalarVars = 46;
const  GvVSPatchPosRPE: GlobalScalarVars = 47;
const  GvVSPatchPosSum: GlobalScalarVars = 48;
const  GvVSPatchPosPrev: GlobalScalarVars = 49;
const  GvVSPatchPosVar: GlobalScalarVars = 50;
const  GvLHbDip: GlobalScalarVars = 51;
const  GvLHbBurst: GlobalScalarVars = 52;
const  GvLHbPVDA: GlobalScalarVars = 53;
const  GvCeMpos: GlobalScalarVars = 54;
const  GvCeMneg: GlobalScalarVars = 55;
const  GvVtaDA: GlobalScalarVars = 56;
const MaxGlobalVecN = 16;
alias GlobalVectorVars = i32; //enums:enum
const  GvCost: GlobalVectorVars = 0;
const  GvCostRaw: GlobalVectorVars = 1;
const  GvUSneg: GlobalVectorVars = 2;
const  GvUSnegRaw: GlobalVectorVars = 3;
const  GvDrives: GlobalVectorVars = 4;
const  GvUSpos: GlobalVectorVars = 5;
const  GvVSPatchD1: GlobalVectorVars = 6;
const  GvVSPatchD2: GlobalVectorVars = 7;
const  GvOFCposPTMaint: GlobalVectorVars = 8;
const  GvVSMatrixPoolGated: GlobalVectorVars = 9;

///////////// import: "hip_paths.go"
struct HipPathParams {
	Hebb: f32,
	Err: f32,
	SAvgCor: f32,
	SAvgThr: f32,
	SNominal: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}

///////////// import: "inhib.go"
struct ActAvgParams {
	Nominal: f32,
	AdaptGi: i32,
	Offset: f32,
	HiTol: f32,
	LoTol: f32,
	AdaptRate: f32,
	pad: f32,
	pad1: f32,
}
struct InhibParams {
	ActAvg: ActAvgParams,
	Layer: GiParams,
	Pool: GiParams,
}

///////////// import: "init-layer.go"

///////////// import: "kinase-params.go"
struct CaDtParams { //types:add
	MTau: f32,
	PTau: f32,
	DTau: f32,
	MDt: f32,
	PDt: f32,
	DDt: f32,
	pad: i32,
	pad1: i32,
}
fn CaDtParams_FromCa(kp: ptr<function,CaDtParams>, ca: f32, caM: ptr<function,f32>,caP: ptr<function,f32>,caD: ptr<function,f32>) {
	*caM += (*kp).MDt * (ca - *caM);
	*caP += (*kp).PDt * (*caM - *caP);
	*caD += (*kp).DDt * (*caP - *caD);
}
struct NeurCaParams {
	SpikeG: f32,
	SynTau: f32,
	SynDt: f32,
	pad: i32,
	Dt: CaDtParams,
}
fn NeurCaParams_CaFromSpike(np: ptr<function,NeurCaParams>, spike: f32, caSyn: ptr<function,f32>,caM: ptr<function,f32>,caP: ptr<function,f32>,caD: ptr<function,f32>) {
	var nsp = (*np).SpikeG * spike;
	*caSyn += (*np).SynDt * (nsp - *caSyn);
	CaDtParams_FromCa(&(*np).Dt, nsp, caM, caP, caD);
}
struct SynCaParams { //types:add
	CaScale: f32,
	pad: i32,
	pad1: i32,
	pad2: i32,
	Dt: CaDtParams,
}
struct BinWeights { //types:add
	Bin0: f32,
	Bin1: f32,
	Bin2: f32,
	Bin3: f32,
	Bin4: f32,
	Bin5: f32,
	Bin6: f32,
	Bin7: f32,
}
struct SynCaLinear { //types:add
	CaP: BinWeights,
	CaD: BinWeights,
	CaGain: f32,
	pad:    f32,
	pad1: f32,
	pad2: f32,
}

///////////// import: "layerparams.go"
struct LayerIndexes {
	NPools: u32,
	NeurSt: u32,
	NNeurons: u32,
	RecvSt: u32,
	RecvN: u32,
	SendSt: u32,
	SendN: u32,
	ExtsSt: u32,
	ShpPlY: i32,
	ShpPlX: i32,
	ShpUnY: i32,
	ShpUnX: i32,
}
struct LayerInhibIndexes {
	Index1: i32,
	Index2: i32,
	Index3: i32,
	Index4: i32,
}
struct LayerParams {
	Type: LayerTypes,
	Index: u32,
	MaxData: u32,
	PoolSt: u32,
	Acts: ActParams,
	Inhib: InhibParams,
	LayInhib: LayerInhibIndexes,
	Learn: LearnNeurParams,
	Bursts: BurstParams,
	CT: CTParams,
	Pulv: PulvParams,
	Matrix: MatrixParams,
	GP: GPParams,
	LDT: LDTParams,
	VTA: VTAParams,
	RWPred: RWPredParams,
	RWDa: RWDaParams,
	TDInteg: TDIntegParams,
	TDDa: TDDaParams,
	Indexes: LayerIndexes,
}
fn LayerParams_PoolIndex(ly: ptr<function,LayerParams>, pi: u32) -> u32 {
	return (*ly).PoolSt + pi;
}

///////////// import: "layertypes.go"
alias LayerTypes = i32; //enums:enum
const  SuperLayer: LayerTypes = 0;
const  InputLayer: LayerTypes = 1;
const  TargetLayer: LayerTypes = 2;
const  CompareLayer: LayerTypes = 3;
const  CTLayer: LayerTypes = 4;
const  PulvinarLayer: LayerTypes = 5;
const  TRNLayer: LayerTypes = 6;
const  PTMaintLayer: LayerTypes = 7;
const  PTPredLayer: LayerTypes = 8;
const  MatrixLayer: LayerTypes = 9;
const  STNLayer: LayerTypes = 10;
const  GPLayer: LayerTypes = 11;
const  BGThalLayer: LayerTypes = 12;
const  VSGatedLayer: LayerTypes = 13;
const  BLALayer: LayerTypes = 14;
const  CeMLayer: LayerTypes = 15;
const  VSPatchLayer: LayerTypes = 16;
const  LHbLayer: LayerTypes = 17;
const  DrivesLayer: LayerTypes = 18;
const  UrgencyLayer: LayerTypes = 19;
const  USLayer: LayerTypes = 20;
const  PVLayer: LayerTypes = 21;
const  LDTLayer: LayerTypes = 22;
const  VTALayer: LayerTypes = 23;
const  RewLayer: LayerTypes = 24;
const  RWPredLayer: LayerTypes = 25;
const  RWDaLayer: LayerTypes = 26;
const  TDPredLayer: LayerTypes = 27;
const  TDIntegLayer: LayerTypes = 28;
const  TDDaLayer: LayerTypes = 29;

///////////// import: "layervars.go"
alias LayerVars = i32; //enums:enum
const  LayerActMAvg: LayerVars = 0;
const  LayerActPAvg: LayerVars = 1;
const  LayerAvgMaxGeM: LayerVars = 2;
const  LayerAvgMaxGiM: LayerVars = 3;
const  LayerGiMult: LayerVars = 4;
const  LayerPhaseDiff: LayerVars = 5;
const  LayerPhaseDiffAvg: LayerVars = 6;
const  LayerPhaseDiffVar: LayerVars = 7;
const  LayerRT: LayerVars = 8;
const  LayerRewPredPos: LayerVars = 9;
const  LayerRewPredNeg: LayerVars = 10;

///////////// import: "learn-layer.go"

///////////// import: "learn-net.go"

///////////// import: "learn-path.go"

///////////// import: "learn.go"
struct LearnCaParams {
	Norm: f32,
	SpkVGCC: i32,
	SpkVgccCa: f32,
	VgccTau: f32,
	Dt: CaDtParams,
	UpdateThr: f32,
	VgccDt: f32,
	NormInv: f32,
	pad: i32,
}
fn LearnCaParams_VgccCaFromSpike(np: ptr<function,LearnCaParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	if ((*np).SpkVGCC == 1) {
		Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCa))] = (*np).SpkVgccCa * Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))];
	}
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCaInt))] += Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCa))] - (*np).VgccDt*Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCaInt))];
}
fn LearnCaParams_LearnCas(np: ptr<function,LearnCaParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	LearnCaParams_VgccCaFromSpike(np, ctx, ni, di);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCa))] = (*np).NormInv * (Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(NmdaCa))] + Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VgccCaInt))]);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaM))] += (*np).Dt.MDt * (Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCa))] - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaM))]);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaP))] += (*np).Dt.PDt * (Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaM))] - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaP))]);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaD))] += (*np).Dt.DDt * (Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaP))] - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaD))]);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaDiff))] = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaP))] - Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(LearnCaD))];
}
struct TrgAvgActParams {
	GiBaseInit: f32,
	RescaleOn: i32,
	ErrLRate: f32,
	SynScaleRate: f32,
	SubMean: f32,
	Permute: i32,
	Pool: i32,
	pad: i32,
	TrgRange: F32,
}
struct RLRateParams {
	On: i32,
	SigmoidLinear: i32,
	SigmoidMin: f32,
	Diff: i32,
	SpkThr: f32,
	DiffThr: f32,
	Min: f32,
	pad: i32,
}
struct LearnNeurParams {
	CaLearn: LearnCaParams,
	CaSpk: NeurCaParams,
	LrnNMDA: NMDAParams,
	TrgAvgAct: TrgAvgActParams,
	RLRate: RLRateParams,
	NeuroMod: NeuroModParams,
}
fn LearnNeurParams_LrnNMDAFromRaw(ln: ptr<function,LearnNeurParams>, ctx: ptr<function,Context>, ni: u32,di: u32, geTot: f32) {
	var geEff = max(geTot, 0.0);
	var vmd = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(VmDend))];
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaLrn))] = NMDAParams_NMDASyn(&(*ln).LrnNMDA, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaLrn))], geEff);
	var gnmda = NMDAParams_Gnmda(&(*ln).LrnNMDA, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(GnmdaLrn))], vmd);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(NmdaCa))] = f32(gnmda * NMDAParams_CaFromV(&(*ln).LrnNMDA, vmd));
}
fn LearnNeurParams_CaFromSpike(ln: ptr<function,LearnNeurParams>, ctx: ptr<function,Context>, ni: u32,di: u32) {
	var caSyn: f32;
	var caSpkM = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaM))];
	var caSpkP = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaP))];
	var caSpkD = Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaD))];
	NeurCaParams_CaFromSpike(&(*ln).CaSpk, Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(Spike))], &caSyn, &caSpkM, &caSpkP, &caSpkD);
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaM))] = caSpkM;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaP))] = caSpkP;
	Neurons[IndexF323D(Neurons[0], Neurons[1], Neurons[2], u32(ni),u32(di),u32(CaD))] = caSpkD;
	LearnCaParams_LearnCas(&(*ln).CaLearn, ctx, ni, di);
}
struct SWtInitParams {
	SPct: f32,
	Mean: f32,
	Var: f32,
	Sym: i32,
}
struct SWtAdaptParams {
	On: i32,
	LRate: f32,
	SubMean: f32,
	SigGain: f32,
}
struct SWtParams {
	Init: SWtInitParams,
	Adapt: SWtAdaptParams,
	Limit: F32,
}
struct LRateParams {
	Base: f32,
	Sched: f32,
	Mod: f32,
	Eff: f32,
}
struct TraceParams {
	Tau: f32,
	SubMean: f32,
	LearnThr: f32,
	Dt: f32,
}
struct LRateMod {
	On: i32,
	Base: f32,
	pad: i32,
	pad1: i32,
	Range: F32,
}
struct HebbParams {
	On: i32,
	Up: f32,
	Down: f32,
	pad: f32,
}
struct LearnSynParams {
	Learn: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
	LRate: LRateParams,
	Trace: TraceParams,
	KinaseCa: SynCaLinear,
	Hebb: HebbParams,
}

///////////// import: "looper.go"
alias ViewTimes = i32; //enums:enum
const  Cycle: ViewTimes = 0;
const  FastSpike: ViewTimes = 1;
const  Gamma: ViewTimes = 2;
const  Beta: ViewTimes = 3;
const  Alpha: ViewTimes = 4;
const  Phase: ViewTimes = 5;
const  Theta: ViewTimes = 6;

///////////// import: "math32-fastexp.go"
fn FastExp(x: f32) -> f32 {
	if (x <= -88.02969) { // this doesn't add anything and -exp is main use-case anyway
		return f32(0.0);
	}
	var i = i32(12102203*x) + i32(127)*(i32(1)<<23);
	var m = i >> 7 & 0xFFFF; // copy mantissa
	i += (((((((((((3537 * m) >> 16) + 13668) * m) >> 18) + 15817) * m) >> 14) - 80470) * m) >> 11);return bitcast<f32>(u32(i));
}

///////////// import: "minmax-avgmax.go"
const  MaxFloat32: f32 = 3.402823466e+38;
const  MinFloat32: f32 = 1.175494351e-38;
struct AvgMax32 {
	Avg: f32,
	Max: f32,
	Sum: f32,
	MaxIndex: i32,
	N: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}

///////////// import: "minmax-minmax32.go"
struct F32 {
	Min: f32,
	Max: f32,
	pad: i32,
	pad1: i32, // for gpu use
}
fn F32_ClipValue(mr: ptr<function,F32>, val: f32) -> f32 {
	if (val < (*mr).Min) {
		return (*mr).Min;
	}
	if (val > (*mr).Max) {
		return (*mr).Max;
	}return val;
}

///////////// import: "network.go"
struct NetworkIndexes {
	MaxData: u32,
	MaxDelay: u32,
	NLayers: u32,
	NNeurons: u32,
	NPools: u32,
	NPaths: u32,
	NSyns: u32,
	RubiconNPosUSs: u32,
	RubiconNCosts: u32,
	RubiconNNegUSs: u32,
	GPUMaxBuffFloats: u32,
	GPUSynCaBanks: u32,
}

///////////// import: "neuromod.go"
alias DAModTypes = i32; //enums:enum
const  NoDAMod: DAModTypes = 0;
const  D1Mod: DAModTypes = 1;
const  D2Mod: DAModTypes = 2;
const  D1AbsMod: DAModTypes = 3;
alias ValenceTypes = i32; //enums:enum
const  Positive: ValenceTypes = 0;
const  Negative: ValenceTypes = 1;
const  Cost: ValenceTypes = 2;
struct NeuroModParams {
	DAMod: DAModTypes,
	Valence: ValenceTypes,
	DAModGain: f32,
	DALRateSign: i32,
	DALRateMod: f32,
	AChLRateMod: f32,
	AChDisInhib: f32,
	BurstGain: f32,
	DipGain: f32,
	pad: f32,
	pad1: f32,
	pad2: f32,
}
fn NeuroModParams_IsBLAExt(nm: ptr<function,NeuroModParams>) -> bool {
	return ((*nm).Valence == Positive && (*nm).DAMod == D2Mod) ||
		((*nm).Valence == Negative && (*nm).DAMod == D1Mod);
}
fn NeuroModParams_GGain(nm: ptr<function,NeuroModParams>, da: f32) -> f32 {
	var ada = da;
	if (da > 0) {
		ada *= (*nm).BurstGain;
	} else {
		ada *= (*nm).DipGain;
	}
	var gain = f32(1);
	switch ((*nm).DAMod) {
	case NoDAMod: {
	}
	case D1Mod: {
		gain += (*nm).DAModGain * ada;
	}
	case D2Mod: {
		gain -= (*nm).DAModGain * ada;
	}
	case D1AbsMod: {
		gain += (*nm).DAModGain * abs(ada);
	}
	default: {
	}
	}
	if (gain < 0) {
		gain = f32(0);
	}return gain;
}
fn NeuroModParams_GiFromACh(nm: ptr<function,NeuroModParams>, ach: f32) -> f32 {
	var ai = 1 - ach;
	if (ai < 0) {
		ai = f32(0);
	}return (*nm).AChDisInhib * ai;
}

///////////// import: "neuron.go"
alias NeuronFlags = i32; //enums:enum
const  NeuronOff: NeuronFlags = 1;
const  NeuronHasExt: NeuronFlags = 2;
const  NeuronHasTarg: NeuronFlags = 4;
const  NeuronHasCmpr: NeuronFlags = 8;
alias NeuronVars = i32; //enums:enum
const  Spike: NeuronVars = 0;
const  Spiked: NeuronVars = 1;
const  Act: NeuronVars = 2;
const  ActInt: NeuronVars = 3;
const  Ge: NeuronVars = 4;
const  Gi: NeuronVars = 5;
const  Gk: NeuronVars = 6;
const  Inet: NeuronVars = 7;
const  Vm: NeuronVars = 8;
const  VmDend: NeuronVars = 9;
const  ISI: NeuronVars = 10;
const  ISIAvg: NeuronVars = 11;
const  Ext: NeuronVars = 12;
const  Target: NeuronVars = 13;
const  CaM: NeuronVars = 14;
const  CaP: NeuronVars = 15;
const  CaD: NeuronVars = 16;
const  LearnCa: NeuronVars = 17;
const  LearnCaM: NeuronVars = 18;
const  LearnCaP: NeuronVars = 19;
const  LearnCaD: NeuronVars = 20;
const  CaDiff: NeuronVars = 21;
const  RLRate: NeuronVars = 22;
const  GnmdaSyn: NeuronVars = 23;
const  Gnmda: NeuronVars = 24;
const  GnmdaLrn: NeuronVars = 25;
const  GnmdaMaint: NeuronVars = 26;
const  NmdaCa: NeuronVars = 27;
const  Gvgcc: NeuronVars = 28;
const  VgccM: NeuronVars = 29;
const  VgccH: NeuronVars = 30;
const  VgccCa: NeuronVars = 31;
const  VgccCaInt: NeuronVars = 32;
const  Burst: NeuronVars = 33;
const  BurstPrv: NeuronVars = 34;
const  CtxtGe: NeuronVars = 35;
const  CtxtGeRaw: NeuronVars = 36;
const  CtxtGeOrig: NeuronVars = 37;
const  GgabaB: NeuronVars = 38;
const  GABAB: NeuronVars = 39;
const  GABABx: NeuronVars = 40;
const  Gak: NeuronVars = 41;
const  SSGiDend: NeuronVars = 42;
const  GknaMed: NeuronVars = 43;
const  GknaSlow: NeuronVars = 44;
const  Gkir: NeuronVars = 45;
const  KirM: NeuronVars = 46;
const  Gsk: NeuronVars = 47;
const  SKCaIn: NeuronVars = 48;
const  SKCaR: NeuronVars = 49;
const  SKCaM: NeuronVars = 50;
const  Gmahp: NeuronVars = 51;
const  MahpN: NeuronVars = 52;
const  Gsahp: NeuronVars = 53;
const  SahpCa: NeuronVars = 54;
const  SahpN: NeuronVars = 55;
const  ActM: NeuronVars = 56;
const  ActP: NeuronVars = 57;
const  Beta1: NeuronVars = 58;
const  Beta2: NeuronVars = 59;
const  SpkMax: NeuronVars = 60;
const  SpkMaxCa: NeuronVars = 61;
const  SpkBin0: NeuronVars = 62;
const  SpkBin1: NeuronVars = 63;
const  SpkBin2: NeuronVars = 64;
const  SpkBin3: NeuronVars = 65;
const  SpkBin4: NeuronVars = 66;
const  SpkBin5: NeuronVars = 67;
const  SpkBin6: NeuronVars = 68;
const  SpkBin7: NeuronVars = 69;
const  SpkPrv: NeuronVars = 70;
const  GeNoise: NeuronVars = 71;
const  GeNoiseP: NeuronVars = 72;
const  GiNoise: NeuronVars = 73;
const  GiNoiseP: NeuronVars = 74;
const  GeExt: NeuronVars = 75;
const  GeRaw: NeuronVars = 76;
const  GeSyn: NeuronVars = 77;
const  GiRaw: NeuronVars = 78;
const  GiSyn: NeuronVars = 79;
const  GeInt: NeuronVars = 80;
const  GeIntNorm: NeuronVars = 81;
const  GiInt: NeuronVars = 82;
const  GModRaw: NeuronVars = 83;
const  GModSyn: NeuronVars = 84;
const  SMaintP: NeuronVars = 85;
const  GMaintRaw: NeuronVars = 86;
const  GMaintSyn: NeuronVars = 87;
const  NeurFlags: NeuronVars = 88;
alias NeuronAvgVars = i32; //enums:enum
const  ActAvg: NeuronAvgVars = 0;
const  AvgPct: NeuronAvgVars = 1;
const  TrgAvg: NeuronAvgVars = 2;
const  DTrgAvg: NeuronAvgVars = 3;
const  AvgDif: NeuronAvgVars = 4;
const  GeBase: NeuronAvgVars = 5;
const  GiBase: NeuronAvgVars = 6;
alias NeuronIndexVars = i32; //enums:enum
const  NrnNeurIndex: NeuronIndexVars = 0;
const  NrnLayIndex: NeuronIndexVars = 1;
const  NrnSubPool: NeuronIndexVars = 2;

///////////// import: "pathparams.go"
const  StartOff: i32 = 0;
const  Nitems: i32 = 1;
const  StartNN: i32 = 2;
struct StartN {
	Start: u32,
	N: u32,
	pad: u32,
	pad1: u32, // todo: see if we can do without these?
}
struct PathIndexes {
	RecvLayer: u32,
	RecvNeurSt: u32,
	RecvNeurN: u32,
	SendLayer: u32,
	SendNeurSt: u32,
	SendNeurN: u32,
	SynapseSt: u32,
	SendConSt: u32,
	RecvConSt: u32,
	RecvSynSt: u32,
	NPathNeurSt: u32,
	pad: u32,
}
struct GScaleValues {
	Scale: f32,
	Rel: f32,
	pad: f32,
	pad1: f32,
}
struct PathParams {
	Type: PathTypes,
	Index: u32,
	pad: i32,
	pad1: i32,
	Indexes: PathIndexes,
	Com: SynComParams,
	PathScale: PathScaleParams,
	SWts: SWtParams,
	Learn: LearnSynParams,
	GScale: GScaleValues,
	RLPred: RLPredPathParams,
	Matrix: MatrixPathParams,
	BLA: BLAPathParams,
	Hip: HipPathParams,
}

///////////// import: "pathtypes.go"
alias PathTypes = i32; //enums:enum
const  ForwardPath: PathTypes = 0;
const  BackPath: PathTypes = 1;
const  LateralPath: PathTypes = 2;
const  InhibPath: PathTypes = 3;
const  CTCtxtPath: PathTypes = 4;
const  RWPath: PathTypes = 5;
const  TDPredPath: PathTypes = 6;
const  BLAPath: PathTypes = 7;
const  HipPath: PathTypes = 8;
const  VSPatchPath: PathTypes = 9;
const  VSMatrixPath: PathTypes = 10;
const  DSMatrixPath: PathTypes = 11;

///////////// import: "pcore-layer.go"
struct MatrixParams {
	GateThr: f32,
	IsVS: i32,
	OtherMatrixIndex: i32,
	ThalLay1Index: i32,
	ThalLay2Index: i32,
	ThalLay3Index: i32,
	ThalLay4Index: i32,
	ThalLay5Index: i32,
	ThalLay6Index: i32,
	pad: i32,
	pad1: i32,
	pad2: i32,
}
alias GPLayerTypes = i32; //enums:enum
const  GPePr: GPLayerTypes = 0;
const  GPeAk: GPLayerTypes = 1;
const  GPi: GPLayerTypes = 2;
struct GPParams {
	GPType: GPLayerTypes,
	pad: u32,
	pad1: u32,
	pad2: u32,
}

///////////// import: "pcore-path.go"
struct MatrixPathParams {
	Credit: f32,
	BasePF: f32,
	Delta: f32,
	VSRewLearn: i32,
}

///////////// import: "pool.go"
alias PoolIntVars = i32; //enums:enum
const  PoolNeurSt: PoolIntVars = 0;
const  PoolNeurEd: PoolIntVars = 1;
const  PoolLayerIdx: PoolIntVars = 2;
const  PoolIsLayer: PoolIntVars = 3;
const  Clamped: PoolIntVars = 4;
const  PoolGated: PoolIntVars = 5;
const  FFsRawInt: PoolIntVars = 6;
const  FBsRawInt: PoolIntVars = 7;
const  GeExtRawInt: PoolIntVars = 8;
const  PoolIntAvgMaxStart: PoolIntVars = 9;
alias AvgMax = i32; //enums:enum
const  Avg: AvgMax = 0;
const  Max: AvgMax = 1;
alias AvgMaxPhases = i32; //enums:enum -trim-prefix AM
const  AMCycle: AvgMaxPhases = 0;
const  AMMinus: AvgMaxPhases = 1;
const  AMPlus: AvgMaxPhases = 2;
const  AMPrev: AvgMaxPhases = 3;
alias AvgMaxVars = i32; //enums:enum -trim-prefix AM
const  AMCaP: AvgMaxVars = 0;
const  AMCaD: AvgMaxVars = 1;
const  AMSpkMax: AvgMaxVars = 2;
const  AMAct: AvgMaxVars = 3;
const  AMGeInt: AvgMaxVars = 4;
const  AMGiInt: AvgMaxVars = 5;
const  AMAvgDif: AvgMaxVars = 6;
const  poolFloatAvgMaxStart = InhibVarsN;
const  PoolVarsN = poolFloatAvgMaxStart + InhibVars(i32(AvgMaxVarsN)*i32(AvgMaxN)*i32(AvgMaxPhasesN));
const  PoolIntVarsTot = PoolIntAvgMaxStart + PoolIntVars(i32(AvgMaxVarsN)*i32(AvgMaxN));
const avgMaxToNeuron = array(CaP, CaD, SpkMax, Act, GeInt, GiInt);
fn AvgMaxVarIndex(vr: AvgMaxVars, phase: AvgMaxPhases, am: AvgMax) -> u32 {
	return u32(poolFloatAvgMaxStart) + u32(vr)*u32(AvgMaxN)*u32(AvgMaxPhasesN) + u32(phase)*u32(AvgMaxN) + u32(am);
}
fn PoolAvgMax(vr: AvgMaxVars, phase: AvgMaxPhases, am: AvgMax, pi: u32,di: u32) -> f32 {
	return Pools[IndexF323D(Pools[0], Pools[1], Pools[2], u32(pi),u32(di),u32(AvgMaxVarIndex(vr, phase, am)))];
}
fn PoolNNeurons(pi: u32) -> i32 {
	return PoolsInt[IndexI323D(PoolsInt[0], PoolsInt[1], PoolsInt[2], u32(pi),u32(0),u32(PoolNeurEd))] - PoolsInt[IndexI323D(PoolsInt[0], PoolsInt[1], PoolsInt[
	2], u32(pi),u32(0),u32(PoolNeurSt))];
}

///////////// import: "rand.go"
alias RandFunIndex = u32;
const  RandFunActPGe: RandFunIndex = 0;
const  RandFunActPGi: RandFunIndex = 1;
const  RandFunActSMaintP: RandFunIndex = 2;
const  RandFunIndexN: RandFunIndex = 3;
fn GetRandomNumber(index: u32, counter: su64, funIndex: RandFunIndex) -> f32 {
	return RandFloat32(counter, u32(funIndex), index);
}

///////////// import: "rl-layer.go"
struct RWPredParams {
	PredRange: F32,
}
struct RWDaParams {
	TonicGe: f32,
	RWPredLayIndex: i32,
	pad: u32,
	pad1: u32,
}
fn RWDaParams_GeFromDA(rp: ptr<function,RWDaParams>, da: f32) -> f32 {
	var ge = (*rp).TonicGe * (1.0 + da);
	if (ge < 0) {
		ge = f32(0);
	}return ge;
}
struct TDIntegParams {
	Discount: f32,
	PredGain: f32,
	TDPredLayIndex: i32,
	pad: u32,
}
struct TDDaParams {
	TonicGe: f32,
	TDIntegLayIndex: i32,
	pad: u32,
	pad1: u32,
}
fn TDDaParams_GeFromDA(tp: ptr<function,TDDaParams>, da: f32) -> f32 {
	return (*tp).TonicGe * (1.0 + da);
}

///////////// import: "rl-path.go"
struct RLPredPathParams {
	OppSignLRate: f32,
	DaTol: f32,
	pad: f32,
	pad1: f32,
}

///////////// import: "rubicon-layer.go"
struct LDTParams {
	SrcThr: f32,
	Rew: i32,
	MaintInhib: f32,
	SrcLay1Index: i32,
	SrcLay2Index: i32,
	SrcLay3Index: i32,
	SrcLay4Index: i32,
	pad: f32,
}
struct VTAParams {
	CeMGain: f32,
	LHbGain: f32,
	AChThr: f32,
	pad: f32,
}

///////////// import: "rubicon-path.go"
struct BLAPathParams {
	NegDeltaLRate: f32,
	AChThr: f32,
	USTrace: f32,
	pad: f32,
}

///////////// import: "rubicon.go"
fn RubiconUSStimValue(di: u32, usIndex: u32, valence: ValenceTypes) -> f32 {
	var nix = NetworkIxs[0];
	var us = f32(0);
	switch (valence) {
	case Positive: {
		if (usIndex < nix.RubiconNPosUSs) {
			us = GlobalVectors[IndexF323D(GlobalVectors[0], GlobalVectors[1], GlobalVectors[2], u32(GvUSpos),u32(usIndex),u32(di))];
		}
	}
	case Negative: {
		if (usIndex < nix.RubiconNNegUSs) {
			us = GlobalVectors[IndexF323D(GlobalVectors[0], GlobalVectors[1], GlobalVectors[2], u32(GvUSneg),u32(usIndex),u32(di))];
		}
	}
	case Cost: {
		if (usIndex < nix.RubiconNCosts) {
			us = GlobalVectors[IndexF323D(GlobalVectors[0], GlobalVectors[1], GlobalVectors[2], u32(GvCost),u32(usIndex),u32(di))];
		}
	}
	default: {
	}
	}return us;
}

///////////// import: "stats.go"

///////////// import: "synapse.go"
alias SynapseVars = i32; //enums:enum
const  Wt: SynapseVars = 0;
const  LWt: SynapseVars = 1;
const  SWt: SynapseVars = 2;
const  DWt: SynapseVars = 3;
const  DSWt: SynapseVars = 4;
alias SynapseTraceVars = i32; //enums:enum
const  Tr: SynapseTraceVars = 0;
const  DTr: SynapseTraceVars = 1;
const  DiDWt: SynapseTraceVars = 2;
alias SynapseIndexVars = i32; //enums:enum
const  SynRecvIndex: SynapseIndexVars = 0;
const  SynSendIndex: SynapseIndexVars = 1;
const  SynPathIndex: SynapseIndexVars = 2;

///////////// import: "slrand.wgsl"
fn Philox2x32round(counter: su64, key: u32) -> su64 {
	let mul = Uint32Mul64(u32(0xD256D193), counter.x);
	var ctr: su64;
	ctr.x = mul.y ^ key ^ counter.y;
	ctr.y = mul.x;
	return ctr;
}
fn Philox2x32bumpkey(key: u32) -> u32 {
	return key + u32(0x9E3779B9);
}
fn Philox2x32(counter: su64, key: u32) -> vec2<u32> {
	var ctr = Philox2x32round(counter, key); // 1
	var ky = Philox2x32bumpkey(key);
	ctr = Philox2x32round(ctr, ky); // 2
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 3
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 4
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 5
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 6
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 7
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 8
	ky = Philox2x32bumpkey(ky);
	ctr = Philox2x32round(ctr, ky); // 9
	ky = Philox2x32bumpkey(ky);
	return Philox2x32round(ctr, ky); // 10
}
fn RandUint32Vec2(counter: su64, funcIndex: u32, key: u32) -> vec2<u32> {
	return Philox2x32(Uint64Add32(counter, funcIndex), key);
}
fn RandUint32(counter: su64, funcIndex: u32, key: u32) -> u32 {
	return Philox2x32(Uint64Add32(counter, funcIndex), key).x;
}
fn RandFloat32Vec2(counter: su64, funcIndex: u32, key: u32) -> vec2<f32> {
	return Uint32ToFloat32Vec2(RandUint32Vec2(counter, funcIndex, key));
}
fn RandFloat32(counter: su64, funcIndex: u32, key: u32) -> f32 { 
	return Uint32ToFloat32(RandUint32(counter, funcIndex, key));
}
fn RandFloat32Range11Vec2(counter: su64, funcIndex: u32, key: u32) -> vec2<f32> {
	return Uint32ToFloat32Vec2(RandUint32Vec2(counter, funcIndex, key));
}
fn RandFloat32Range11(counter: su64, funcIndex: u32, key: u32) -> f32 { 
	return Uint32ToFloat32Range11(RandUint32(counter, funcIndex, key));
}
fn RandBoolP(counter: su64, funcIndex: u32, key: u32, p: f32) -> bool { 
	return (RandFloat32(counter, funcIndex, key) < p);
}
fn sincospi(x: f32) -> vec2<f32> {
	let PIf = 3.1415926535897932;
	var r: vec2<f32>;
	r.x = cos(PIf*x);
	r.y = sin(PIf*x);
	return r;
}
fn RandFloat32NormVec2(counter: su64, funcIndex: u32, key: u32) -> vec2<f32> { 
	let ur = RandUint32Vec2(counter, funcIndex, key);
	var f = sincospi(Uint32ToFloat32Range11(ur.x));
	let r = sqrt(-2.0 * log(Uint32ToFloat32(ur.y))); // guaranteed to avoid 0.
	return f * r;
}
fn RandFloat32Norm(counter: su64, funcIndex: u32, key: u32) -> f32 { 
	return RandFloat32Vec2(counter, funcIndex, key).x;
}
fn RandUint32N(counter: su64, funcIndex: u32, key: u32, n: u32) -> u32 { 
	let v = RandFloat32(counter, funcIndex, key);
	return u32(v * f32(n));
}
struct RandCounter {
	Counter: su64,
	HiSeed: u32,
	pad: u32,
}
fn RandCounter_Reset(ct: ptr<function,RandCounter>) {
	(*ct).Counter.x = u32(0);
	(*ct).Counter.y = (*ct).HiSeed;
}
fn RandCounter_Seed(ct: ptr<function,RandCounter>, seed: u32) {
	(*ct).HiSeed = seed;
	RandCounter_Reset(ct);
}
fn RandCounter_Add(ct: ptr<function,RandCounter>, inc: u32) {
	(*ct).Counter = Uint64Add32((*ct).Counter, inc);
}

///////////// import: "sltype.wgsl"
alias su64 = vec2<u32>;
fn Uint32Mul64(a: u32, b: u32) -> su64 {
	let LOMASK = (((u32(1))<<16)-1);
	var r: su64;
	r.x = a * b;               /* full low multiply */
	let ahi = a >> 16;
	let alo = a & LOMASK;
	let bhi = b >> 16;
	let blo = b & LOMASK;
	let ahbl = ahi * blo;
	let albh = alo * bhi;
	let ahbl_albh = ((ahbl&LOMASK) + (albh&LOMASK));
	var hit = ahi*bhi + (ahbl>>16) +  (albh>>16);
	hit += ahbl_albh >> 16; /* carry from the sum of lo(ahbl) + lo(albh) ) */
	/* carry from the sum with alo*blo */
	if ((r.x >> u32(16)) < (ahbl_albh&LOMASK)) {
		hit += u32(1);
	}
	r.y = hit; 
	return r;
}
/*
fn Uint32Mul64(a: u32, b: u32) -> su64 {
	return su64(a) * su64(b);
}
*/
fn Uint64Add32(a: su64, b: u32) -> su64 {
	if (b == 0) {
		return a;
	}
	var s = a;
	if (s.x > u32(0xffffffff) - b) {
		s.y++;
		s.x = (b - 1) - (u32(0xffffffff) - s.x);
	} else {
		s.x += b;
	}
	return s;
}
fn Uint64Incr(a: su64) -> su64 {
	var s = a;
	if(s.x == 0xffffffff) {
		s.y++;
		s.x = u32(0);
	} else {
		s.x++;
	}
	return s;
}
fn Uint32ToFloat32(val: u32) -> f32 {
	let factor = f32(1.0) / (f32(u32(0xffffffff)) + f32(1.0));
	let halffactor = f32(0.5) * factor;
	var f = f32(val) * factor + halffactor;
	if (f == 1.0) { // exclude 1
		return bitcast<f32>(0x3F7FFFFF);
	}
	return f;
}
fn Uint32ToFloat32Vec2(val: vec2<u32>) -> vec2<f32> {
	var r: vec2<f32>;
	r.x = Uint32ToFloat32(val.x);
	r.y = Uint32ToFloat32(val.y);
	return r;
}
fn Uint32ToFloat32Range11(val: u32) -> f32 {
	let factor = f32(1.0) / (f32(i32(0x7fffffff)) + f32(1.0));
	let halffactor = f32(0.5) * factor;
	return (f32(val) * factor + halffactor);
}
fn Uint32ToFloat32Range11Vec2(val: vec2<u32>) -> vec2<f32> {
	var r: vec2<f32>;
	r.x = Uint32ToFloat32Range11(val.x);
	r.y = Uint32ToFloat32Range11(val.y);
	return r;
}