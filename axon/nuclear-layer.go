// Code generated by "goal build"; DO NOT EDIT.
//line nuclear-layer.goal:1
// Copyright (c) 2025, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package axon

// import "fmt"

//gosl:start

// NuclearParams has parameters that apply to all cerebellum Nuclear model neurons.
// Not just cerebellar nuclei neurons: also applies to PC.
type NuclearParams struct {

	// ActionEnv is the total time envelope for actions to be tracked,
	// in ms (cycles). Must be consistent across microzone elements.
	ActionEnv int32 `default:"180" min:"0"`

	// SendTimeOff is the time offset for sending activations used in learning,
	// relative to the IO-driven LearnNow time. Should be 0 for CNiUp.
	// Must be an even multiple of [CaBinCycles].
	SendTimeOff int32 `default:"40,0" min:"0"`

	// SendTimeWindow is the time window to integrate sending activations
	// used in learning. Must be an even multiple of [CaBinCycles].
	SendTimeWindow int32 `default:"30" min:"0"`

	// ActTarget is the target activity level, as measured by CaD.
	// GeBase is adapted, along with excitatory MF inputs in proportion to activity,
	// which is the source of very slow synaptic decay in these pathways.
	ActTarget float32 `default:"0.5" min:"0.0"`

	// Decay is the rate of decay (prior to the learning rate multiplier)
	// for baseline non-learning trials.
	Decay float32 `default:"0.01"`

	// GeBaseLRate is the learning rate for neuron-level [GeBase] baseline
	// excitatory conductance, to maintain target activity levels.
	GeBaseLRate float32 `default:"0.01"`

	// IOLayIndex of IO (inferior olive) layer for sending error signals
	// to this layer. Set via SetBuildConfig(IOLayName) setting.
	IOLayIndex int32 `edit:"-"`

	// SendTimeBins = SendTimeWindow / [CaBinCycles].
	SendTimeBins int32 `edit:"-"`
}

func (tp *NuclearParams) Update() {
	tp.SendTimeBins = tp.SendTimeWindow / CaBinCycles
}

func (tp *NuclearParams) Defaults() {
	tp.ActionEnv = 180
	tp.SendTimeOff = 40
	tp.SendTimeWindow = 30
	tp.ActTarget = 0.5
	tp.Decay = 0.01
	tp.GeBaseLRate = 0.01
	tp.Update()
}

// IsNuclear returns true if layer type is cerebellum (Nuclear model).
func (ly *LayerParams) IsNuclear() bool {
	return ly.Type >= IOLayer && ly.Type <= CNiUpLayer
}

// IOLearn gets the IO layer [LearnNow] signal.
func (ly *LayerParams) IOLearn(ctx *Context, lni, lpi, pi, ni, di uint32) {
	ioi := uint32(ly.Nuclear.IOLayIndex)
	ioly := GetLayers(ioi)
	Neurons.Set(Neurons.Value(int(ioly.Indexes.NeurSt+lni), int(di), int(LearnNow)), int(ni), int(di), int(LearnNow))
	Neurons.Set(Neurons.Value(int(ioly.Indexes.NeurSt+lni), int(di), int(TimePeak)), int(ni), int(di), int(TimePeak))
}

// NuclearLearnReset resets LearnNow if past envelope time, in new state
func (ly *LayerParams) NuclearLearnReset(ctx *Context, ni, di uint32) {
	effAct := int32(Neurons.Value(int(ni), int(di), int(TimeCycle)))
	if effAct == 0 {
		return
	}
	if Neurons.Value(int(ni), int(di), int(LearnNow)) == 0.0 { // not done yet
		return
	}
	envCyc := ctx.CyclesTotal - effAct // cycle within envelope
	if envCyc >= ly.Nuclear.ActionEnv {
		Neurons.Set(0.0, int(ni), int(di), int(TimeCycle))
		Neurons.Set(0.0, int(ni), int(di), int(TimePeak))
		Neurons.Set(0.0, int(ni), int(di), int(LearnNow))
	}
}

// NuclearDWtNeuron is the neuron-level learning rule for tonically-active
// Nuclear layers (e.g., [CNeLayer]).
// Used to adjust the GeBase levels per neuron.
func (ly *LayerParams) NuclearDWtNeuron(ctx *Context, ni uint32) {
	dbase := float32(0)
	for di := uint32(0); di < ly.MaxData; di++ {
		if Neurons.Value(int(ni), int(di), int(TimePeak)) == 1.0 { // non-baseline
			continue
		}
		aerr := ly.Nuclear.ActTarget - Neurons.Value(int(ni), int(di), int(CaD))
		dbase += aerr
	}
	dbase *= ly.Nuclear.GeBaseLRate
	gbase := NeuronAvgs.Value(int(ni), int(GeBase))
	gbase += dbase
	if gbase < 0 {
		gbase = 0
	}
	NeuronAvgs.Set(gbase, int(ni), int(GeBase))
}

// IOParams has parameters for the IO inferior olive neurons,
// which compute a temporal offset error signal between CNiIO inhibitory
// predictions and excitatory sensory input, contingent on initial
// above-threshold efferent copy motor trigger input (modulatory).
// Neuron [CaBins] are used to store TimeOff past inhibitory inputs.
type IOParams struct {

	// TimeOff is the time offset for earlier predictive inhibitory inputs to
	// compare against current excitatory inputs to trigger an error,
	// in ms (cycles). Must be an even multiple of [CaBinCycles].
	TimeOff int32 `default:"50" min:"0"`

	// ErrThr is the threshold on the GeSyn - GiSyn_(t-TimeOff) difference
	// to trigger an error.
	ErrThr float32 `default:"0.1" min:"0.0"`

	// EfferentThr is the threshold for modulatory [GModSyn] from efferent copy
	// inputs to trigger an activated IO window where error comparison occurs.
	// Efferent inputs can continue post-threshold, but this is the point at which
	// the envelope opens.
	EfferentThr float32 `default:"0.2" min:"0.0"`

	// EfferentOff is the offset from the time of the efferent signal before
	// meaningful sensory comparison can occur. The inhibitory prediction values
	// are assumed to be strongly activated at this time.
	// in ms (cycles). Must be an even multiple of [CaBinCycles].
	EfferentOff int32 `default:"20" min:"0"`

	// GTau is the time constant in ms for integrating [GeSyn] and [GiSyn]
	// excitatory and inhibitory conductances for comparison.
	// Integration goes into GaM (only for IO neurons).
	GTau float32 `default:"20"`

	// Dt = 1 / Tau
	GDt float32 `display:"-"`

	pad, pad1 float32
}

func (tp *IOParams) Update() {
	tp.GDt = 1.0 / tp.GTau
}

func (tp *IOParams) Defaults() {
	tp.TimeOff = 50
	tp.ErrThr = 0.1
	tp.EfferentThr = 0.2
	tp.EfferentOff = 20
	tp.GTau = 20
	tp.Update()
}

// TODO: IO neurons integrate across many distinct comparisons!
// here, we just have 1 IO per pairwise comparison.
// Need to get layer and do indexing or something. Figure out
// best way to organize later.

// IOUpdate is the main IO update routine, called in
// LayerParams::PostSpikeSpecial
func (ly *LayerParams) IOUpdate(ctx *Context, lpi, pi, ni, di uint32) {
	cycTot := float32(ctx.CyclesTotal)
	effAct := int32(Neurons.Value(int(ni), int(di), int(TimeCycle)))
	envCyc := ctx.CyclesTotal - effAct // cycle within envelope

	gaP := Neurons.Value(int(ni), int(di), int(GaP)) // IOe excitatory input
	gaP += ly.IO.GDt * (Neurons.Value(int(ni), int(di), int(GeSyn)) - gaP)
	Neurons.Set(gaP, int(ni), int(di), int(GaP))

	gaM := Neurons.Value(int(ni), int(di), int(GaM))
	gaM += ly.IO.GDt * (Neurons.Value(int(ni), int(di), int(GiSyn)) - gaM)
	Neurons.Set(gaM, int(ni), int(di), int(GaM))
	inhibAct := gaM
	// CaBinCycles to ensure that full bin is filled
	if effAct > 0 && envCyc <= ly.IO.EfferentOff+CaBinCycles {
		inhibAct = 1.0
	}
	CaBinIncrement(inhibAct, ctx.CyclesTotal, ni, di) // always store

	Neurons.Set(0.0, int(ni), int(di), int(TimeDiff)) // set below for display
	Neurons.Set(0.0, int(ni), int(di), int(Spike))    // default is no spike

	oldInhib := float32(0)
	nbins := ly.IO.TimeOff / CaBinCycles
	nbins = max(1, nbins-1)
	stcyc := ctx.CyclesTotal - ly.IO.TimeOff
	for i := range nbins {
		bi := CaBinForCycle(stcyc + i*CaBinCycles)
		oldInhib += Neurons.Value(int(ni), int(di), int(CaBins+NeuronVars(bi)))
	}
	oldInhib /= float32(nbins)
	Neurons.Set(oldInhib, int(ni), int(di), int(GaD))

	if Neurons.Value(int(ni), int(di), int(LearnNow)) > 0 { // already learned, done until cleared in NuclearLearnReset
		Neurons.Set(0.0, int(ni), int(di), int(Spike))
		return
	}
	if effAct == 0 {
		Neurons.Set(0.0, int(ni), int(di), int(Spike))
		if Neurons.Value(int(ni), int(di), int(GModSyn)) > ly.IO.EfferentThr { // efferent always activates.
			Neurons.Set(cycTot, int(ni), int(di), int(TimeCycle)) // efferent activation cycle
			Neurons.Set(0.0, int(ni), int(di), int(TimePeak))
			Neurons.Set(0.0, int(ni), int(di), int(LearnNow))
		}
		return
	}
	if envCyc <= (ly.IO.TimeOff + ly.IO.EfferentOff) { // nothing until min
		return
	}
	if envCyc >= ly.Nuclear.ActionEnv { // no errors until the end of envelope: baseline spike
		Neurons.Set(cycTot, int(ni), int(di), int(LearnNow))
		Neurons.Set(1.0, int(ni), int(di), int(Spike)) // baseline spike
		return
	}
	errVal := gaP - oldInhib
	Neurons.Set(errVal, int(ni), int(di), int(TimeDiff))
	if gaP > ly.Learn.Timing.LearnThr && errVal > ly.IO.ErrThr {
		//	if ni == 1664 {
		//		fmt.Println("act:", gaP, oldInhib, errVal)
		//	}
		Neurons.Set(1.0, int(ni), int(di), int(Spike))       // error spike
		Neurons.Set(cycTot, int(ni), int(di), int(LearnNow)) // record point of error
		Neurons.Set(1.0, int(ni), int(di), int(TimePeak))    // records that we got err spike
	}
}

//gosl:end

// NuclearPostBuild does post-Build config of Nuclear models of the
// cerebellum based on BuildConfig options.
func (ly *Layer) NuclearPostBuild() {
	ly.Params.Nuclear.IOLayIndex = ly.BuildConfigFindLayer("IOLayName", true)
}

// LinearDefaults sets parameters to allow neurons to linearly encode
// values in their rate of firing, to the extent possible.
func (ly *LayerParams) LinearDefaults() {
	// turn off accommodation currents
	ly.Acts.Mahp.Gk = 0
	ly.Acts.Sahp.Gk = 0
	ly.Acts.KNa.On.SetBool(false)
	// no sustained:
	ly.Acts.NMDA.Ge = 0
	ly.Acts.GabaB.Gk = 0
}

// NuclearDefaults called in Defaults for all Nuclear layers
func (ly *LayerParams) NuclearDefaults() {
	ly.Learn.TrgAvgAct.RescaleOn.SetBool(false)
	ly.Acts.Init.GeBase = 0.25
	ly.Inhib.Layer.On.SetBool(false)
	ly.Acts.Decay.Act = 0.0
	ly.Acts.Decay.Glong = 0.0 // clear long
	ly.Acts.Decay.AHP = 0.0   // clear long

	ly.LinearDefaults()

	// ly.Learn.RLRate.SigmoidMin = 1.0 // 1.0 generally better but worth trying 0.05 too

	//	for _, pj := range lly.RecvPaths {
	//		pj.Params.SWts.Init.Mean = 0.8
	//		pj.Params.SWts.Init.Var = 0.0
	//		if pj.Send.Type != CNiIOLayer {
	//			pj.Params.SetFixedWts()
	//		} else {
	//			pj.Params.SWts.Init.Mean = 0.5
	//		}
	//	}
}

// called in Defaults for [IOLayer] type
func (ly *LayerParams) IODefaults() {
	ly.NuclearDefaults()
	ly.Learn.Timing.On.SetBool(false)
	ly.Acts.Init.GeBase = 0
}

// called in Defaults for [CNiIOLayer] type
func (ly *LayerParams) CNiIODefaults() {
	ly.NuclearDefaults()
	ly.Acts.Init.GeBase = 0
	ly.Nuclear.ActTarget = 0
	ly.Nuclear.SendTimeOff = 40
}

// called in Defaults for [CNiUpLayer] type
func (ly *LayerParams) CNiUpDefaults() {
	ly.NuclearDefaults()
	ly.Acts.Init.GeBase = 0
	ly.Nuclear.ActTarget = 0
	ly.Nuclear.SendTimeOff = 10 // match the excitatory
}
