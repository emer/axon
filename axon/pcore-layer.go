// Code generated by "goal build"; DO NOT EDIT.
//line pcore-layer.goal:1
// Copyright (c) 2022, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package axon

import (
	"strings"

	"cogentcore.org/core/base/errors"
	"cogentcore.org/core/base/num"
	"cogentcore.org/core/math32/minmax"
	"github.com/emer/axon/v2/fsfffb"
)

//gosl:start

// DSMatrixParams has parameters for DSMatrixLayer.
// DA, ACh learning rate modulation is pre-computed on the recv neuron
// RLRate variable via NeuroMod.
// Must set Learn.NeuroMod.DAMod = D1Mod or D2Mod via SetBuildConfig("DAMod").
type DSMatrixParams struct {

	// PatchD1Range is the range of PatchD1 values to normalize into effective value.
	PatchD1Range minmax.F32 `default:"{'Min':0.1,'Max':0.3}" display:"inline"`

	// PatchD2Range is the range of PatchD2 values to normalize into effective value.
	PatchD2Range minmax.F32 `default:"{'Min':0.05,'Max':0.25}" display:"inline"`

	// PatchDAModGain is a separate NeuroMod.DAModGain factor applying
	// to DA performance gain effects from the Patch-based DA values.
	// The standard NeuroMod parameters apply only to the final outcome-based
	// dopamine values.
	PatchDAModGain float32 `default:"0.02"`

	// PatchBurstGain is a separate NeuroMod.BurstGain-like factor applying
	// to DA performance gain effects from the Patch-based DA values.
	// The standard NeuroMod parameters apply only to the final outcome-based
	// dopamine values, which do not drive performance DA effects in dorsal striatum.
	// NeuroMod.DAModGain does control overall performance gain from patch.
	PatchBurstGain float32 `default:"1.0"`

	// Index of PatchD1 layer to get striosome modulation state from.
	// Set during Build from BuildConfig PatchD1Name.
	PatchD1Index int32 `edit:"-"`

	// Index of PatchD2 layer to get striosome modulation state from.
	// Set during Build from BuildConfig PatchD2Name.
	PatchD2Index int32 `edit:"-"`
}

func (mp *DSMatrixParams) Defaults() {
	mp.PatchDAModGain = 0.02
	mp.PatchBurstGain = 1.0
	mp.PatchD1Range.Set(0.1, 0.3)
	mp.PatchD2Range.Set(0.05, 0.25)
}

func (mp *DSMatrixParams) Update() {
}

// StriatumParams has params and indexes for BG Striatum layers including
// DSMatrixLayer, VSMatrixLayer, and DSPatchLayer.
type StriatumParams struct {

	// GateThr is the threshold on layer Avg CaPMax for Matrix Go and BG Thal
	// layers to count as having gated.
	GateThr float32 `default:"0.05"`

	// Index of other layer (D2 if we are D1 and vice-versa).
	// Set during Build from BuildConfig OtherName.
	OtherIndex int32 `edit:"-"`

	// Index of PF parafasciculus layer to get gating output state from.
	// Set during Build from BuildConfig PFName.
	PFIndex int32 `edit:"-"`

	// Index of thalamus layer that we gate. needed to get gating information.
	// Set during Build from BuildConfig ThalLay1Name if present -- -1 if not used
	ThalLay1Index int32 `edit:"-"`

	// Index of thalamus layer that we gate. needed to get gating information.
	// Set during Build from BuildConfig ThalLay1Name if present -- -1 if not used
	ThalLay2Index int32 `edit:"-"`

	// Index of thalamus layer that we gate. needed to get gating information.
	// Set during Build from BuildConfig ThalLay1Name if present -- -1 if not used
	ThalLay3Index int32 `edit:"-"`

	// Index of thalamus layer that we gate. needed to get gating information.
	// Set during Build from BuildConfig ThalLay1Name if present -- -1 if not used
	ThalLay4Index int32 `edit:"-"`

	// Index of thalamus layer that we gate. needed to get gating information.
	// Set during Build from BuildConfig ThalLay1Name if present -- -1 if not used
	ThalLay5Index int32 `edit:"-"`

	// Index of thalamus layer that we gate. needed to get gating information.
	// Set during Build from BuildConfig ThalLay1Name if present -- -1 if not used
	ThalLay6Index int32 `edit:"-"`

	pad, pad1, pad2 float32
}

func (mp *StriatumParams) Defaults() {
	mp.GateThr = 0.05
}

func (mp *StriatumParams) Update() {
}

//////// GP

// GPLayerTypes is a GPLayer axon-specific layer type enum.
type GPLayerTypes int32 //enums:enum

// The GPLayer types
const (
	// GPePr is the set of prototypical GPe neurons, mediating classical NoGo
	GPePr GPLayerTypes = iota

	// GPeAk is arkypallidal layer of GPe neurons, receiving inhibition from GPePr
	// and projecting inhibition to Mtx
	GPeAk

	// GPi is the inner globus pallidus, functionally equivalent to SNr,
	// receiving from MtxGo and GPePr, and sending inhibition to VThal
	GPi
)

// GPLayer represents a globus pallidus layer, including:
// GPePr, GPeAk (arkypallidal), and GPi (see GPType for type).
// Typically just a single unit per Pool representing a given stripe.
type GPParams struct {

	// type of GP Layer -- must set during config using SetBuildConfig of GPType.
	GPType GPLayerTypes

	pad, pad1, pad2 uint32
}

func (gp *GPParams) Defaults() {
}

func (gp *GPParams) Update() {
}

// MatrixGated is called after std PlusPhase
// Uses Pool state to set Gated flag based on CaPMax activity.
func (ly *LayerParams) MatrixGated(ctx *Context) {
	lpi := ly.PoolIndex(0)
	if ly.Learn.NeuroMod.DAMod != D1Mod {
		oly := Layers[ly.Striatum.OtherIndex]
		olpi := oly.PoolSt
		// note: NoGo layers don't track gating at the sub-pool level!
		for di := uint32(0); di < ctx.NData; di++ {
			PoolsInt.Set(PoolsInt.Value(int(olpi), int(di), int(PoolGated)), int(lpi), int(di), int(PoolGated))
		}
		return
	}
	for di := uint32(0); di < ctx.NData; di++ {
		mtxGated := PoolsInt.Value(int(lpi), int(di), int(PoolGated)) > 0
		thalGated := false
		if ly.Striatum.ThalLay1Index >= 0 {
			tly := Layers[ly.Striatum.ThalLay1Index]
			tlpi := tly.PoolSt
			gt := PoolsInt.Value(int(tlpi), int(di), int(PoolGated))
			thalGated = thalGated || gt > 0
		}
		if ly.Striatum.ThalLay2Index >= 0 {
			tly := Layers[ly.Striatum.ThalLay2Index]
			tlpi := tly.PoolSt
			gt := PoolsInt.Value(int(tlpi), int(di), int(PoolGated))
			thalGated = thalGated || gt > 0
		}
		if ly.Striatum.ThalLay3Index >= 0 {
			tly := Layers[ly.Striatum.ThalLay3Index]
			tlpi := tly.PoolSt
			gt := PoolsInt.Value(int(tlpi), int(di), int(PoolGated))
			thalGated = thalGated || gt > 0
		}
		if ly.Striatum.ThalLay4Index >= 0 {
			tly := Layers[ly.Striatum.ThalLay4Index]
			tlpi := tly.PoolSt
			gt := PoolsInt.Value(int(tlpi), int(di), int(PoolGated))
			thalGated = thalGated || gt > 0
		}
		if ly.Striatum.ThalLay5Index >= 0 {
			tly := Layers[ly.Striatum.ThalLay5Index]
			tlpi := tly.PoolSt
			gt := PoolsInt.Value(int(tlpi), int(di), int(PoolGated))
			thalGated = thalGated || gt > 0
		}
		if ly.Striatum.ThalLay6Index >= 0 {
			tly := Layers[ly.Striatum.ThalLay6Index]
			tlpi := tly.PoolSt
			gt := PoolsInt.Value(int(tlpi), int(di), int(PoolGated))
			thalGated = thalGated || gt > 0
		}

		mtxGated = mtxGated && thalGated

		// note: in principle with multi-pool GP, could try to establish
		// a correspondence between thal and matrix pools, such that
		// a failure to gate at the thal level for a given pool would veto
		// just the one corresponding pool.  However, we're not really sure
		// that this will make sense and not doing yet..

		if !mtxGated { // nobody did if thal didn't
			for spi := uint32(0); spi < ly.Indexes.NPools; spi++ {
				pi := ly.PoolIndex(spi)
				PoolsInt.Set(0, int(pi), int(di), int(PoolGated))
			}
		}
		if ctx.PlusPhase.IsTrue() && ly.Type == VSMatrixLayer {
			GlobalScalars.Set(num.FromBool[float32](mtxGated), int(GvVSMatrixJustGated), int(di))
			if mtxGated {
				poolIndex := int32(-1)
				for spi := uint32(1); spi < ly.Indexes.NPools; spi++ {
					pi := ly.PoolIndex(spi)
					if poolIndex < 0 && PoolsInt.Value(int(pi), int(di), int(PoolGated)) > 0 {
						poolIndex = int32(spi)
					}
				}
				if poolIndex > 0 {
					GlobalVectors.Set(float32(1.0), int(GvVSMatrixPoolGated), int(poolIndex), int(di))
				}
			}
		}
	}
}

// GatedFromCaPMax updates the Gated state in Pools of given layer,
// based on Avg CaPMax being above given threshold.
func (ly *LayerParams) GatedFromCaPMax(ctx *Context, di uint32) {
	anyGated := false
	lpi := ly.PoolIndex(0)
	thr := ly.Striatum.GateThr
	if ly.Indexes.NPools > 1 {
		for spi := uint32(1); spi < ly.Indexes.NPools; spi++ {
			pi := ly.PoolIndex(spi)
			spkavg := PoolAvgMax(AMCaPMax, AMCycle, Avg, pi, di)
			gthr := spkavg > thr
			if gthr {
				anyGated = true
				PoolsInt.Set(1, int(pi), int(di), int(PoolGated))
			} else {
				PoolsInt.Set(0, int(pi), int(di), int(PoolGated))
			}
		}
	} else {
		spkavg := PoolAvgMax(AMCaPMax, AMCycle, Avg, lpi, di)
		if spkavg > thr {
			anyGated = true
		}
	}
	if anyGated {
		PoolsInt.Set(1, int(lpi), int(di), int(PoolGated))
	} else {
		PoolsInt.Set(0, int(lpi), int(di), int(PoolGated))
	}
}

// AnyGated returns true if the layer-level pool Gated flag is true,
// which indicates if any of the layers gated.
func (ly *LayerParams) AnyGated(di uint32) bool {
	lpi := ly.PoolIndex(0)
	return PoolsInt.Value(int(lpi), int(di), int(PoolGated)) > 0
}

// CyclePostDSPatchLayer grabs PF activation
func (ly *LayerParams) CyclePostDSPatchLayer(ctx *Context, pi, di uint32, spi int32) {
	pf := Layers[ly.Striatum.PFIndex]
	pfact := PoolAvgMax(AMCaP, AMCycle, Avg, pf.PoolIndex(uint32(spi)), di) // must be CaP, not CaD
	Pools.Set(pfact, int(pi), int(di), int(fsfffb.ModAct))
}

// CyclePostDSMatrixLayer sets pool-specific DA dopamine signal based on PF
// activity and DSPatch
func (ly *LayerParams) CyclePostDSMatrixLayer(ctx *Context, pi, di uint32, spi int32) {
	pf := Layers[ly.Striatum.PFIndex]
	patchD1 := Layers[ly.DSMatrix.PatchD1Index]
	patchD2 := Layers[ly.DSMatrix.PatchD2Index]
	pfact := PoolAvgMax(AMCaP, AMCycle, Avg, pf.PoolIndex(uint32(spi)), di) // must be CaP
	ptD1act := PoolAvgMax(AMCaP, AMCycle, Avg, patchD1.PoolIndex(uint32(spi)), di)
	ptD2act := PoolAvgMax(AMCaP, AMCycle, Avg, patchD2.PoolIndex(uint32(spi)), di)
	Pools.Set(ly.DSMatrix.PatchD1Range.NormValue(ptD1act), int(pi), int(di), int(fsfffb.DAD1))
	Pools.Set(ly.DSMatrix.PatchD2Range.NormValue(ptD2act), int(pi), int(di), int(fsfffb.DAD2))
	Pools.Set(pfact, int(pi), int(di), int(fsfffb.ModAct))
}

//gosl:end

func (lly *Layer) MatrixDefaults() {
	ly := lly.Params
	ly.Acts.Decay.Act = 1
	ly.Acts.Decay.Glong = 1 // prevent carryover of NMDA
	ly.Acts.Kir.Gk = 10
	ly.Acts.GabaB.Gk = 0 // Kir replaces GabaB
	// ly.Acts.NMDA.Ge = 0    // Matrix needs nmda, default is fine
	ly.Inhib.Layer.FB = 0 // pure FF
	ly.Inhib.Layer.Gi = 0.5
	ly.Inhib.Pool.On.SetBool(true) // needs both pool and layer if has pools
	ly.Inhib.Pool.FB = 0           // pure FF
	ly.Inhib.Pool.Gi = 0.5
	ly.Inhib.ActAvg.Nominal = 0.25   // pooled should be lower
	ly.Learn.RLRate.On.SetBool(true) // key: sig deriv used outside of rew trials
	ly.Learn.RLRate.Diff.SetBool(false)
	ly.Learn.TrgAvgAct.RescaleOn.SetBool(true) // major effect

	// ly.Learn.NeuroMod.DAMod needs to be set via BuildConfig
	ly.Learn.NeuroMod.DALRateSign.SetBool(true) // critical
	ly.Learn.NeuroMod.DALRateMod = 1
	ly.Learn.NeuroMod.DAModGain = 0
	ly.Learn.NeuroMod.AChLRateMod = 0
	ly.Learn.NeuroMod.BurstGain = 0.1
	ly.Learn.RLRate.SigmoidMin = 0.001

	// important: user needs to adjust wt scale of some PFC inputs vs others:
	// drivers vs. modulators

	for _, pj := range lly.RecvPaths {
		pj.Params.SWts.Init.SPct = 0
		if pj.Send.Type == GPLayer { // GPeAkToMtx
			pj.Params.SetFixedWts()
			pj.Params.PathScale.Abs = 3
			pj.Params.SWts.Init.Mean = 0.75
			pj.Params.SWts.Init.Var = 0.0
		}
	}
}

func (lly *Layer) DSMatrixDefaults() {
	ly := lly.Params
	lly.MatrixDefaults()
	ly.Inhib.Layer.On.SetBool(false)
	ly.Acts.Dend.ModBase = 1
	ly.Acts.Dend.ModGain = 0
	ly.Learn.NeuroMod.AChDisInhib = 0
	ly.Learn.NeuroMod.DAModGain = 0.0 // DS

	for _, pj := range lly.RecvPaths {
		if pj.Send.Type == GPLayer { // GPeAkToMtx
			if strings.Contains(lly.Name, "No") {
				pj.Params.PathScale.Abs = 4
			}
		}
	}
}

func (lly *Layer) VSMatrixDefaults() {
	ly := lly.Params
	lly.MatrixDefaults()
	ly.Inhib.Layer.On.SetBool(true)
	ly.Acts.Dend.ModBase = 0
	ly.Acts.Dend.ModGain = 2 // for VS case -- otherwise irrelevant
	ly.Learn.NeuroMod.AChDisInhib = 5
	ly.Learn.NeuroMod.BurstGain = 1
}

func (lly *Layer) MatrixPostBuild() {
	ly := lly.Params
	ly.Striatum.ThalLay1Index = lly.BuildConfigFindLayer("ThalLay1Name", false) // optional
	ly.Striatum.ThalLay2Index = lly.BuildConfigFindLayer("ThalLay2Name", false) // optional
	ly.Striatum.ThalLay3Index = lly.BuildConfigFindLayer("ThalLay3Name", false) // optional
	ly.Striatum.ThalLay4Index = lly.BuildConfigFindLayer("ThalLay4Name", false) // optional
	ly.Striatum.ThalLay5Index = lly.BuildConfigFindLayer("ThalLay5Name", false) // optional
	ly.Striatum.ThalLay6Index = lly.BuildConfigFindLayer("ThalLay6Name", false) // optional

	ly.Striatum.OtherIndex = lly.BuildConfigFindLayer("OtherName", true)

	dm, err := lly.BuildConfigByName("DAMod")
	if err == nil {
		errors.Log(ly.Learn.NeuroMod.DAMod.SetString(dm))
	}
}

func (lly *Layer) DSMatrixPostBuild() {
	ly := lly.Params
	lly.MatrixPostBuild()
	ly.Striatum.PFIndex = lly.BuildConfigFindLayer("PFName", true)
	ly.DSMatrix.PatchD1Index = lly.BuildConfigFindLayer("PatchD1Name", true)
	ly.DSMatrix.PatchD2Index = lly.BuildConfigFindLayer("PatchD2Name", true)
}

func (lly *Layer) VSMatrixPostBuild() {
	lly.MatrixPostBuild()
}

func (lly *Layer) DSPatchDefaults() {
	ly := lly.Params
	ly.VSPatchDefaults()
	ly.Acts.Dend.ModBase = 1
	ly.Acts.Dend.ModGain = 0
	ly.Learn.NeuroMod.AChLRateMod = 1
}

func (lly *Layer) PatchPostBuild() {
	ly := lly.Params
	ly.Striatum.OtherIndex = lly.BuildConfigFindLayer("OtherName", true)
	ly.Striatum.PFIndex = lly.BuildConfigFindLayer("PFName", true)
	dm, err := lly.BuildConfigByName("DAMod")
	if err == nil {
		errors.Log(ly.Learn.NeuroMod.DAMod.SetString(dm))
	}
}

////////  GP

func (lly *Layer) GPDefaults() {
	ly := lly.Params
	// GP is tonically self-active and has no FFFB inhibition
	// Defaults are for GPePr, Ak has special values below
	ly.Acts.Init.GeBase = 0.4
	ly.Acts.Init.GeVar = 0.2
	ly.Acts.Init.GiVar = 0.1
	ly.Acts.Decay.Act = 0
	ly.Acts.Decay.Glong = 1
	ly.Acts.NMDA.Ge = 0 // carryover of NMDA was causing issues!
	ly.Acts.GabaB.Gk = 0
	ly.Inhib.ActAvg.Nominal = 1 // very active!
	ly.Inhib.Layer.On.SetBool(false)
	ly.Inhib.Pool.On.SetBool(false)

	if ly.GP.GPType == GPeAk {
		ly.Acts.Init.GeBase = 0.2 // definitely lower in bio data, necessary
		ly.Acts.Init.GeVar = 0.1
	}

	for _, pj := range lly.RecvPaths {
		pj.Params.SetFixedWts()
		pj.Params.SWts.Init.Mean = 0.75 // 0.75 -- very similar -- maybe a bit more reliable with 0.8 / 0
		pj.Params.SWts.Init.Var = 0.25  // 0.25
		switch ly.GP.GPType {
		case GPePr:
			switch pj.Send.Type {
			case VSMatrixLayer, DSMatrixLayer:
				pj.Params.PathScale.Abs = 1 // MtxNoToGPePr -- primary NoGo pathway
			case GPLayer:
				pj.Params.PathScale.Abs = 4.5 // 4.5 best for DS; GPePrToGPePr -- must be very strong
			case STNLayer:
				pj.Params.PathScale.Abs = 0.5 // STNToGPePr
			}
		case GPeAk:
			switch pj.Send.Type {
			case VSMatrixLayer, DSMatrixLayer:
				pj.Params.PathScale.Abs = 0.6 // MtxGoToGPeAk
			case GPLayer:
				pj.Params.PathScale.Abs = 1 // GPePrToGPeAk
			case STNLayer:
				pj.Params.PathScale.Abs = 0.1 // STNToGPAk
			}
		}
	}

	if ly.GP.GPType == GPi {
		lly.GPiDefaults()
	}
}

func (lly *Layer) GPiDefaults() {
	ly := lly.Params
	ly.Acts.Init.GeBase = 0.3
	ly.Acts.Init.GeVar = 0.1
	ly.Acts.Init.GiVar = 0.1
	// note: GPLayer took care of STN input paths

	for _, pj := range lly.RecvPaths {
		pj.Params.SetFixedWts()
		pj.Params.SWts.Init.Mean = 0.75    // 0.75  see above
		pj.Params.SWts.Init.Var = 0.25     // 0.25
		if pj.Send.Type == VSMatrixLayer { // MatrixGoToGPi
			pj.Params.PathScale.Abs = 0.2
		} else if pj.Send.Type == DSMatrixLayer {
			pj.Params.PathScale.Abs = 1
		} else if pj.Send.Type == GPLayer { // GPePrToGPi
			pj.Params.PathScale.Abs = 1
		} else if pj.Send.Type == STNLayer { // STNToGPi
			pj.Params.PathScale.Abs = 0.2
		}
	}
}

func (lly *Layer) GPPostBuild() {
	ly := lly.Params
	gpnm, err := lly.BuildConfigByName("GPType")
	if err == nil {
		errors.Log(ly.GP.GPType.SetString(gpnm))
	}
}

////////  STN

func (lly *Layer) STNDefaults() {
	ly := lly.Params
	// STN is tonically self-active and has no FFFB inhibition
	ly.Acts.Init.GeBase = 0.1 // was 0.3
	ly.Acts.Init.GeVar = 0.1
	ly.Acts.Init.GiVar = 0.1
	ly.Acts.SKCa.Gk = 2
	ly.Acts.SKCa.CaRDecayTau = 150 // 150 > 80 for longer theta windows
	ly.Acts.Kir.Gk = 10            // 10 > 5 -- key for pause
	ly.Acts.Decay.Act = 0
	ly.Acts.Decay.Glong = 0
	ly.Acts.Decay.LearnCa = 1 // key for non-spaced trials, to refresh immediately
	ly.Acts.Dend.SSGi = 0
	ly.Acts.NMDA.Ge = 0 // fine with 0
	ly.Acts.GabaB.Gk = 0
	ly.Inhib.Layer.On.SetBool(true)
	ly.Inhib.Layer.Gi = 0.5
	ly.Inhib.Layer.FB = 0
	ly.Inhib.Pool.On.SetBool(false)
	ly.Inhib.Pool.Gi = 0.5
	ly.Inhib.Pool.FB = 0
	ly.Inhib.ActAvg.Nominal = 0.15
	ly.Learn.NeuroMod.AChDisInhib = 0 // was 2,

	// if ly.Cls == "VSTNLayer" {
	// 	ly.Inhib.Layer.On.SetBool(false)
	// } else {
	// 	ly.Inhib.Layer.On.SetBool(true)
	// }

	for _, pj := range lly.RecvPaths {
		pj.Params.SetFixedWts()
		pj.Params.SWts.Init.Mean = 0.75
		pj.Params.SWts.Init.Var = 0.25
		if pj.Send.Type == GPLayer { // GPePrToSTN
			pj.Params.PathScale.Abs = 0.4
		} else {
			pj.Params.PathScale.Abs = 2.0 // pfc inputs
		}
	}
}

////////  BGThal

func (lly *Layer) BGThalDefaults() {
	ly := lly.Params
	// note: not tonically active
	// ly.Acts.NMDA.Ge = 0 // needs NMDA
	ly.Acts.Decay.Act = 1
	ly.Acts.Decay.Glong = 0.6
	ly.Acts.Dend.SSGi = 0
	ly.Inhib.ActAvg.Nominal = 0.1
	ly.Inhib.Layer.On.SetBool(true)
	ly.Inhib.Layer.Gi = 0.6
	ly.Inhib.Pool.On.SetBool(false)
	ly.Inhib.Pool.Gi = 0.6

	ly.Learn.NeuroMod.AChDisInhib = 1

	for _, pj := range lly.RecvPaths {
		pj.Params.SetFixedWts()
		pj.Params.SWts.Init.Mean = 0.75
		pj.Params.SWts.Init.Var = 0.0
		if strings.HasSuffix(pj.Send.Name, "GPi") { // GPiToBGThal
			pj.Params.PathScale.Abs = 5 // can now be much stronger with PTMaint mod and maint dynamics
			pj.AddClass("GPiToBGThal")
		}
	}
}

////////  VSGated

func (ly *LayerParams) VSGatedDefaults() {
	ly.Inhib.ActAvg.Nominal = 0.5
	ly.Inhib.Layer.On.SetBool(true)
	ly.Inhib.Layer.Gi = 1
	ly.Inhib.Pool.On.SetBool(false)
	ly.Inhib.Pool.Gi = 1
	ly.Acts.Decay.Act = 1
	ly.Acts.Decay.Glong = 1
}
