// Copyright (c) 2024, The Emergent Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package axon

import (
	"time"

	"cogentcore.org/core/base/timer"
	"cogentcore.org/core/enums"
	"cogentcore.org/core/plot"
	"cogentcore.org/core/tensor/datafs"
	"cogentcore.org/core/tensor/stats/stats"
)

// StatPerTrialMSec returns a Stats function that reports the number of milliseconds
// per trial, for the given times and training mode enum values.
// The times should start at the Trial and go up from there: data will
// be recorded from the second time level. The statName is the name of another
// stat that is used to get the number of trials.
func StatPerTrialMSec(statDir *datafs.Data, statName string, trainMode enums.Enum, times ...enums.Enum) func(lmode enums.Enum, ltime enums.Enum, start bool) {
	var epcTimer timer.Time
	return func(lmode enums.Enum, ltime enums.Enum, start bool) {
		if lmode.Int64() != trainMode.Int64() || ltime.Int64() <= times[0].Int64() {
			return
		}
		name := "PerTrialMSec"
		modeDir := statDir.RecycleDir(lmode.String())
		timeDir := modeDir.RecycleDir(ltime.String())
		tsr := datafs.Value[float64](timeDir, name)
		if start {
			tsr.SetNumRows(0)
			if ps := plot.GetStylersFrom(tsr); ps == nil {
				ps.Add(func(s *plot.Style) {
					s.Range.SetMin(0).SetMax(1)
				})
				plot.SetStylersTo(tsr, ps)
			}
			return
		}
		for i, tm := range times {
			if ltime.Int64() != tm.Int64() {
				continue
			}
			switch i {
			case 0:
				continue
			case 1:
				epcTimer.Stop()
				subd := modeDir.RecycleDir(times[0].String())
				trls := subd.Value(statName) // must be a stat
				epcTimer.N = trls.Len()
				pertrl := float64(epcTimer.Avg()) / float64(time.Millisecond)
				tsr.AppendRowFloat(pertrl)
				epcTimer.ResetStart()
			default:
				subd := modeDir.RecycleDir(times[i-1].String())
				stat := stats.StatMean.Call(subd.Value(name))
				tsr.AppendRow(stat)
			}
		}
	}
}

// StatDiagnostics returns a Stats function that computes key
// statistics.
func StatDiagnostics(statDir *datafs.Data, net *Network, layerNames []string, trainMode enums.Enum, times ...enums.Enum) func(lmode enums.Enum, ltime enums.Enum, start bool) {
	statNames := []string{"ActMAvg", "ActMMax", "MaxGeM"}
	return func(lmode enums.Enum, ltime enums.Enum, start bool) {
		if lmode.Int64() != trainMode.Int64() || ltime.Int64() < times[0].Int64() {
			return
		}
		modeDir := statDir.RecycleDir(lmode.String())
		timeDir := modeDir.RecycleDir(ltime.String())
		ndata := net.Context().NData
		for _, lnm := range layerNames {
			for si, statName := range statNames {
				ly := net.LayerByName(lnm)
				lpi := ly.Params.PoolIndex(0)
				name := lnm + "_" + statName
				tsr := datafs.Value[float64](timeDir, name)
				if start {
					tsr.SetNumRows(0)
					if ps := plot.GetStylersFrom(tsr); ps == nil {
						ps.Add(func(s *plot.Style) {
							s.Range.SetMin(0).SetMax(1)
						})
						plot.SetStylersTo(tsr, ps)
					}
					return
				}
				for i, tm := range times {
					if ltime.Int64() != tm.Int64() {
						continue
					}
					switch i {
					case 0:
						for di := range ndata {
							var stat float32
							switch si {
							case 0:
								stat = PoolAvgMax(AMAct, AMMinus, Avg, lpi, di)
							case 1:
								stat = PoolAvgMax(AMAct, AMMinus, Max, lpi, di)
							case 2:
								stat = PoolAvgMax(AMGeInt, AMMinus, Max, lpi, di)
							}
							tsr.AppendRowFloat(float64(stat))
						}
					// todo: last 5 here
					default:
						subd := modeDir.RecycleDir(times[i-1].String())
						stat := stats.StatMean.Call(subd.Value(name))
						tsr.AppendRow(stat)
					}
				}
			}
		}
	}
}
