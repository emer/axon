// Code generated by "core generate -add-types -add-funcs -setters -gosl"; DO NOT EDIT.

package emery

import (
	"image"

	"cogentcore.org/core/core"
	"cogentcore.org/core/math32/minmax"
	"cogentcore.org/core/types"
	"cogentcore.org/core/xyz/xyzcore"
	"cogentcore.org/lab/base/randx"
	"cogentcore.org/lab/physics/builder"
	"cogentcore.org/lab/physics/phyxyz"
	"cogentcore.org/lab/tensor"
	"cogentcore.org/lab/tensorfs"
	"github.com/emer/emergent/v2/env"
	"github.com/emer/emergent/v2/popcode"
	"github.com/emer/v1vision/v1std"
)

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.Actions", IDName: "actions", Doc: "Actions are motor actions as abstracted coordinated plans\nthat unfold over time, at a level above individual muscles.\nThey are recorded in data continuously, with 0 meaning no\naction being taken, and non-zero indicating strength of action."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.EmeryBodies", IDName: "emery-bodies", Doc: "EmeryBodies are indexes for the physics body elements of Emery."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.Emery", IDName: "emery", Doc: "Emery encapsulates all the emery agent config and physics.", Fields: []types.Field{{Name: "Length", Doc: "full length of emery"}, {Name: "Obj", Doc: "emery object"}, {Name: "XZ", Doc: "PlaneXZ joint for controlling 2D position."}, {Name: "Neck", Doc: "joint for the neck."}, {Name: "EyeR", Doc: "Right eye of emery"}}})

// SetLength sets the [Emery.Length]:
// full length of emery
func (t *Emery) SetLength(v float32) *Emery { t.Length = v; return t }

// SetObj sets the [Emery.Obj]:
// emery object
func (t *Emery) SetObj(v *builder.Object) *Emery { t.Obj = v; return t }

// SetXZ sets the [Emery.XZ]:
// PlaneXZ joint for controlling 2D position.
func (t *Emery) SetXZ(v *builder.Joint) *Emery { t.XZ = v; return t }

// SetNeck sets the [Emery.Neck]:
// joint for the neck.
func (t *Emery) SetNeck(v *builder.Joint) *Emery { t.Neck = v; return t }

// SetEyeR sets the [Emery.EyeR]:
// Right eye of emery
func (t *Emery) SetEyeR(v *builder.Body) *Emery { t.EyeR = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.EmeryState", IDName: "emery-state", Doc: "EmeryState has all the state info for each Emery instance.", Fields: []types.Field{{Name: "SenseValues", Doc: "SenseValues has the current sensory values from physics model,\nstored here by the Sensor function for subsequent recording."}, {Name: "SenseAverages", Doc: "SenseAverages has the average delayed sensory values over\nSensoryWindow, which goes into SenseNormed for rendering."}, {Name: "SenseNormed", Doc: "SenseNormed has the normalized versions of SenseAverages,\nwhich is what is actually rendered."}, {Name: "EyeRImage", Doc: "current captured images"}, {Name: "EyeLImage", Doc: "current captured images"}, {Name: "NextActions", Doc: "NextActions are the next action values set by sim, and rendered\ndepending on RenderNextAction value."}, {Name: "CurActions", Doc: "CurActions are the current action values, updated by TakeNextAction,\nand rendered depending on RenderNextAction value."}}})

// SetSenseValues sets the [EmeryState.SenseValues]:
// SenseValues has the current sensory values from physics model,
// stored here by the Sensor function for subsequent recording.
func (t *EmeryState) SetSenseValues(v [SensesN]float32) *EmeryState { t.SenseValues = v; return t }

// SetSenseAverages sets the [EmeryState.SenseAverages]:
// SenseAverages has the average delayed sensory values over
// SensoryWindow, which goes into SenseNormed for rendering.
func (t *EmeryState) SetSenseAverages(v [SensesN]float32) *EmeryState { t.SenseAverages = v; return t }

// SetSenseNormed sets the [EmeryState.SenseNormed]:
// SenseNormed has the normalized versions of SenseAverages,
// which is what is actually rendered.
func (t *EmeryState) SetSenseNormed(v [SensesN]float32) *EmeryState { t.SenseNormed = v; return t }

// SetEyeRImage sets the [EmeryState.EyeRImage]:
// current captured images
func (t *EmeryState) SetEyeRImage(v image.Image) *EmeryState { t.EyeRImage = v; return t }

// SetEyeLImage sets the [EmeryState.EyeLImage]:
// current captured images
func (t *EmeryState) SetEyeLImage(v image.Image) *EmeryState { t.EyeLImage = v; return t }

// SetNextActions sets the [EmeryState.NextActions]:
// NextActions are the next action values set by sim, and rendered
// depending on RenderNextAction value.
func (t *EmeryState) SetNextActions(v [ActionsN]float32) *EmeryState { t.NextActions = v; return t }

// SetCurActions sets the [EmeryState.CurActions]:
// CurActions are the current action values, updated by TakeNextAction,
// and rendered depending on RenderNextAction value.
func (t *EmeryState) SetCurActions(v [ActionsN]float32) *EmeryState { t.CurActions = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.EmeryEnv", IDName: "emery-env", Doc: "EmeryEnv is the emery rat environment.", Fields: []types.Field{{Name: "Name", Doc: "name of this environment: Train or Test"}, {Name: "NData", Doc: "NData is number of data-parallel Emery's to run."}, {Name: "RenderStates", Doc: "RenderStates should be updated by sim prior to running Step.\nIt tells Step to render States input for the model.\nOtherwise, physics is updated and sensory state is recorded, but\nno rendering. Rendered states average over SensoryWindow."}, {Name: "SensoryWindow", Doc: "SensoryWindow is the time window in Steps (ms) over which the sensory\nstate is averaged, for the purposes of rendering state."}, {Name: "ModelSteps", Doc: "Number of model steps per env Step. This is on top of the\nphysics SubSteps."}, {Name: "ActionStiff", Doc: "ActionStiff is the stiffness for performing actions."}, {Name: "AngleCode", Doc: "angle population code values, in normalized units"}, {Name: "LinearCode", Doc: "population code for linear values, -1..1, in normalized units"}, {Name: "Motion", Doc: "Visual motion processing"}, {Name: "MotionImage", Doc: "Image processing for Motion."}, {Name: "UnitsPer", Doc: "UnitsPer is the number of units per localist value."}, {Name: "LinearUnits", Doc: "LinearUnits is the number of units per linear value."}, {Name: "AngleUnits", Doc: "AngleUnits is the number of units per angle value."}, {Name: "LeftEye", Doc: "LeftEye determines whether to process left eye image or not."}, {Name: "World", Doc: "World specifies the physical world parameters."}, {Name: "Emery", Doc: "Emery has the parameters for (the first) Emery."}, {Name: "Params", Doc: "Params are sensory and motor parameters."}, {Name: "Physics", Doc: "The core physics elements: Model, Builder, Scene"}, {Name: "Camera", Doc: "Camera has offscreen render camera settings"}, {Name: "CurrentTime", Doc: "CurrentTime is the current timestep in msec. Counts up every Step,\n1 per msec (cycle)."}, {Name: "SenseData", Doc: "SenseData records the sensory data for each emery agent."}, {Name: "ActionData", Doc: "ActionData records the motor action data for each emery agent."}, {Name: "BufferSize", Doc: "BufferSize is the number of time steps (ms) to retain in the tensorfs\nsensory and motor state buffers."}, {Name: "WriteIndex", Doc: "WriteIndex is the current write index in tensorfs Cycle-level\nsensory and motor data. Add post-increments."}, {Name: "AvgWriteIndex", Doc: "AvgWriteIndex is the current write index for averages data,\nwhich is less frequently updated."}, {Name: "SensoryDelays", Doc: "SensoryDelays are the actual delays for each sense: from [SensoryDelays]\nparams."}, {Name: "SenseNorms", Doc: "SenseNorms are the normalization factors for each sense (1/typical max)."}, {Name: "Emerys", Doc: "Emerys has the state values for each NData emery."}, {Name: "States", Doc: "States is the current rendered state tensors."}, {Name: "Rand", Doc: "Rand is the random number generator for the env.\nAll random calls must use this.\nSet seed here for weight initialization values."}, {Name: "Cycle", Doc: "Cycle tracks cycles, for interval-based updates etc."}, {Name: "RandSeed", Doc: "random seed"}}})

// SetName sets the [EmeryEnv.Name]:
// name of this environment: Train or Test
func (t *EmeryEnv) SetName(v string) *EmeryEnv { t.Name = v; return t }

// SetNData sets the [EmeryEnv.NData]:
// NData is number of data-parallel Emery's to run.
func (t *EmeryEnv) SetNData(v int) *EmeryEnv { t.NData = v; return t }

// SetRenderStates sets the [EmeryEnv.RenderStates]:
// RenderStates should be updated by sim prior to running Step.
// It tells Step to render States input for the model.
// Otherwise, physics is updated and sensory state is recorded, but
// no rendering. Rendered states average over SensoryWindow.
func (t *EmeryEnv) SetRenderStates(v bool) *EmeryEnv { t.RenderStates = v; return t }

// SetSensoryWindow sets the [EmeryEnv.SensoryWindow]:
// SensoryWindow is the time window in Steps (ms) over which the sensory
// state is averaged, for the purposes of rendering state.
func (t *EmeryEnv) SetSensoryWindow(v int) *EmeryEnv { t.SensoryWindow = v; return t }

// SetModelSteps sets the [EmeryEnv.ModelSteps]:
// Number of model steps per env Step. This is on top of the
// physics SubSteps.
func (t *EmeryEnv) SetModelSteps(v int) *EmeryEnv { t.ModelSteps = v; return t }

// SetActionStiff sets the [EmeryEnv.ActionStiff]:
// ActionStiff is the stiffness for performing actions.
func (t *EmeryEnv) SetActionStiff(v float32) *EmeryEnv { t.ActionStiff = v; return t }

// SetAngleCode sets the [EmeryEnv.AngleCode]:
// angle population code values, in normalized units
func (t *EmeryEnv) SetAngleCode(v popcode.Ring) *EmeryEnv { t.AngleCode = v; return t }

// SetLinearCode sets the [EmeryEnv.LinearCode]:
// population code for linear values, -1..1, in normalized units
func (t *EmeryEnv) SetLinearCode(v popcode.OneD) *EmeryEnv { t.LinearCode = v; return t }

// SetMotion sets the [EmeryEnv.Motion]:
// Visual motion processing
func (t *EmeryEnv) SetMotion(v v1std.MotionDoG) *EmeryEnv { t.Motion = v; return t }

// SetMotionImage sets the [EmeryEnv.MotionImage]:
// Image processing for Motion.
func (t *EmeryEnv) SetMotionImage(v v1std.Image) *EmeryEnv { t.MotionImage = v; return t }

// SetUnitsPer sets the [EmeryEnv.UnitsPer]:
// UnitsPer is the number of units per localist value.
func (t *EmeryEnv) SetUnitsPer(v int) *EmeryEnv { t.UnitsPer = v; return t }

// SetLinearUnits sets the [EmeryEnv.LinearUnits]:
// LinearUnits is the number of units per linear value.
func (t *EmeryEnv) SetLinearUnits(v int) *EmeryEnv { t.LinearUnits = v; return t }

// SetAngleUnits sets the [EmeryEnv.AngleUnits]:
// AngleUnits is the number of units per angle value.
func (t *EmeryEnv) SetAngleUnits(v int) *EmeryEnv { t.AngleUnits = v; return t }

// SetLeftEye sets the [EmeryEnv.LeftEye]:
// LeftEye determines whether to process left eye image or not.
func (t *EmeryEnv) SetLeftEye(v bool) *EmeryEnv { t.LeftEye = v; return t }

// SetWorld sets the [EmeryEnv.World]:
// World specifies the physical world parameters.
func (t *EmeryEnv) SetWorld(v World) *EmeryEnv { t.World = v; return t }

// SetEmery sets the [EmeryEnv.Emery]:
// Emery has the parameters for (the first) Emery.
func (t *EmeryEnv) SetEmery(v Emery) *EmeryEnv { t.Emery = v; return t }

// SetParams sets the [EmeryEnv.Params]:
// Params are sensory and motor parameters.
func (t *EmeryEnv) SetParams(v SensoryMotorParams) *EmeryEnv { t.Params = v; return t }

// SetPhysics sets the [EmeryEnv.Physics]:
// The core physics elements: Model, Builder, Scene
func (t *EmeryEnv) SetPhysics(v builder.Physics) *EmeryEnv { t.Physics = v; return t }

// SetCamera sets the [EmeryEnv.Camera]:
// Camera has offscreen render camera settings
func (t *EmeryEnv) SetCamera(v phyxyz.Camera) *EmeryEnv { t.Camera = v; return t }

// SetCurrentTime sets the [EmeryEnv.CurrentTime]:
// CurrentTime is the current timestep in msec. Counts up every Step,
// 1 per msec (cycle).
func (t *EmeryEnv) SetCurrentTime(v int) *EmeryEnv { t.CurrentTime = v; return t }

// SetSenseData sets the [EmeryEnv.SenseData]:
// SenseData records the sensory data for each emery agent.
func (t *EmeryEnv) SetSenseData(v *tensorfs.Node) *EmeryEnv { t.SenseData = v; return t }

// SetActionData sets the [EmeryEnv.ActionData]:
// ActionData records the motor action data for each emery agent.
func (t *EmeryEnv) SetActionData(v *tensorfs.Node) *EmeryEnv { t.ActionData = v; return t }

// SetBufferSize sets the [EmeryEnv.BufferSize]:
// BufferSize is the number of time steps (ms) to retain in the tensorfs
// sensory and motor state buffers.
func (t *EmeryEnv) SetBufferSize(v int) *EmeryEnv { t.BufferSize = v; return t }

// SetWriteIndex sets the [EmeryEnv.WriteIndex]:
// WriteIndex is the current write index in tensorfs Cycle-level
// sensory and motor data. Add post-increments.
func (t *EmeryEnv) SetWriteIndex(v int) *EmeryEnv { t.WriteIndex = v; return t }

// SetAvgWriteIndex sets the [EmeryEnv.AvgWriteIndex]:
// AvgWriteIndex is the current write index for averages data,
// which is less frequently updated.
func (t *EmeryEnv) SetAvgWriteIndex(v int) *EmeryEnv { t.AvgWriteIndex = v; return t }

// SetSensoryDelays sets the [EmeryEnv.SensoryDelays]:
// SensoryDelays are the actual delays for each sense: from [SensoryDelays]
// params.
func (t *EmeryEnv) SetSensoryDelays(v [SensesN]int) *EmeryEnv { t.SensoryDelays = v; return t }

// SetSenseNorms sets the [EmeryEnv.SenseNorms]:
// SenseNorms are the normalization factors for each sense (1/typical max).
func (t *EmeryEnv) SetSenseNorms(v [SensesN]float32) *EmeryEnv { t.SenseNorms = v; return t }

// SetEmerys sets the [EmeryEnv.Emerys]:
// Emerys has the state values for each NData emery.
func (t *EmeryEnv) SetEmerys(v ...EmeryState) *EmeryEnv { t.Emerys = v; return t }

// SetStates sets the [EmeryEnv.States]:
// States is the current rendered state tensors.
func (t *EmeryEnv) SetStates(v map[string]*tensor.Float32) *EmeryEnv { t.States = v; return t }

// SetRand sets the [EmeryEnv.Rand]:
// Rand is the random number generator for the env.
// All random calls must use this.
// Set seed here for weight initialization values.
func (t *EmeryEnv) SetRand(v randx.SysRand) *EmeryEnv { t.Rand = v; return t }

// SetCycle sets the [EmeryEnv.Cycle]:
// Cycle tracks cycles, for interval-based updates etc.
func (t *EmeryEnv) SetCycle(v env.Counter) *EmeryEnv { t.Cycle = v; return t }

// SetRandSeed sets the [EmeryEnv.RandSeed]:
// random seed
func (t *EmeryEnv) SetRandSeed(v int64) *EmeryEnv { t.RandSeed = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.GUI", IDName: "gui", Doc: "GUI provides a GUI view onto the EmeryEnv", Fields: []types.Field{{Name: "Env", Doc: "Env is the environment we're viewing"}, {Name: "Di", Doc: "Di is the data parallel item to view."}, {Name: "Scene", Doc: "GUI version of scene"}, {Name: "SceneEditor", Doc: "3D visualization of the Scene"}, {Name: "EyeRImageDisp", Doc: "first-person right-eye full field view"}, {Name: "EyeLImageDisp", Doc: "first-person left-eye fovea view"}}})

// SetEnv sets the [GUI.Env]:
// Env is the environment we're viewing
func (t *GUI) SetEnv(v *EmeryEnv) *GUI { t.Env = v; return t }

// SetDi sets the [GUI.Di]:
// Di is the data parallel item to view.
func (t *GUI) SetDi(v int) *GUI { t.Di = v; return t }

// SetScene sets the [GUI.Scene]:
// GUI version of scene
func (t *GUI) SetScene(v *phyxyz.Scene) *GUI { t.Scene = v; return t }

// SetSceneEditor sets the [GUI.SceneEditor]:
// 3D visualization of the Scene
func (t *GUI) SetSceneEditor(v *xyzcore.SceneEditor) *GUI { t.SceneEditor = v; return t }

// SetEyeRImageDisp sets the [GUI.EyeRImageDisp]:
// first-person right-eye full field view
func (t *GUI) SetEyeRImageDisp(v *core.Image) *GUI { t.EyeRImageDisp = v; return t }

// SetEyeLImageDisp sets the [GUI.EyeLImageDisp]:
// first-person left-eye fovea view
func (t *GUI) SetEyeLImageDisp(v *core.Image) *GUI { t.EyeLImageDisp = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.Senses", IDName: "senses", Doc: "Senses are sensory inputs that unfold over time.\nCan also use to store abstracted sensory state."})

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.SensoryDelays", IDName: "sensory-delays", Doc: "SensoryDelays are delays from motor actions for different sensory modalities.", Fields: []types.Field{{Name: "Vestibular"}, {Name: "Visual"}}})

// SetVestibular sets the [SensoryDelays.Vestibular]
func (t *SensoryDelays) SetVestibular(v int) *SensoryDelays { t.Vestibular = v; return t }

// SetVisual sets the [SensoryDelays.Visual]
func (t *SensoryDelays) SetVisual(v int) *SensoryDelays { t.Visual = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.SensoryMotorParams", IDName: "sensory-motor-params", Doc: "SensoryMotorParams are parameters for sensory and motor properties.", Fields: []types.Field{{Name: "MaxRotate", Doc: "MaxRotate is maximum rotation angle magnitude per action, in degrees."}, {Name: "VisMotionInterval", Doc: "VisMotionInterval is interval between vis motion computation in cycles.\nThis is a very expensive computation in general so spacing it out."}, {Name: "Delays", Doc: "Delays are sensory delays"}}})

// SetMaxRotate sets the [SensoryMotorParams.MaxRotate]:
// MaxRotate is maximum rotation angle magnitude per action, in degrees.
func (t *SensoryMotorParams) SetMaxRotate(v float32) *SensoryMotorParams { t.MaxRotate = v; return t }

// SetVisMotionInterval sets the [SensoryMotorParams.VisMotionInterval]:
// VisMotionInterval is interval between vis motion computation in cycles.
// This is a very expensive computation in general so spacing it out.
func (t *SensoryMotorParams) SetVisMotionInterval(v int) *SensoryMotorParams {
	t.VisMotionInterval = v
	return t
}

// SetDelays sets the [SensoryMotorParams.Delays]:
// Delays are sensory delays
func (t *SensoryMotorParams) SetDelays(v SensoryDelays) *SensoryMotorParams { t.Delays = v; return t }

var _ = types.AddType(&types.Type{Name: "github.com/emer/axon/v2/sims/deepspace/emery.World", IDName: "world", Doc: "World describes the physics world parameters.", Fields: []types.Field{{Name: "Depth", Doc: "computed total depth, starts at 0 goes deep"}, {Name: "Width", Doc: "computed total width"}, {Name: "Thick", Doc: "thickness of walls"}, {Name: "HalfWidth", Doc: "half width for centering on 0 X"}, {Name: "ObjWidth", Doc: "ObjWidth is the range in width of objects (landmarks)."}, {Name: "ObjHeight", Doc: "ObjHeight is the range in height of objects (landmarks)."}, {Name: "ObjSpace", Doc: "ObjSpace is the range in space between objects (landmarks) in degrees."}}})

// SetDepth sets the [World.Depth]:
// computed total depth, starts at 0 goes deep
func (t *World) SetDepth(v float32) *World { t.Depth = v; return t }

// SetWidth sets the [World.Width]:
// computed total width
func (t *World) SetWidth(v float32) *World { t.Width = v; return t }

// SetThick sets the [World.Thick]:
// thickness of walls
func (t *World) SetThick(v float32) *World { t.Thick = v; return t }

// SetHalfWidth sets the [World.HalfWidth]:
// half width for centering on 0 X
func (t *World) SetHalfWidth(v float32) *World { t.HalfWidth = v; return t }

// SetObjWidth sets the [World.ObjWidth]:
// ObjWidth is the range in width of objects (landmarks).
func (t *World) SetObjWidth(v minmax.F32) *World { t.ObjWidth = v; return t }

// SetObjHeight sets the [World.ObjHeight]:
// ObjHeight is the range in height of objects (landmarks).
func (t *World) SetObjHeight(v minmax.F32) *World { t.ObjHeight = v; return t }

// SetObjSpace sets the [World.ObjSpace]:
// ObjSpace is the range in space between objects (landmarks) in degrees.
func (t *World) SetObjSpace(v minmax.F32) *World { t.ObjSpace = v; return t }
